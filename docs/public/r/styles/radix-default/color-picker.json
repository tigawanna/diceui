{
  "name": "color-picker",
  "dependencies": [
    "radix-ui"
  ],
  "registryDependencies": [
    "button",
    "input",
    "popover",
    "select",
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/color-picker.tsx",
      "content": "\"use client\";\r\n\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\nimport { PipetteIcon } from \"lucide-react\";\r\nimport {\r\n  Direction as DirectionPrimitive,\r\n  Slider as SliderPrimitive,\r\n  Slot as SlotPrimitive,\r\n} from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from \"@/components/ui/popover\";\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n} from \"@/components/ui/select\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { VisuallyHiddenInput } from \"@/registry/bases/radix/components/visually-hidden-input\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"ColorPicker\";\r\nconst ROOT_IMPL_NAME = \"ColorPickerImpl\";\r\nconst TRIGGER_NAME = \"ColorPickerTrigger\";\r\nconst CONTENT_NAME = \"ColorPickerContent\";\r\nconst AREA_NAME = \"ColorPickerArea\";\r\nconst HUE_SLIDER_NAME = \"ColorPickerHueSlider\";\r\nconst ALPHA_SLIDER_NAME = \"ColorPickerAlphaSlider\";\r\nconst SWATCH_NAME = \"ColorPickerSwatch\";\r\nconst EYE_DROPPER_NAME = \"ColorPickerEyeDropper\";\r\nconst FORMAT_SELECT_NAME = \"ColorPickerFormatSelect\";\r\nconst INPUT_NAME = \"ColorPickerInput\";\r\n\r\nconst colorFormats = [\"hex\", \"rgb\", \"hsl\", \"hsb\"] as const;\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof ColorPicker>;\r\ntype AreaElement = React.ComponentRef<typeof ColorPickerArea>;\r\ntype InputElement = React.ComponentRef<typeof ColorPickerInput>;\r\n\r\ntype ColorFormat = (typeof colorFormats)[number];\r\n\r\n/**\r\n * @see https://gist.github.com/bkrmendy/f4582173f50fab209ddfef1377ab31e3\r\n */\r\ninterface EyeDropper {\r\n  open: (options?: { signal?: AbortSignal }) => Promise<{ sRGBHex: string }>;\r\n}\r\n\r\ndeclare global {\r\n  interface Window {\r\n    EyeDropper?: {\r\n      new (): EyeDropper;\r\n    };\r\n  }\r\n}\r\n\r\ninterface ColorValue {\r\n  r: number;\r\n  g: number;\r\n  b: number;\r\n  a: number;\r\n}\r\n\r\ninterface HSVColorValue {\r\n  h: number;\r\n  s: number;\r\n  v: number;\r\n  a: number;\r\n}\r\n\r\nfunction hexToRgb(hex: string, alpha?: number): ColorValue {\r\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n  return result\r\n    ? {\r\n        r: Number.parseInt(result[1] ?? \"0\", 16),\r\n        g: Number.parseInt(result[2] ?? \"0\", 16),\r\n        b: Number.parseInt(result[3] ?? \"0\", 16),\r\n        a: alpha ?? 1,\r\n      }\r\n    : { r: 0, g: 0, b: 0, a: alpha ?? 1 };\r\n}\r\n\r\nfunction rgbToHex(color: ColorValue): string {\r\n  const toHex = (n: number) => {\r\n    const hex = Math.round(n).toString(16);\r\n    return hex.length === 1 ? `0${hex}` : hex;\r\n  };\r\n  return `#${toHex(color.r)}${toHex(color.g)}${toHex(color.b)}`;\r\n}\r\n\r\nfunction rgbToHsv(color: ColorValue): HSVColorValue {\r\n  const r = color.r / 255;\r\n  const g = color.g / 255;\r\n  const b = color.b / 255;\r\n\r\n  const max = Math.max(r, g, b);\r\n  const min = Math.min(r, g, b);\r\n  const diff = max - min;\r\n\r\n  let h = 0;\r\n  if (diff !== 0) {\r\n    switch (max) {\r\n      case r:\r\n        h = ((g - b) / diff) % 6;\r\n        break;\r\n      case g:\r\n        h = (b - r) / diff + 2;\r\n        break;\r\n      case b:\r\n        h = (r - g) / diff + 4;\r\n        break;\r\n    }\r\n  }\r\n  h = Math.round(h * 60);\r\n  if (h < 0) h += 360;\r\n\r\n  const s = max === 0 ? 0 : diff / max;\r\n  const v = max;\r\n\r\n  return {\r\n    h,\r\n    s: Math.round(s * 100),\r\n    v: Math.round(v * 100),\r\n    a: color.a,\r\n  };\r\n}\r\n\r\nfunction hsvToRgb(hsv: HSVColorValue): ColorValue {\r\n  const h = hsv.h / 360;\r\n  const s = hsv.s / 100;\r\n  const v = hsv.v / 100;\r\n\r\n  const i = Math.floor(h * 6);\r\n  const f = h * 6 - i;\r\n  const p = v * (1 - s);\r\n  const q = v * (1 - f * s);\r\n  const t = v * (1 - (1 - f) * s);\r\n\r\n  let r: number;\r\n  let g: number;\r\n  let b: number;\r\n\r\n  switch (i % 6) {\r\n    case 0: {\r\n      r = v;\r\n      g = t;\r\n      b = p;\r\n      break;\r\n    }\r\n    case 1: {\r\n      r = q;\r\n      g = v;\r\n      b = p;\r\n      break;\r\n    }\r\n    case 2: {\r\n      r = p;\r\n      g = v;\r\n      b = t;\r\n      break;\r\n    }\r\n    case 3: {\r\n      r = p;\r\n      g = q;\r\n      b = v;\r\n      break;\r\n    }\r\n    case 4: {\r\n      r = t;\r\n      g = p;\r\n      b = v;\r\n      break;\r\n    }\r\n    case 5: {\r\n      r = v;\r\n      g = p;\r\n      b = q;\r\n      break;\r\n    }\r\n    default: {\r\n      r = 0;\r\n      g = 0;\r\n      b = 0;\r\n    }\r\n  }\r\n\r\n  return {\r\n    r: Math.round(r * 255),\r\n    g: Math.round(g * 255),\r\n    b: Math.round(b * 255),\r\n    a: hsv.a,\r\n  };\r\n}\r\n\r\nfunction colorToString(color: ColorValue, format: ColorFormat = \"hex\"): string {\r\n  switch (format) {\r\n    case \"hex\":\r\n      return rgbToHex(color);\r\n    case \"rgb\":\r\n      return color.a < 1\r\n        ? `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`\r\n        : `rgb(${color.r}, ${color.g}, ${color.b})`;\r\n    case \"hsl\": {\r\n      const hsl = rgbToHsl(color);\r\n      return color.a < 1\r\n        ? `hsla(${hsl.h}, ${hsl.s}%, ${hsl.l}%, ${color.a})`\r\n        : `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;\r\n    }\r\n    case \"hsb\": {\r\n      const hsv = rgbToHsv(color);\r\n      return color.a < 1\r\n        ? `hsba(${hsv.h}, ${hsv.s}%, ${hsv.v}%, ${color.a})`\r\n        : `hsb(${hsv.h}, ${hsv.s}%, ${hsv.v}%)`;\r\n    }\r\n    default:\r\n      return rgbToHex(color);\r\n  }\r\n}\r\n\r\nfunction rgbToHsl(color: ColorValue) {\r\n  const r = color.r / 255;\r\n  const g = color.g / 255;\r\n  const b = color.b / 255;\r\n\r\n  const max = Math.max(r, g, b);\r\n  const min = Math.min(r, g, b);\r\n  const diff = max - min;\r\n  const sum = max + min;\r\n\r\n  const l = sum / 2;\r\n\r\n  let h = 0;\r\n  let s = 0;\r\n\r\n  if (diff !== 0) {\r\n    s = l > 0.5 ? diff / (2 - sum) : diff / sum;\r\n\r\n    if (max === r) {\r\n      h = (g - b) / diff + (g < b ? 6 : 0);\r\n    } else if (max === g) {\r\n      h = (b - r) / diff + 2;\r\n    } else if (max === b) {\r\n      h = (r - g) / diff + 4;\r\n    }\r\n    h /= 6;\r\n  }\r\n\r\n  return {\r\n    h: Math.round(h * 360),\r\n    s: Math.round(s * 100),\r\n    l: Math.round(l * 100),\r\n  };\r\n}\r\n\r\nfunction hslToRgb(\r\n  hsl: { h: number; s: number; l: number },\r\n  alpha = 1,\r\n): ColorValue {\r\n  const h = hsl.h / 360;\r\n  const s = hsl.s / 100;\r\n  const l = hsl.l / 100;\r\n\r\n  const c = (1 - Math.abs(2 * l - 1)) * s;\r\n  const x = c * (1 - Math.abs(((h * 6) % 2) - 1));\r\n  const m = l - c / 2;\r\n\r\n  let r = 0;\r\n  let g = 0;\r\n  let b = 0;\r\n\r\n  if (h >= 0 && h < 1 / 6) {\r\n    r = c;\r\n    g = x;\r\n    b = 0;\r\n  } else if (h >= 1 / 6 && h < 2 / 6) {\r\n    r = x;\r\n    g = c;\r\n    b = 0;\r\n  } else if (h >= 2 / 6 && h < 3 / 6) {\r\n    r = 0;\r\n    g = c;\r\n    b = x;\r\n  } else if (h >= 3 / 6 && h < 4 / 6) {\r\n    r = 0;\r\n    g = x;\r\n    b = c;\r\n  } else if (h >= 4 / 6 && h < 5 / 6) {\r\n    r = x;\r\n    g = 0;\r\n    b = c;\r\n  } else if (h >= 5 / 6 && h < 1) {\r\n    r = c;\r\n    g = 0;\r\n    b = x;\r\n  }\r\n\r\n  return {\r\n    r: Math.round((r + m) * 255),\r\n    g: Math.round((g + m) * 255),\r\n    b: Math.round((b + m) * 255),\r\n    a: alpha,\r\n  };\r\n}\r\n\r\nfunction parseColorString(value: string): ColorValue | null {\r\n  const trimmed = value.trim();\r\n\r\n  // Parse hex colors\r\n  if (trimmed.startsWith(\"#\")) {\r\n    const hexMatch = trimmed.match(/^#([a-fA-F0-9]{3}|[a-fA-F0-9]{6})$/);\r\n    if (hexMatch) {\r\n      return hexToRgb(trimmed);\r\n    }\r\n  }\r\n\r\n  // Parse rgb/rgba colors\r\n  const rgbMatch = trimmed.match(\r\n    /^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([\\d.]+))?\\s*\\)$/,\r\n  );\r\n  if (rgbMatch) {\r\n    return {\r\n      r: Number.parseInt(rgbMatch[1] ?? \"0\", 10),\r\n      g: Number.parseInt(rgbMatch[2] ?? \"0\", 10),\r\n      b: Number.parseInt(rgbMatch[3] ?? \"0\", 10),\r\n      a: rgbMatch[4] ? Number.parseFloat(rgbMatch[4]) : 1,\r\n    };\r\n  }\r\n\r\n  // Parse hsl/hsla colors\r\n  const hslMatch = trimmed.match(\r\n    /^hsla?\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([\\d.]+))?\\s*\\)$/,\r\n  );\r\n  if (hslMatch) {\r\n    const h = Number.parseInt(hslMatch[1] ?? \"0\", 10);\r\n    const s = Number.parseInt(hslMatch[2] ?? \"0\", 10) / 100;\r\n    const l = Number.parseInt(hslMatch[3] ?? \"0\", 10) / 100;\r\n    const a = hslMatch[4] ? Number.parseFloat(hslMatch[4]) : 1;\r\n\r\n    // Convert HSL to RGB\r\n    const c = (1 - Math.abs(2 * l - 1)) * s;\r\n    const x = c * (1 - Math.abs(((h / 60) % 2) - 1));\r\n    const m = l - c / 2;\r\n\r\n    let r = 0;\r\n    let g = 0;\r\n    let b = 0;\r\n\r\n    if (h >= 0 && h < 60) {\r\n      r = c;\r\n      g = x;\r\n      b = 0;\r\n    } else if (h >= 60 && h < 120) {\r\n      r = x;\r\n      g = c;\r\n      b = 0;\r\n    } else if (h >= 120 && h < 180) {\r\n      r = 0;\r\n      g = c;\r\n      b = x;\r\n    } else if (h >= 180 && h < 240) {\r\n      r = 0;\r\n      g = x;\r\n      b = c;\r\n    } else if (h >= 240 && h < 300) {\r\n      r = x;\r\n      g = 0;\r\n      b = c;\r\n    } else if (h >= 300 && h < 360) {\r\n      r = c;\r\n      g = 0;\r\n      b = x;\r\n    }\r\n\r\n    return {\r\n      r: Math.round((r + m) * 255),\r\n      g: Math.round((g + m) * 255),\r\n      b: Math.round((b + m) * 255),\r\n      a,\r\n    };\r\n  }\r\n\r\n  // Parse hsb/hsba colors\r\n  const hsbMatch = trimmed.match(\r\n    /^hsba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([\\d.]+))?\\s*\\)$/,\r\n  );\r\n  if (hsbMatch) {\r\n    const h = Number.parseInt(hsbMatch[1] ?? \"0\", 10);\r\n    const s = Number.parseInt(hsbMatch[2] ?? \"0\", 10);\r\n    const v = Number.parseInt(hsbMatch[3] ?? \"0\", 10);\r\n    const a = hsbMatch[4] ? Number.parseFloat(hsbMatch[4]) : 1;\r\n\r\n    return hsvToRgb({ h, s, v, a });\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\ninterface StoreState {\r\n  color: ColorValue;\r\n  hsv: HSVColorValue;\r\n  open: boolean;\r\n  format: ColorFormat;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (cb: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setColor: (value: ColorValue) => void;\r\n  setHsv: (value: HSVColorValue) => void;\r\n  setOpen: (value: boolean) => void;\r\n  setFormat: (value: ColorFormat) => void;\r\n  notify: () => void;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(\r\n      `\\`${consumerName}\\` must be used within \\`ColorPickerRoot\\``,\r\n    );\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<U>(selector: (state: StoreState) => U): U {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface ColorPickerContextValue {\r\n  dir: Direction;\r\n  disabled?: boolean;\r\n  inline?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n}\r\n\r\nconst ColorPickerContext = React.createContext<ColorPickerContextValue | null>(\r\n  null,\r\n);\r\n\r\nfunction useColorPickerContext(consumerName: string) {\r\n  const context = React.useContext(ColorPickerContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface ColorPickerProps\r\n  extends Omit<DivProps, \"onValueChange\">,\r\n    Pick<\r\n      React.ComponentProps<typeof Popover>,\r\n      \"defaultOpen\" | \"open\" | \"onOpenChange\" | \"modal\"\r\n    > {\r\n  value?: string;\r\n  defaultValue?: string;\r\n  onValueChange?: (value: string) => void;\r\n  dir?: Direction;\r\n  format?: ColorFormat;\r\n  defaultFormat?: ColorFormat;\r\n  onFormatChange?: (format: ColorFormat) => void;\r\n  name?: string;\r\n  asChild?: boolean;\r\n  disabled?: boolean;\r\n  inline?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n}\r\n\r\nfunction ColorPicker(props: ColorPickerProps) {\r\n  const {\r\n    value: valueProp,\r\n    defaultValue = \"#000000\",\r\n    onValueChange,\r\n    format: formatProp,\r\n    defaultFormat = \"hex\",\r\n    onFormatChange,\r\n    defaultOpen,\r\n    open: openProp,\r\n    onOpenChange,\r\n    name,\r\n    disabled,\r\n    inline,\r\n    readOnly,\r\n    required,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => {\r\n    const colorString = valueProp ?? defaultValue;\r\n    const color = hexToRgb(colorString);\r\n\r\n    return {\r\n      color,\r\n      hsv: rgbToHsv(color),\r\n      open: openProp ?? defaultOpen ?? false,\r\n      format: formatProp ?? defaultFormat,\r\n    };\r\n  });\r\n\r\n  const propsRef = useAsRef({\r\n    onValueChange,\r\n    onOpenChange,\r\n    onFormatChange,\r\n  });\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setColor: (value: ColorValue) => {\r\n        if (Object.is(stateRef.current.color, value)) return;\r\n\r\n        const prevState = { ...stateRef.current };\r\n        stateRef.current.color = value;\r\n\r\n        if (propsRef.current.onValueChange) {\r\n          const colorString = colorToString(value, prevState.format);\r\n          propsRef.current.onValueChange(colorString);\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      setHsv: (value: HSVColorValue) => {\r\n        if (Object.is(stateRef.current.hsv, value)) return;\r\n\r\n        const prevState = { ...stateRef.current };\r\n        stateRef.current.hsv = value;\r\n\r\n        if (propsRef.current.onValueChange) {\r\n          const colorValue = hsvToRgb(value);\r\n          const colorString = colorToString(colorValue, prevState.format);\r\n          propsRef.current.onValueChange(colorString);\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      setOpen: (value: boolean) => {\r\n        if (Object.is(stateRef.current.open, value)) return;\r\n\r\n        stateRef.current.open = value;\r\n\r\n        if (propsRef.current.onOpenChange) {\r\n          propsRef.current.onOpenChange(value);\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      setFormat: (value: ColorFormat) => {\r\n        if (Object.is(stateRef.current.format, value)) return;\r\n\r\n        stateRef.current.format = value;\r\n\r\n        if (propsRef.current.onFormatChange) {\r\n          propsRef.current.onFormatChange(value);\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef]);\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <ColorPickerImpl\r\n        {...rootProps}\r\n        value={valueProp}\r\n        defaultOpen={defaultOpen}\r\n        open={openProp}\r\n        name={name}\r\n        disabled={disabled}\r\n        inline={inline}\r\n        readOnly={readOnly}\r\n        required={required}\r\n      />\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface ColorPickerImplProps\r\n  extends Omit<\r\n    ColorPickerProps,\r\n    | \"defaultValue\"\r\n    | \"onValueChange\"\r\n    | \"onOpenChange\"\r\n    | \"format\"\r\n    | \"defaultFormat\"\r\n    | \"onFormatChange\"\r\n  > {}\r\n\r\nfunction ColorPickerImpl(props: ColorPickerImplProps) {\r\n  const {\r\n    value: valueProp,\r\n    dir: dirProp,\r\n    defaultOpen,\r\n    open: openProp,\r\n    name,\r\n    ref,\r\n    asChild,\r\n    disabled,\r\n    inline,\r\n    modal,\r\n    readOnly,\r\n    required,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const store = useStoreContext(ROOT_IMPL_NAME);\r\n\r\n  const dir = DirectionPrimitive.useDirection(dirProp);\r\n\r\n  const [formTrigger, setFormTrigger] = React.useState<RootElement | null>(\r\n    null,\r\n  );\r\n  const composedRef = useComposedRefs(ref, (node) => setFormTrigger(node));\r\n  const isFormControl = formTrigger ? !!formTrigger.closest(\"form\") : true;\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (valueProp !== undefined) {\r\n      const currentState = store.getState();\r\n      const color = hexToRgb(valueProp, currentState.color.a);\r\n      const hsv = rgbToHsv(color);\r\n      store.setColor(color);\r\n      store.setHsv(hsv);\r\n    }\r\n  }, [valueProp]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (openProp !== undefined) {\r\n      store.setOpen(openProp);\r\n    }\r\n  }, [openProp]);\r\n\r\n  const contextValue = React.useMemo<ColorPickerContextValue>(\r\n    () => ({\r\n      dir,\r\n      disabled,\r\n      inline,\r\n      readOnly,\r\n      required,\r\n    }),\r\n    [dir, disabled, inline, readOnly, required],\r\n  );\r\n\r\n  const value = useStore((state) => rgbToHex(state.color));\r\n  const open = useStore((state) => state.open);\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  if (inline) {\r\n    return (\r\n      <ColorPickerContext.Provider value={contextValue}>\r\n        <RootPrimitive {...rootProps} ref={composedRef} />\r\n        {isFormControl && (\r\n          <VisuallyHiddenInput\r\n            type=\"hidden\"\r\n            control={formTrigger}\r\n            name={name}\r\n            value={value}\r\n            disabled={disabled}\r\n            readOnly={readOnly}\r\n            required={required}\r\n          />\r\n        )}\r\n      </ColorPickerContext.Provider>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <ColorPickerContext.Provider value={contextValue}>\r\n      <Popover\r\n        defaultOpen={defaultOpen}\r\n        open={open}\r\n        onOpenChange={store.setOpen}\r\n        modal={modal}\r\n      >\r\n        <RootPrimitive {...rootProps} ref={composedRef} />\r\n        {isFormControl && (\r\n          <VisuallyHiddenInput\r\n            type=\"hidden\"\r\n            control={formTrigger}\r\n            name={name}\r\n            value={value}\r\n            disabled={disabled}\r\n            readOnly={readOnly}\r\n            required={required}\r\n          />\r\n        )}\r\n      </Popover>\r\n    </ColorPickerContext.Provider>\r\n  );\r\n}\r\n\r\nfunction ColorPickerTrigger(\r\n  props: React.ComponentProps<typeof PopoverTrigger>,\r\n) {\r\n  const { asChild, disabled, ...triggerProps } = props;\r\n\r\n  const context = useColorPickerContext(TRIGGER_NAME);\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const TriggerPrimitive = asChild ? SlotPrimitive.Slot : Button;\r\n\r\n  return (\r\n    <PopoverTrigger asChild disabled={isDisabled}>\r\n      <TriggerPrimitive data-slot=\"color-picker-trigger\" {...triggerProps} />\r\n    </PopoverTrigger>\r\n  );\r\n}\r\n\r\nfunction ColorPickerContent(\r\n  props: React.ComponentProps<typeof PopoverContent>,\r\n) {\r\n  const { asChild, className, children, ...popoverContentProps } = props;\r\n\r\n  const context = useColorPickerContext(CONTENT_NAME);\r\n\r\n  if (context.inline) {\r\n    const ContentPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n    return (\r\n      <ContentPrimitive\r\n        data-slot=\"color-picker-content\"\r\n        {...popoverContentProps}\r\n        className={cn(\"flex w-[340px] flex-col gap-4 p-4\", className)}\r\n      >\r\n        {children}\r\n      </ContentPrimitive>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <PopoverContent\r\n      data-slot=\"color-picker-content\"\r\n      asChild={asChild}\r\n      {...popoverContentProps}\r\n      className={cn(\"flex w-[340px] flex-col gap-4 p-4\", className)}\r\n    >\r\n      {children}\r\n    </PopoverContent>\r\n  );\r\n}\r\n\r\nfunction ColorPickerArea(props: DivProps) {\r\n  const {\r\n    asChild,\r\n    onPointerDown: onPointerDownProp,\r\n    onPointerMove: onPointerMoveProp,\r\n    onPointerUp: onPointerUpProp,\r\n    className,\r\n    ref,\r\n    ...areaProps\r\n  } = props;\r\n\r\n  const propsRef = useAsRef({\r\n    onPointerDown: onPointerDownProp,\r\n    onPointerMove: onPointerMoveProp,\r\n    onPointerUp: onPointerUpProp,\r\n  });\r\n\r\n  const context = useColorPickerContext(AREA_NAME);\r\n  const store = useStoreContext(AREA_NAME);\r\n\r\n  const hsv = useStore((state) => state.hsv);\r\n\r\n  const isDraggingRef = React.useRef(false);\r\n  const areaRef = React.useRef<HTMLDivElement>(null);\r\n  const composedRef = useComposedRefs(ref, areaRef);\r\n\r\n  const updateColorFromPosition = React.useCallback(\r\n    (clientX: number, clientY: number) => {\r\n      if (!areaRef.current) return;\r\n\r\n      const rect = areaRef.current.getBoundingClientRect();\r\n      const x = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));\r\n      const y = Math.max(\r\n        0,\r\n        Math.min(1, 1 - (clientY - rect.top) / rect.height),\r\n      );\r\n\r\n      const newHsv: HSVColorValue = {\r\n        h: hsv?.h ?? 0,\r\n        s: Math.round(x * 100),\r\n        v: Math.round(y * 100),\r\n        a: hsv?.a ?? 1,\r\n      };\r\n\r\n      store.setHsv(newHsv);\r\n      store.setColor(hsvToRgb(newHsv));\r\n    },\r\n    [hsv, store],\r\n  );\r\n\r\n  const onPointerDown = React.useCallback(\r\n    (event: React.PointerEvent<AreaElement>) => {\r\n      if (context.disabled) return;\r\n      propsRef.current.onPointerDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      isDraggingRef.current = true;\r\n      areaRef.current?.setPointerCapture(event.pointerId);\r\n      updateColorFromPosition(event.clientX, event.clientY);\r\n    },\r\n    [context.disabled, updateColorFromPosition, propsRef],\r\n  );\r\n\r\n  const onPointerMove = React.useCallback(\r\n    (event: React.PointerEvent<AreaElement>) => {\r\n      propsRef.current.onPointerMove?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (isDraggingRef.current) {\r\n        updateColorFromPosition(event.clientX, event.clientY);\r\n      }\r\n    },\r\n    [updateColorFromPosition, propsRef],\r\n  );\r\n\r\n  const onPointerUp = React.useCallback(\r\n    (event: React.PointerEvent<AreaElement>) => {\r\n      propsRef.current.onPointerUp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      isDraggingRef.current = false;\r\n      areaRef.current?.releasePointerCapture(event.pointerId);\r\n    },\r\n    [propsRef],\r\n  );\r\n\r\n  const hue = hsv?.h ?? 0;\r\n  const backgroundHue = hsvToRgb({ h: hue, s: 100, v: 100, a: 1 });\r\n\r\n  const AreaPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <AreaPrimitive\r\n      data-slot=\"color-picker-area\"\r\n      {...areaProps}\r\n      className={cn(\r\n        \"relative h-40 w-full cursor-crosshair touch-none rounded-sm border\",\r\n        context.disabled && \"pointer-events-none opacity-50\",\r\n        className,\r\n      )}\r\n      ref={composedRef}\r\n      onPointerDown={onPointerDown}\r\n      onPointerMove={onPointerMove}\r\n      onPointerUp={onPointerUp}\r\n    >\r\n      <div className=\"absolute inset-0 overflow-hidden rounded-sm\">\r\n        <div\r\n          className=\"absolute inset-0\"\r\n          style={{\r\n            backgroundColor: `rgb(${backgroundHue.r}, ${backgroundHue.g}, ${backgroundHue.b})`,\r\n          }}\r\n        />\r\n        <div\r\n          className=\"absolute inset-0\"\r\n          style={{\r\n            background: \"linear-gradient(to right, #fff, transparent)\",\r\n          }}\r\n        />\r\n        <div\r\n          className=\"absolute inset-0\"\r\n          style={{\r\n            background: \"linear-gradient(to bottom, transparent, #000)\",\r\n          }}\r\n        />\r\n      </div>\r\n      <div\r\n        className=\"absolute size-3 -translate-x-1/2 -translate-y-1/2 rounded-full border-2 border-white shadow-sm\"\r\n        style={{\r\n          left: `${hsv?.s ?? 0}%`,\r\n          top: `${100 - (hsv?.v ?? 0)}%`,\r\n        }}\r\n      />\r\n    </AreaPrimitive>\r\n  );\r\n}\r\n\r\nfunction ColorPickerHueSlider(\r\n  props: React.ComponentProps<typeof SliderPrimitive.Root>,\r\n) {\r\n  const { className, ...sliderProps } = props;\r\n\r\n  const context = useColorPickerContext(HUE_SLIDER_NAME);\r\n  const store = useStoreContext(HUE_SLIDER_NAME);\r\n\r\n  const hsv = useStore((state) => state.hsv);\r\n\r\n  const onValueChange = React.useCallback(\r\n    (values: number[]) => {\r\n      const newHsv: HSVColorValue = {\r\n        h: values[0] ?? 0,\r\n        s: hsv?.s ?? 0,\r\n        v: hsv?.v ?? 0,\r\n        a: hsv?.a ?? 1,\r\n      };\r\n      store.setHsv(newHsv);\r\n      store.setColor(hsvToRgb(newHsv));\r\n    },\r\n    [hsv, store],\r\n  );\r\n\r\n  return (\r\n    <SliderPrimitive.Root\r\n      data-slot=\"color-picker-hue-slider\"\r\n      {...sliderProps}\r\n      max={360}\r\n      step={1}\r\n      className={cn(\r\n        \"relative flex w-full touch-none select-none items-center\",\r\n        className,\r\n      )}\r\n      value={[hsv?.h ?? 0]}\r\n      onValueChange={onValueChange}\r\n      disabled={context.disabled}\r\n    >\r\n      <SliderPrimitive.Track className=\"relative h-3 w-full grow overflow-hidden rounded-full bg-[linear-gradient(to_right,#ff0000_0%,#ffff00_16.66%,#00ff00_33.33%,#00ffff_50%,#0000ff_66.66%,#ff00ff_83.33%,#ff0000_100%)]\">\r\n        <SliderPrimitive.Range className=\"absolute h-full\" />\r\n      </SliderPrimitive.Track>\r\n      <SliderPrimitive.Thumb className=\"block size-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50\" />\r\n    </SliderPrimitive.Root>\r\n  );\r\n}\r\n\r\nfunction ColorPickerAlphaSlider(\r\n  props: React.ComponentProps<typeof SliderPrimitive.Root>,\r\n) {\r\n  const { className, ...sliderProps } = props;\r\n\r\n  const context = useColorPickerContext(ALPHA_SLIDER_NAME);\r\n  const store = useStoreContext(ALPHA_SLIDER_NAME);\r\n\r\n  const color = useStore((state) => state.color);\r\n  const hsv = useStore((state) => state.hsv);\r\n\r\n  const onValueChange = React.useCallback(\r\n    (values: number[]) => {\r\n      const alpha = (values[0] ?? 0) / 100;\r\n      const newColor = { ...color, a: alpha };\r\n      const newHsv = { ...hsv, a: alpha };\r\n      store.setColor(newColor);\r\n      store.setHsv(newHsv);\r\n    },\r\n    [color, hsv, store],\r\n  );\r\n\r\n  const gradientColor = `rgb(${color?.r ?? 0}, ${color?.g ?? 0}, ${color?.b ?? 0})`;\r\n\r\n  return (\r\n    <SliderPrimitive.Root\r\n      data-slot=\"color-picker-alpha-slider\"\r\n      {...sliderProps}\r\n      max={100}\r\n      step={1}\r\n      disabled={context.disabled}\r\n      className={cn(\r\n        \"relative flex w-full touch-none select-none items-center\",\r\n        className,\r\n      )}\r\n      value={[Math.round((color?.a ?? 1) * 100)]}\r\n      onValueChange={onValueChange}\r\n    >\r\n      <SliderPrimitive.Track\r\n        className=\"relative h-3 w-full grow overflow-hidden rounded-full\"\r\n        style={{\r\n          background:\r\n            \"linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)\",\r\n          backgroundSize: \"8px 8px\",\r\n          backgroundPosition: \"0 0, 0 4px, 4px -4px, -4px 0px\",\r\n        }}\r\n      >\r\n        <div\r\n          className=\"absolute inset-0 rounded-full\"\r\n          style={{\r\n            background: `linear-gradient(to right, transparent, ${gradientColor})`,\r\n          }}\r\n        />\r\n        <SliderPrimitive.Range className=\"absolute h-full\" />\r\n      </SliderPrimitive.Track>\r\n      <SliderPrimitive.Thumb className=\"block size-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50\" />\r\n    </SliderPrimitive.Root>\r\n  );\r\n}\r\n\r\nfunction ColorPickerSwatch(props: DivProps) {\r\n  const { asChild, className, ...swatchProps } = props;\r\n\r\n  const context = useColorPickerContext(SWATCH_NAME);\r\n\r\n  const color = useStore((state) => state.color);\r\n  const format = useStore((state) => state.format);\r\n\r\n  const backgroundStyle = React.useMemo(() => {\r\n    if (!color) {\r\n      return {\r\n        background:\r\n          \"linear-gradient(to bottom right, transparent calc(50% - 1px), hsl(var(--destructive)) calc(50% - 1px) calc(50% + 1px), transparent calc(50% + 1px)) no-repeat\",\r\n      };\r\n    }\r\n\r\n    const colorString = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\r\n\r\n    if (color.a < 1) {\r\n      return {\r\n        background: `linear-gradient(${colorString}, ${colorString}), repeating-conic-gradient(#ccc 0% 25%, #fff 0% 50%) 0% 50% / 8px 8px`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      backgroundColor: colorString,\r\n    };\r\n  }, [color]);\r\n\r\n  const ariaLabel = !color\r\n    ? \"No color selected\"\r\n    : `Current color: ${colorToString(color, format)}`;\r\n\r\n  const SwatchPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <SwatchPrimitive\r\n      role=\"img\"\r\n      aria-label={ariaLabel}\r\n      data-slot=\"color-picker-swatch\"\r\n      {...swatchProps}\r\n      className={cn(\r\n        \"box-border size-8 rounded-sm border shadow-sm\",\r\n        context.disabled && \"opacity-50\",\r\n        className,\r\n      )}\r\n      style={{\r\n        ...backgroundStyle,\r\n        forcedColorAdjust: \"none\",\r\n      }}\r\n    />\r\n  );\r\n}\r\n\r\nfunction ColorPickerEyeDropper(props: React.ComponentProps<typeof Button>) {\r\n  const { size: sizeProp, children, disabled, ...buttonProps } = props;\r\n\r\n  const context = useColorPickerContext(EYE_DROPPER_NAME);\r\n  const store = useStoreContext(EYE_DROPPER_NAME);\r\n\r\n  const color = useStore((state) => state.color);\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onEyeDropper = React.useCallback(async () => {\r\n    if (!window.EyeDropper) return;\r\n\r\n    try {\r\n      const eyeDropper = new window.EyeDropper();\r\n      const result = await eyeDropper.open();\r\n\r\n      if (result.sRGBHex) {\r\n        const currentAlpha = color?.a ?? 1;\r\n        const newColor = hexToRgb(result.sRGBHex, currentAlpha);\r\n        const newHsv = rgbToHsv(newColor);\r\n        store.setColor(newColor);\r\n        store.setHsv(newHsv);\r\n      }\r\n    } catch (error) {\r\n      console.warn(\"EyeDropper error:\", error);\r\n    }\r\n  }, [color, store]);\r\n\r\n  const hasEyeDropper = typeof window !== \"undefined\" && !!window.EyeDropper;\r\n\r\n  if (!hasEyeDropper) return null;\r\n\r\n  const size = sizeProp ?? (children ? \"default\" : \"icon\");\r\n\r\n  return (\r\n    <Button\r\n      data-slot=\"color-picker-eye-dropper\"\r\n      {...buttonProps}\r\n      variant=\"outline\"\r\n      size={size}\r\n      onClick={onEyeDropper}\r\n      disabled={isDisabled}\r\n    >\r\n      {children ?? <PipetteIcon />}\r\n    </Button>\r\n  );\r\n}\r\n\r\ninterface ColorPickerFormatSelectProps\r\n  extends Omit<React.ComponentProps<typeof Select>, \"value\" | \"onValueChange\">,\r\n    Pick<React.ComponentProps<typeof SelectTrigger>, \"size\" | \"className\"> {}\r\n\r\nfunction ColorPickerFormatSelect(props: ColorPickerFormatSelectProps) {\r\n  const { size, disabled, className, ...selectProps } = props;\r\n\r\n  const context = useColorPickerContext(FORMAT_SELECT_NAME);\r\n  const store = useStoreContext(FORMAT_SELECT_NAME);\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const format = useStore((state) => state.format);\r\n\r\n  const onFormatChange = React.useCallback(\r\n    (value: ColorFormat) => {\r\n      store.setFormat(value);\r\n    },\r\n    [store],\r\n  );\r\n\r\n  return (\r\n    <Select\r\n      data-slot=\"color-picker-format-select\"\r\n      {...selectProps}\r\n      value={format}\r\n      onValueChange={onFormatChange}\r\n      disabled={isDisabled}\r\n    >\r\n      <SelectTrigger\r\n        data-slot=\"color-picker-format-select-trigger\"\r\n        size={size ?? \"sm\"}\r\n        className={cn(className)}\r\n      >\r\n        <SelectValue />\r\n      </SelectTrigger>\r\n      <SelectContent>\r\n        {colorFormats.map((format) => (\r\n          <SelectItem key={format} value={format}>\r\n            {format.toUpperCase()}\r\n          </SelectItem>\r\n        ))}\r\n      </SelectContent>\r\n    </Select>\r\n  );\r\n}\r\n\r\ninterface ColorPickerInputProps\r\n  extends Omit<\r\n    React.ComponentProps<typeof Input>,\r\n    \"value\" | \"onChange\" | \"color\"\r\n  > {\r\n  withoutAlpha?: boolean;\r\n}\r\n\r\nfunction ColorPickerInput(props: ColorPickerInputProps) {\r\n  const store = useStoreContext(INPUT_NAME);\r\n  const context = useColorPickerContext(INPUT_NAME);\r\n\r\n  const color = useStore((state) => state.color);\r\n  const format = useStore((state) => state.format);\r\n  const hsv = useStore((state) => state.hsv);\r\n\r\n  const onColorChange = React.useCallback(\r\n    (newColor: ColorValue) => {\r\n      const newHsv = rgbToHsv(newColor);\r\n      store.setColor(newColor);\r\n      store.setHsv(newHsv);\r\n    },\r\n    [store],\r\n  );\r\n\r\n  if (format === \"hex\") {\r\n    return (\r\n      <HexInput\r\n        color={color}\r\n        onColorChange={onColorChange}\r\n        context={context}\r\n        {...props}\r\n      />\r\n    );\r\n  }\r\n\r\n  if (format === \"rgb\") {\r\n    return (\r\n      <RgbInput\r\n        color={color}\r\n        onColorChange={onColorChange}\r\n        context={context}\r\n        {...props}\r\n      />\r\n    );\r\n  }\r\n\r\n  if (format === \"hsl\") {\r\n    return (\r\n      <HslInput\r\n        color={color}\r\n        onColorChange={onColorChange}\r\n        context={context}\r\n        {...props}\r\n      />\r\n    );\r\n  }\r\n\r\n  if (format === \"hsb\") {\r\n    return (\r\n      <HsbInput\r\n        hsv={hsv}\r\n        onColorChange={onColorChange}\r\n        context={context}\r\n        {...props}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nconst inputGroupItemVariants = cva(\r\n  \"h-8 [-moz-appearance:textfield] focus-visible:z-10 focus-visible:ring-1 [&::-webkit-inner-spin-button]:m-0 [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:m-0 [&::-webkit-outer-spin-button]:appearance-none\",\r\n  {\r\n    variants: {\r\n      position: {\r\n        first: \"rounded-e-none\",\r\n        middle: \"-ms-px rounded-none border-l-0\",\r\n        last: \"-ms-px rounded-s-none border-l-0\",\r\n        isolated: \"\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      position: \"isolated\",\r\n    },\r\n  },\r\n);\r\n\r\ninterface InputGroupItemProps\r\n  extends React.ComponentProps<typeof Input>,\r\n    VariantProps<typeof inputGroupItemVariants> {}\r\n\r\nfunction InputGroupItem({\r\n  className,\r\n  position,\r\n  ...props\r\n}: InputGroupItemProps) {\r\n  return (\r\n    <Input\r\n      data-slot=\"color-picker-input\"\r\n      className={cn(inputGroupItemVariants({ position, className }))}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\ninterface FormatInputProps extends ColorPickerInputProps {\r\n  color: ColorValue;\r\n  onColorChange: (color: ColorValue) => void;\r\n  context: ColorPickerContextValue;\r\n}\r\n\r\nfunction HexInput(props: FormatInputProps) {\r\n  const {\r\n    color,\r\n    onColorChange,\r\n    context,\r\n    withoutAlpha,\r\n    className,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const hexValue = rgbToHex(color);\r\n  const alphaValue = Math.round((color?.a ?? 1) * 100);\r\n\r\n  const onHexChange = React.useCallback(\r\n    (event: React.ChangeEvent<InputElement>) => {\r\n      const value = event.target.value;\r\n      const parsedColor = parseColorString(value);\r\n      if (parsedColor) {\r\n        onColorChange({ ...parsedColor, a: color?.a ?? 1 });\r\n      }\r\n    },\r\n    [color, onColorChange],\r\n  );\r\n\r\n  const onAlphaChange = React.useCallback(\r\n    (event: React.ChangeEvent<InputElement>) => {\r\n      const value = Number.parseInt(event.target.value, 10);\r\n      if (!Number.isNaN(value) && value >= 0 && value <= 100) {\r\n        onColorChange({ ...color, a: value / 100 });\r\n      }\r\n    },\r\n    [color, onColorChange],\r\n  );\r\n\r\n  if (withoutAlpha) {\r\n    return (\r\n      <InputGroupItem\r\n        aria-label=\"Hex color value\"\r\n        position=\"isolated\"\r\n        {...inputProps}\r\n        placeholder=\"#000000\"\r\n        className={cn(\"font-mono\", className)}\r\n        value={hexValue}\r\n        onChange={onHexChange}\r\n        disabled={context.disabled}\r\n      />\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div\r\n      data-slot=\"color-picker-input-wrapper\"\r\n      className={cn(\"flex items-center\", className)}\r\n    >\r\n      <InputGroupItem\r\n        aria-label=\"Hex color value\"\r\n        position=\"first\"\r\n        {...inputProps}\r\n        placeholder=\"#000000\"\r\n        className=\"flex-1 font-mono\"\r\n        value={hexValue}\r\n        onChange={onHexChange}\r\n        disabled={context.disabled}\r\n      />\r\n      <InputGroupItem\r\n        aria-label=\"Alpha transparency percentage\"\r\n        position=\"last\"\r\n        {...inputProps}\r\n        placeholder=\"100\"\r\n        inputMode=\"numeric\"\r\n        pattern=\"[0-9]*\"\r\n        min=\"0\"\r\n        max=\"100\"\r\n        className=\"w-14\"\r\n        value={alphaValue}\r\n        onChange={onAlphaChange}\r\n        disabled={context.disabled}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction RgbInput(props: FormatInputProps) {\r\n  const {\r\n    color,\r\n    onColorChange,\r\n    context,\r\n    withoutAlpha,\r\n    className,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const rValue = Math.round(color?.r ?? 0);\r\n  const gValue = Math.round(color?.g ?? 0);\r\n  const bValue = Math.round(color?.b ?? 0);\r\n  const alphaValue = Math.round((color?.a ?? 1) * 100);\r\n\r\n  const onChannelChange = React.useCallback(\r\n    (channel: \"r\" | \"g\" | \"b\" | \"a\", max: number, isAlpha = false) =>\r\n      (event: React.ChangeEvent<InputElement>) => {\r\n        const value = Number.parseInt(event.target.value, 10);\r\n        if (!Number.isNaN(value) && value >= 0 && value <= max) {\r\n          const newValue = isAlpha ? value / 100 : value;\r\n          onColorChange({ ...color, [channel]: newValue });\r\n        }\r\n      },\r\n    [color, onColorChange],\r\n  );\r\n\r\n  return (\r\n    <div\r\n      data-slot=\"color-picker-input-wrapper\"\r\n      className={cn(\"flex items-center\", className)}\r\n    >\r\n      <InputGroupItem\r\n        aria-label=\"Red color component (0-255)\"\r\n        position=\"first\"\r\n        {...inputProps}\r\n        placeholder=\"0\"\r\n        inputMode=\"numeric\"\r\n        pattern=\"[0-9]*\"\r\n        min=\"0\"\r\n        max=\"255\"\r\n        className=\"w-14\"\r\n        value={rValue}\r\n        onChange={onChannelChange(\"r\", 255)}\r\n        disabled={context.disabled}\r\n      />\r\n      <InputGroupItem\r\n        aria-label=\"Green color component (0-255)\"\r\n        position=\"middle\"\r\n        {...inputProps}\r\n        placeholder=\"0\"\r\n        inputMode=\"numeric\"\r\n        pattern=\"[0-9]*\"\r\n        min=\"0\"\r\n        max=\"255\"\r\n        className=\"w-14\"\r\n        value={gValue}\r\n        onChange={onChannelChange(\"g\", 255)}\r\n        disabled={context.disabled}\r\n      />\r\n      <InputGroupItem\r\n        aria-label=\"Blue color component (0-255)\"\r\n        position={withoutAlpha ? \"last\" : \"middle\"}\r\n        {...inputProps}\r\n        placeholder=\"0\"\r\n        inputMode=\"numeric\"\r\n        pattern=\"[0-9]*\"\r\n        min=\"0\"\r\n        max=\"255\"\r\n        className=\"w-14\"\r\n        value={bValue}\r\n        onChange={onChannelChange(\"b\", 255)}\r\n        disabled={context.disabled}\r\n      />\r\n      {!withoutAlpha && (\r\n        <InputGroupItem\r\n          aria-label=\"Alpha transparency percentage\"\r\n          position=\"last\"\r\n          {...inputProps}\r\n          placeholder=\"100\"\r\n          inputMode=\"numeric\"\r\n          pattern=\"[0-9]*\"\r\n          min=\"0\"\r\n          max=\"100\"\r\n          className=\"w-14\"\r\n          value={alphaValue}\r\n          onChange={onChannelChange(\"a\", 100, true)}\r\n          disabled={context.disabled}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction HslInput(props: FormatInputProps) {\r\n  const {\r\n    color,\r\n    onColorChange,\r\n    context,\r\n    withoutAlpha,\r\n    className,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const hsl = React.useMemo(() => rgbToHsl(color), [color]);\r\n  const alphaValue = Math.round((color?.a ?? 1) * 100);\r\n\r\n  const onHslChannelChange = React.useCallback(\r\n    (channel: \"h\" | \"s\" | \"l\", max: number) =>\r\n      (event: React.ChangeEvent<InputElement>) => {\r\n        const value = Number.parseInt(event.target.value, 10);\r\n        if (!Number.isNaN(value) && value >= 0 && value <= max) {\r\n          const newHsl = { ...hsl, [channel]: value };\r\n          const newColor = hslToRgb(newHsl, color?.a ?? 1);\r\n          onColorChange(newColor);\r\n        }\r\n      },\r\n    [hsl, color, onColorChange],\r\n  );\r\n\r\n  const onAlphaChange = React.useCallback(\r\n    (event: React.ChangeEvent<InputElement>) => {\r\n      const value = Number.parseInt(event.target.value, 10);\r\n      if (!Number.isNaN(value) && value >= 0 && value <= 100) {\r\n        onColorChange({ ...color, a: value / 100 });\r\n      }\r\n    },\r\n    [color, onColorChange],\r\n  );\r\n\r\n  return (\r\n    <div\r\n      data-slot=\"color-picker-input-wrapper\"\r\n      className={cn(\"flex items-center\", className)}\r\n    >\r\n      <InputGroupItem\r\n        aria-label=\"Hue degree (0-360)\"\r\n        position=\"first\"\r\n        {...inputProps}\r\n        placeholder=\"0\"\r\n        inputMode=\"numeric\"\r\n        pattern=\"[0-9]*\"\r\n        min=\"0\"\r\n        max=\"360\"\r\n        className=\"w-14\"\r\n        value={hsl.h}\r\n        onChange={onHslChannelChange(\"h\", 360)}\r\n        disabled={context.disabled}\r\n      />\r\n      <InputGroupItem\r\n        aria-label=\"Saturation percentage (0-100)\"\r\n        position=\"middle\"\r\n        {...inputProps}\r\n        placeholder=\"0\"\r\n        inputMode=\"numeric\"\r\n        pattern=\"[0-9]*\"\r\n        min=\"0\"\r\n        max=\"100\"\r\n        className=\"w-14\"\r\n        value={hsl.s}\r\n        onChange={onHslChannelChange(\"s\", 100)}\r\n        disabled={context.disabled}\r\n      />\r\n      <InputGroupItem\r\n        aria-label=\"Lightness percentage (0-100)\"\r\n        position={withoutAlpha ? \"last\" : \"middle\"}\r\n        {...inputProps}\r\n        placeholder=\"0\"\r\n        inputMode=\"numeric\"\r\n        pattern=\"[0-9]*\"\r\n        min=\"0\"\r\n        max=\"100\"\r\n        className=\"w-14\"\r\n        value={hsl.l}\r\n        onChange={onHslChannelChange(\"l\", 100)}\r\n        disabled={context.disabled}\r\n      />\r\n      {!withoutAlpha && (\r\n        <InputGroupItem\r\n          aria-label=\"Alpha transparency percentage\"\r\n          position=\"last\"\r\n          {...inputProps}\r\n          placeholder=\"100\"\r\n          inputMode=\"numeric\"\r\n          pattern=\"[0-9]*\"\r\n          min=\"0\"\r\n          max=\"100\"\r\n          className=\"w-14\"\r\n          value={alphaValue}\r\n          onChange={onAlphaChange}\r\n          disabled={context.disabled}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface HsbInputProps extends Omit<FormatInputProps, \"color\"> {\r\n  hsv: HSVColorValue;\r\n}\r\n\r\nfunction HsbInput(props: HsbInputProps) {\r\n  const {\r\n    hsv,\r\n    onColorChange,\r\n    context,\r\n    withoutAlpha,\r\n    className,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const alphaValue = Math.round((hsv?.a ?? 1) * 100);\r\n\r\n  const onHsvChannelChange = React.useCallback(\r\n    (channel: \"h\" | \"s\" | \"v\", max: number) =>\r\n      (event: React.ChangeEvent<InputElement>) => {\r\n        const value = Number.parseInt(event.target.value, 10);\r\n        if (!Number.isNaN(value) && value >= 0 && value <= max) {\r\n          const newHsv = { ...hsv, [channel]: value };\r\n          const newColor = hsvToRgb(newHsv);\r\n          onColorChange(newColor);\r\n        }\r\n      },\r\n    [hsv, onColorChange],\r\n  );\r\n\r\n  const onAlphaChange = React.useCallback(\r\n    (event: React.ChangeEvent<InputElement>) => {\r\n      const value = Number.parseInt(event.target.value, 10);\r\n      if (!Number.isNaN(value) && value >= 0 && value <= 100) {\r\n        const currentColor = hsvToRgb(hsv);\r\n        onColorChange({ ...currentColor, a: value / 100 });\r\n      }\r\n    },\r\n    [hsv, onColorChange],\r\n  );\r\n\r\n  return (\r\n    <div\r\n      data-slot=\"color-picker-input-wrapper\"\r\n      className={cn(\"flex items-center\", className)}\r\n    >\r\n      <InputGroupItem\r\n        aria-label=\"Hue degree (0-360)\"\r\n        position=\"first\"\r\n        {...inputProps}\r\n        placeholder=\"0\"\r\n        inputMode=\"numeric\"\r\n        pattern=\"[0-9]*\"\r\n        min=\"0\"\r\n        max=\"360\"\r\n        className=\"w-14\"\r\n        value={hsv?.h ?? 0}\r\n        onChange={onHsvChannelChange(\"h\", 360)}\r\n        disabled={context.disabled}\r\n      />\r\n      <InputGroupItem\r\n        aria-label=\"Saturation percentage (0-100)\"\r\n        position=\"middle\"\r\n        {...inputProps}\r\n        placeholder=\"0\"\r\n        inputMode=\"numeric\"\r\n        pattern=\"[0-9]*\"\r\n        min=\"0\"\r\n        max=\"100\"\r\n        className=\"w-14\"\r\n        value={hsv?.s ?? 0}\r\n        onChange={onHsvChannelChange(\"s\", 100)}\r\n        disabled={context.disabled}\r\n      />\r\n      <InputGroupItem\r\n        aria-label=\"Brightness percentage (0-100)\"\r\n        position={withoutAlpha ? \"last\" : \"middle\"}\r\n        {...inputProps}\r\n        placeholder=\"0\"\r\n        inputMode=\"numeric\"\r\n        pattern=\"[0-9]*\"\r\n        min=\"0\"\r\n        max=\"100\"\r\n        className=\"w-14\"\r\n        value={hsv?.v ?? 0}\r\n        onChange={onHsvChannelChange(\"v\", 100)}\r\n        disabled={context.disabled}\r\n      />\r\n      {!withoutAlpha && (\r\n        <InputGroupItem\r\n          aria-label=\"Alpha transparency percentage\"\r\n          position=\"last\"\r\n          {...inputProps}\r\n          placeholder=\"100\"\r\n          inputMode=\"numeric\"\r\n          pattern=\"[0-9]*\"\r\n          min=\"0\"\r\n          max=\"100\"\r\n          className=\"w-14\"\r\n          value={alphaValue}\r\n          onChange={onAlphaChange}\r\n          disabled={context.disabled}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport {\r\n  ColorPicker,\r\n  ColorPickerTrigger,\r\n  ColorPickerContent,\r\n  ColorPickerArea,\r\n  ColorPickerHueSlider,\r\n  ColorPickerAlphaSlider,\r\n  ColorPickerSwatch,\r\n  ColorPickerEyeDropper,\r\n  ColorPickerFormatSelect,\r\n  ColorPickerInput,\r\n  //\r\n  useStore as useColorPicker,\r\n  //\r\n  type ColorPickerProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\n\r\ntype InputValue = string[] | string;\r\n\r\ninterface VisuallyHiddenInputProps<T = InputValue>\r\n  extends Omit<\r\n    React.InputHTMLAttributes<HTMLInputElement>,\r\n    \"value\" | \"checked\" | \"onReset\"\r\n  > {\r\n  value?: T;\r\n  checked?: boolean;\r\n  control: HTMLElement | null;\r\n  bubbles?: boolean;\r\n}\r\n\r\nfunction VisuallyHiddenInput<T = InputValue>(\r\n  props: VisuallyHiddenInputProps<T>,\r\n) {\r\n  const {\r\n    control,\r\n    value,\r\n    checked,\r\n    bubbles = true,\r\n    type = \"hidden\",\r\n    style,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const isCheckInput = React.useMemo(\r\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\r\n    [type],\r\n  );\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  const prevValueRef = React.useRef<{\r\n    value: T | boolean | undefined;\r\n    previous: T | boolean | undefined;\r\n  }>({\r\n    value: isCheckInput ? checked : value,\r\n    previous: isCheckInput ? checked : value,\r\n  });\r\n\r\n  const prevValue = React.useMemo(() => {\r\n    const currentValue = isCheckInput ? checked : value;\r\n    if (prevValueRef.current.value !== currentValue) {\r\n      prevValueRef.current.previous = prevValueRef.current.value;\r\n      prevValueRef.current.value = currentValue;\r\n    }\r\n    return prevValueRef.current.previous;\r\n  }, [isCheckInput, value, checked]);\r\n\r\n  const [controlSize, setControlSize] = React.useState<{\r\n    width?: number;\r\n    height?: number;\r\n  }>({});\r\n\r\n  React.useLayoutEffect(() => {\r\n    if (!control) {\r\n      setControlSize({});\r\n      return;\r\n    }\r\n\r\n    setControlSize({\r\n      width: control.offsetWidth,\r\n      height: control.offsetHeight,\r\n    });\r\n\r\n    if (typeof window === \"undefined\") return;\r\n\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      if (!Array.isArray(entries) || !entries.length) return;\r\n\r\n      const entry = entries[0];\r\n      if (!entry) return;\r\n\r\n      let width: number;\r\n      let height: number;\r\n\r\n      if (\"borderBoxSize\" in entry) {\r\n        const borderSizeEntry = entry.borderBoxSize;\r\n        const borderSize = Array.isArray(borderSizeEntry)\r\n          ? borderSizeEntry[0]\r\n          : borderSizeEntry;\r\n        width = borderSize.inlineSize;\r\n        height = borderSize.blockSize;\r\n      } else {\r\n        width = control.offsetWidth;\r\n        height = control.offsetHeight;\r\n      }\r\n\r\n      setControlSize({ width, height });\r\n    });\r\n\r\n    resizeObserver.observe(control, { box: \"border-box\" });\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [control]);\r\n\r\n  React.useEffect(() => {\r\n    const input = inputRef.current;\r\n    if (!input) return;\r\n\r\n    const inputProto = window.HTMLInputElement.prototype;\r\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\r\n    const eventType = isCheckInput ? \"click\" : \"input\";\r\n    const currentValue = isCheckInput ? checked : value;\r\n\r\n    const serializedCurrentValue = isCheckInput\r\n      ? checked\r\n      : typeof value === \"object\" && value !== null\r\n        ? JSON.stringify(value)\r\n        : value;\r\n\r\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\r\n\r\n    const setter = descriptor?.set;\r\n\r\n    if (prevValue !== currentValue && setter) {\r\n      const event = new Event(eventType, { bubbles });\r\n      setter.call(input, serializedCurrentValue);\r\n      input.dispatchEvent(event);\r\n    }\r\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\r\n\r\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\r\n    return {\r\n      ...style,\r\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\r\n        ? controlSize\r\n        : {}),\r\n      border: 0,\r\n      clip: \"rect(0 0 0 0)\",\r\n      clipPath: \"inset(50%)\",\r\n      height: \"1px\",\r\n      margin: \"-1px\",\r\n      overflow: \"hidden\",\r\n      padding: 0,\r\n      position: \"absolute\",\r\n      whiteSpace: \"nowrap\",\r\n      width: \"1px\",\r\n    };\r\n  }, [style, controlSize]);\r\n\r\n  return (\r\n    <input\r\n      type={type}\r\n      {...inputProps}\r\n      ref={inputRef}\r\n      aria-hidden={isCheckInput}\r\n      tabIndex={-1}\r\n      defaultChecked={isCheckInput ? checked : undefined}\r\n      style={composedStyle}\r\n    />\r\n  );\r\n}\r\n\r\nexport { VisuallyHiddenInput };\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}