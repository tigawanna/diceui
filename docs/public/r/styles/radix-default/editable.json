{
  "name": "editable",
  "dependencies": [
    "radix-ui"
  ],
  "registryDependencies": [
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/editable.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  Direction as DirectionPrimitive,\r\n  Slot as SlotPrimitive,\r\n} from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { VisuallyHiddenInput } from \"@/registry/bases/radix/components/visually-hidden-input\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"Editable\";\r\nconst LABEL_NAME = \"EditableLabel\";\r\nconst AREA_NAME = \"EditableArea\";\r\nconst PREVIEW_NAME = \"EditablePreview\";\r\nconst INPUT_NAME = \"EditableInput\";\r\nconst TRIGGER_NAME = \"EditableTrigger\";\r\nconst TOOLBAR_NAME = \"EditableToolbar\";\r\nconst CANCEL_NAME = \"EditableCancel\";\r\nconst SUBMIT_NAME = \"EditableSubmit\";\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof Editable>;\r\ntype PreviewElement = React.ComponentRef<typeof EditablePreview>;\r\ntype SubmitElement = React.ComponentRef<typeof EditableSubmit>;\r\ntype InputElement = React.ComponentRef<typeof EditableInput>;\r\n\r\ninterface StoreState {\r\n  value: string;\r\n  editing: boolean;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  notify: () => void;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(\r\n  selector: (state: StoreState) => T,\r\n  ogStore?: Store | null,\r\n): T {\r\n  const contextStore = React.useContext(StoreContext);\r\n\r\n  const store = ogStore ?? contextStore;\r\n\r\n  if (!store) {\r\n    throw new Error(`\\`useStore\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface EditableContextValue {\r\n  rootId: string;\r\n  inputId: string;\r\n  labelId: string;\r\n  defaultValue: string;\r\n  onCancel: () => void;\r\n  onEdit: () => void;\r\n  onSubmit: (value: string) => void;\r\n  onEnterKeyDown?: (event: KeyboardEvent) => void;\r\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\r\n  dir?: Direction;\r\n  maxLength?: number;\r\n  placeholder?: string;\r\n  triggerMode: \"click\" | \"dblclick\" | \"focus\";\r\n  autosize: boolean;\r\n  disabled?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  invalid?: boolean;\r\n}\r\n\r\nconst EditableContext = React.createContext<EditableContextValue | null>(null);\r\n\r\nfunction useEditableContext(consumerName: string) {\r\n  const context = React.useContext(EditableContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface EditableProps extends Omit<DivProps, \"onSubmit\"> {\r\n  id?: string;\r\n  defaultValue?: string;\r\n  value?: string;\r\n  onValueChange?: (value: string) => void;\r\n  defaultEditing?: boolean;\r\n  editing?: boolean;\r\n  onEditingChange?: (editing: boolean) => void;\r\n  onCancel?: () => void;\r\n  onEdit?: () => void;\r\n  onSubmit?: (value: string) => void;\r\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\r\n  onEnterKeyDown?: (event: KeyboardEvent) => void;\r\n  dir?: Direction;\r\n  maxLength?: number;\r\n  name?: string;\r\n  placeholder?: string;\r\n  triggerMode?: EditableContextValue[\"triggerMode\"];\r\n  autosize?: boolean;\r\n  disabled?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  invalid?: boolean;\r\n}\r\n\r\nfunction Editable(props: EditableProps) {\r\n  const {\r\n    value: valueProp,\r\n    defaultValue = \"\",\r\n    defaultEditing,\r\n    editing: editingProp,\r\n    onValueChange,\r\n    onEditingChange,\r\n    onCancel: onCancelProp,\r\n    onEdit: onEditProp,\r\n    onSubmit: onSubmitProp,\r\n    onEscapeKeyDown,\r\n    onEnterKeyDown,\r\n    dir: dirProp,\r\n    maxLength,\r\n    name,\r\n    placeholder,\r\n    triggerMode = \"click\",\r\n    asChild,\r\n    autosize = false,\r\n    disabled,\r\n    required,\r\n    readOnly,\r\n    invalid,\r\n    className,\r\n    id,\r\n    ref,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const instanceId = React.useId();\r\n  const rootId = id ?? instanceId;\r\n\r\n  const inputId = React.useId();\r\n  const labelId = React.useId();\r\n\r\n  const dir = DirectionPrimitive.useDirection(dirProp);\r\n\r\n  const previousValueRef = React.useRef(defaultValue);\r\n\r\n  const [formTrigger, setFormTrigger] = React.useState<RootElement | null>(\r\n    null,\r\n  );\r\n  const composedRef = useComposedRefs(ref, (node) => setFormTrigger(node));\r\n  const isFormControl = formTrigger ? !!formTrigger.closest(\"form\") : true;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    value: valueProp ?? defaultValue,\r\n    editing: editingProp ?? defaultEditing ?? false,\r\n  }));\r\n\r\n  const propsRef = useAsRef({\r\n    onValueChange,\r\n    onEditingChange,\r\n    onCancel: onCancelProp,\r\n    onEdit: onEditProp,\r\n    onSubmit: onSubmitProp,\r\n    onEscapeKeyDown,\r\n    onEnterKeyDown,\r\n  });\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n\r\n        if (key === \"value\" && typeof value === \"string\") {\r\n          stateRef.current.value = value;\r\n          propsRef.current.onValueChange?.(value);\r\n        } else if (key === \"editing\" && typeof value === \"boolean\") {\r\n          stateRef.current.editing = value;\r\n          propsRef.current.onEditingChange?.(value);\r\n        } else {\r\n          stateRef.current[key] = value;\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef]);\r\n\r\n  const value = useStore((state) => state.value, store);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (valueProp !== undefined) {\r\n      store.setState(\"value\", valueProp);\r\n    }\r\n  }, [valueProp]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (editingProp !== undefined) {\r\n      store.setState(\"editing\", editingProp);\r\n    }\r\n  }, [editingProp]);\r\n\r\n  const onCancel = React.useCallback(() => {\r\n    const prevValue = previousValueRef.current;\r\n    store.setState(\"value\", prevValue);\r\n    store.setState(\"editing\", false);\r\n    propsRef.current.onCancel?.();\r\n  }, [store, propsRef]);\r\n\r\n  const onEdit = React.useCallback(() => {\r\n    const currentValue = store.getState().value;\r\n    previousValueRef.current = currentValue;\r\n    store.setState(\"editing\", true);\r\n    propsRef.current.onEdit?.();\r\n  }, [store, propsRef]);\r\n\r\n  const onSubmit = React.useCallback(\r\n    (newValue: string) => {\r\n      store.setState(\"value\", newValue);\r\n      store.setState(\"editing\", false);\r\n      propsRef.current.onSubmit?.(newValue);\r\n    },\r\n    [store, propsRef],\r\n  );\r\n\r\n  const contextValue = React.useMemo<EditableContextValue>(\r\n    () => ({\r\n      rootId,\r\n      inputId,\r\n      labelId,\r\n      defaultValue,\r\n      onSubmit,\r\n      onEdit,\r\n      onCancel,\r\n      onEscapeKeyDown,\r\n      onEnterKeyDown,\r\n      dir,\r\n      maxLength,\r\n      placeholder,\r\n      triggerMode,\r\n      autosize,\r\n      disabled,\r\n      readOnly,\r\n      required,\r\n      invalid,\r\n    }),\r\n    [\r\n      rootId,\r\n      inputId,\r\n      labelId,\r\n      defaultValue,\r\n      onSubmit,\r\n      onCancel,\r\n      onEdit,\r\n      onEscapeKeyDown,\r\n      onEnterKeyDown,\r\n      dir,\r\n      maxLength,\r\n      placeholder,\r\n      triggerMode,\r\n      autosize,\r\n      disabled,\r\n      required,\r\n      readOnly,\r\n      invalid,\r\n    ],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <EditableContext.Provider value={contextValue}>\r\n        <RootPrimitive\r\n          data-slot=\"editable\"\r\n          {...rootProps}\r\n          id={id}\r\n          ref={composedRef}\r\n          className={cn(\"flex min-w-0 flex-col gap-2\", className)}\r\n        />\r\n        {isFormControl && (\r\n          <VisuallyHiddenInput\r\n            type=\"hidden\"\r\n            control={formTrigger}\r\n            name={name}\r\n            value={value}\r\n            disabled={disabled}\r\n            readOnly={readOnly}\r\n            required={required}\r\n          />\r\n        )}\r\n      </EditableContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface EditableLabelProps extends React.ComponentProps<\"label\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction EditableLabel(props: EditableLabelProps) {\r\n  const { asChild, className, children, ref, ...labelProps } = props;\r\n  const context = useEditableContext(LABEL_NAME);\r\n\r\n  const LabelPrimitive = asChild ? SlotPrimitive.Slot : \"label\";\r\n\r\n  return (\r\n    <LabelPrimitive\r\n      data-disabled={context.disabled ? \"\" : undefined}\r\n      data-invalid={context.invalid ? \"\" : undefined}\r\n      data-required={context.required ? \"\" : undefined}\r\n      data-slot=\"editable-label\"\r\n      {...labelProps}\r\n      ref={ref}\r\n      id={context.labelId}\r\n      htmlFor={context.inputId}\r\n      className={cn(\r\n        \"font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 data-required:after:ml-0.5 data-required:after:text-destructive data-required:after:content-['*']\",\r\n        className,\r\n      )}\r\n    >\r\n      {children}\r\n    </LabelPrimitive>\r\n  );\r\n}\r\n\r\ninterface EditableAreaProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction EditableArea(props: EditableAreaProps) {\r\n  const { asChild, className, ref, ...areaProps } = props;\r\n  const context = useEditableContext(AREA_NAME);\r\n  const editing = useStore((state) => state.editing);\r\n\r\n  const AreaPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <AreaPrimitive\r\n      role=\"group\"\r\n      data-disabled={context.disabled ? \"\" : undefined}\r\n      data-editing={editing ? \"\" : undefined}\r\n      data-slot=\"editable-area\"\r\n      dir={context.dir}\r\n      {...areaProps}\r\n      ref={ref}\r\n      className={cn(\r\n        \"relative inline-block min-w-0 data-disabled:cursor-not-allowed data-disabled:opacity-50\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface EditablePreviewProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction EditablePreview(props: EditablePreviewProps) {\r\n  const {\r\n    onClick: onClickProp,\r\n    onDoubleClick: onDoubleClickProp,\r\n    onFocus: onFocusProp,\r\n    onKeyDown: onKeyDownProp,\r\n    asChild,\r\n    className,\r\n    ref,\r\n    ...previewProps\r\n  } = props;\r\n\r\n  const context = useEditableContext(PREVIEW_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const editing = useStore((state) => state.editing);\r\n\r\n  const propsRef = useAsRef({\r\n    onClick: onClickProp,\r\n    onDoubleClick: onDoubleClickProp,\r\n    onFocus: onFocusProp,\r\n    onKeyDown: onKeyDownProp,\r\n  });\r\n\r\n  const onTrigger = React.useCallback(() => {\r\n    if (context.disabled || context.readOnly) return;\r\n    context.onEdit();\r\n  }, [context.onEdit, context.disabled, context.readOnly]);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<PreviewElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n      if (event.defaultPrevented || context.triggerMode !== \"click\") return;\r\n\r\n      onTrigger();\r\n    },\r\n    [propsRef, onTrigger, context.triggerMode],\r\n  );\r\n\r\n  const onDoubleClick = React.useCallback(\r\n    (event: React.MouseEvent<PreviewElement>) => {\r\n      propsRef.current.onDoubleClick?.(event);\r\n      if (event.defaultPrevented || context.triggerMode !== \"dblclick\") return;\r\n\r\n      onTrigger();\r\n    },\r\n    [propsRef, onTrigger, context.triggerMode],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<PreviewElement>) => {\r\n      propsRef.current.onFocus?.(event);\r\n      if (event.defaultPrevented || context.triggerMode !== \"focus\") return;\r\n\r\n      onTrigger();\r\n    },\r\n    [propsRef, onTrigger, context.triggerMode],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<PreviewElement>) => {\r\n      propsRef.current.onKeyDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (event.key === \"Enter\") {\r\n        const nativeEvent = event.nativeEvent;\r\n        if (context.onEnterKeyDown) {\r\n          context.onEnterKeyDown(nativeEvent);\r\n          if (nativeEvent.defaultPrevented) return;\r\n        }\r\n        onTrigger();\r\n      }\r\n    },\r\n    [propsRef, onTrigger, context.onEnterKeyDown],\r\n  );\r\n\r\n  const PreviewPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  if (editing || context.readOnly) return null;\r\n\r\n  return (\r\n    <PreviewPrimitive\r\n      role=\"button\"\r\n      aria-disabled={context.disabled || context.readOnly}\r\n      data-empty={!value ? \"\" : undefined}\r\n      data-disabled={context.disabled ? \"\" : undefined}\r\n      data-readonly={context.readOnly ? \"\" : undefined}\r\n      data-slot=\"editable-preview\"\r\n      tabIndex={context.disabled || context.readOnly ? undefined : 0}\r\n      {...previewProps}\r\n      ref={ref}\r\n      onClick={onClick}\r\n      onDoubleClick={onDoubleClick}\r\n      onFocus={onFocus}\r\n      onKeyDown={onKeyDown}\r\n      className={cn(\r\n        \"cursor-text truncate rounded-sm border border-transparent py-1 text-base focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring data-disabled:cursor-not-allowed data-readonly:cursor-default data-empty:text-muted-foreground data-disabled:opacity-50 md:text-sm\",\r\n        className,\r\n      )}\r\n    >\r\n      {value || context.placeholder}\r\n    </PreviewPrimitive>\r\n  );\r\n}\r\n\r\ninterface EditableInputProps extends React.ComponentProps<\"input\"> {\r\n  asChild?: boolean;\r\n  maxLength?: number;\r\n}\r\n\r\nfunction EditableInput(props: EditableInputProps) {\r\n  const {\r\n    onBlur: onBlurProp,\r\n    onChange: onChangeProp,\r\n    onKeyDown: onKeyDownProp,\r\n    asChild,\r\n    className,\r\n    disabled,\r\n    readOnly,\r\n    required,\r\n    maxLength,\r\n    ref,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const context = useEditableContext(INPUT_NAME);\r\n  const store = useStoreContext(INPUT_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const editing = useStore((state) => state.editing);\r\n  const inputRef = React.useRef<InputElement>(null);\r\n  const composedRef = useComposedRefs(ref, inputRef);\r\n\r\n  const propsRef = useAsRef({\r\n    onBlur: onBlurProp,\r\n    onChange: onChangeProp,\r\n    onKeyDown: onKeyDownProp,\r\n  });\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n  const isReadOnly = readOnly || context.readOnly;\r\n  const isRequired = required || context.required;\r\n\r\n  const onAutosize = React.useCallback(\r\n    (target: InputElement) => {\r\n      if (!context.autosize) return;\r\n\r\n      if (target instanceof HTMLTextAreaElement) {\r\n        target.style.height = \"0\";\r\n        target.style.height = `${target.scrollHeight}px`;\r\n      } else {\r\n        target.style.width = \"0\";\r\n        target.style.width = `${target.scrollWidth + 4}px`;\r\n      }\r\n    },\r\n    [context.autosize],\r\n  );\r\n\r\n  const onBlur = React.useCallback(\r\n    (event: React.FocusEvent<InputElement>) => {\r\n      if (isDisabled || isReadOnly) return;\r\n\r\n      propsRef.current.onBlur?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const relatedTarget = event.relatedTarget;\r\n\r\n      const isAction =\r\n        relatedTarget instanceof HTMLElement &&\r\n        (relatedTarget.closest(`[data-slot=\"editable-trigger\"]`) ||\r\n          relatedTarget.closest(`[data-slot=\"editable-cancel\"]`));\r\n\r\n      if (!isAction) {\r\n        context.onSubmit(value);\r\n      }\r\n    },\r\n    [value, context.onSubmit, propsRef, isDisabled, isReadOnly],\r\n  );\r\n\r\n  const onChange = React.useCallback(\r\n    (event: React.ChangeEvent<InputElement>) => {\r\n      if (isDisabled || isReadOnly) return;\r\n\r\n      propsRef.current.onChange?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      store.setState(\"value\", event.target.value);\r\n      onAutosize(event.target);\r\n    },\r\n    [store, propsRef, onAutosize, isDisabled, isReadOnly],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<InputElement>) => {\r\n      if (isDisabled || isReadOnly) return;\r\n\r\n      propsRef.current.onKeyDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (event.key === \"Escape\") {\r\n        const nativeEvent = event.nativeEvent;\r\n        if (context.onEscapeKeyDown) {\r\n          context.onEscapeKeyDown(nativeEvent);\r\n          if (nativeEvent.defaultPrevented) return;\r\n        }\r\n        context.onCancel();\r\n      } else if (event.key === \"Enter\") {\r\n        context.onSubmit(value);\r\n      }\r\n    },\r\n    [\r\n      value,\r\n      context.onSubmit,\r\n      context.onCancel,\r\n      context.onEscapeKeyDown,\r\n      propsRef,\r\n      isDisabled,\r\n      isReadOnly,\r\n    ],\r\n  );\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (!editing || isDisabled || isReadOnly || !inputRef.current) return;\r\n\r\n    const frameId = window.requestAnimationFrame(() => {\r\n      if (!inputRef.current) return;\r\n\r\n      inputRef.current.focus();\r\n      inputRef.current.select();\r\n      onAutosize(inputRef.current);\r\n    });\r\n\r\n    return () => {\r\n      window.cancelAnimationFrame(frameId);\r\n    };\r\n  }, [editing, onAutosize, isDisabled, isReadOnly]);\r\n\r\n  const InputPrimitive = asChild ? SlotPrimitive.Slot : \"input\";\r\n\r\n  if (!editing && !isReadOnly) return null;\r\n\r\n  return (\r\n    <InputPrimitive\r\n      aria-required={isRequired}\r\n      aria-invalid={context.invalid}\r\n      data-slot=\"editable-input\"\r\n      dir={context.dir}\r\n      disabled={isDisabled}\r\n      readOnly={isReadOnly}\r\n      required={isRequired}\r\n      {...inputProps}\r\n      id={context.inputId}\r\n      aria-labelledby={context.labelId}\r\n      ref={composedRef}\r\n      maxLength={maxLength}\r\n      placeholder={context.placeholder}\r\n      value={value}\r\n      onBlur={onBlur}\r\n      onChange={onChange}\r\n      onKeyDown={onKeyDown}\r\n      className={cn(\r\n        \"flex rounded-sm border border-input bg-transparent py-1 text-base shadow-xs transition-colors file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\r\n        context.autosize ? \"w-auto\" : \"w-full\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface EditableTriggerProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n  forceMount?: boolean;\r\n}\r\n\r\nfunction EditableTrigger(props: EditableTriggerProps) {\r\n  const { asChild, forceMount = false, ref, ...triggerProps } = props;\r\n  const context = useEditableContext(TRIGGER_NAME);\r\n  const editing = useStore((state) => state.editing);\r\n\r\n  const onTrigger = React.useCallback(() => {\r\n    if (context.disabled || context.readOnly) return;\r\n    context.onEdit();\r\n  }, [context.disabled, context.readOnly, context.onEdit]);\r\n\r\n  const TriggerPrimitive = asChild ? SlotPrimitive.Slot : \"button\";\r\n\r\n  if (!forceMount && (editing || context.readOnly)) return null;\r\n\r\n  return (\r\n    <TriggerPrimitive\r\n      type=\"button\"\r\n      aria-controls={context.rootId}\r\n      aria-disabled={context.disabled || context.readOnly}\r\n      data-disabled={context.disabled ? \"\" : undefined}\r\n      data-readonly={context.readOnly ? \"\" : undefined}\r\n      data-slot=\"editable-trigger\"\r\n      {...triggerProps}\r\n      ref={ref}\r\n      onClick={context.triggerMode === \"click\" ? onTrigger : undefined}\r\n      onDoubleClick={context.triggerMode === \"dblclick\" ? onTrigger : undefined}\r\n    />\r\n  );\r\n}\r\n\r\ninterface EditableToolbarProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n  orientation?: \"horizontal\" | \"vertical\";\r\n}\r\n\r\nfunction EditableToolbar(props: EditableToolbarProps) {\r\n  const {\r\n    asChild,\r\n    className,\r\n    orientation = \"horizontal\",\r\n    ref,\r\n    ...toolbarProps\r\n  } = props;\r\n  const context = useEditableContext(TOOLBAR_NAME);\r\n\r\n  const ToolbarPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <ToolbarPrimitive\r\n      role=\"toolbar\"\r\n      aria-controls={context.rootId}\r\n      aria-orientation={orientation}\r\n      data-slot=\"editable-toolbar\"\r\n      dir={context.dir}\r\n      {...toolbarProps}\r\n      ref={ref}\r\n      className={cn(\r\n        \"flex items-center gap-2\",\r\n        orientation === \"vertical\" && \"flex-col\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface EditableCancelProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction EditableCancel(props: EditableCancelProps) {\r\n  const { onClick: onClickProp, asChild, ref, ...cancelProps } = props;\r\n  const context = useEditableContext(CANCEL_NAME);\r\n  const editing = useStore((state) => state.editing);\r\n\r\n  const propsRef = useAsRef({\r\n    onClick: onClickProp,\r\n  });\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      if (context.disabled || context.readOnly) return;\r\n\r\n      propsRef.current.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      context.onCancel();\r\n    },\r\n    [propsRef, context.onCancel, context.disabled, context.readOnly],\r\n  );\r\n\r\n  const CancelPrimitive = asChild ? SlotPrimitive.Slot : \"button\";\r\n\r\n  if (!editing && !context.readOnly) return null;\r\n\r\n  return (\r\n    <CancelPrimitive\r\n      type=\"button\"\r\n      aria-controls={context.rootId}\r\n      data-slot=\"editable-cancel\"\r\n      {...cancelProps}\r\n      onClick={onClick}\r\n      ref={ref}\r\n    />\r\n  );\r\n}\r\n\r\ninterface EditableSubmitProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction EditableSubmit(props: EditableSubmitProps) {\r\n  const { onClick: onClickProp, asChild, ref, ...submitProps } = props;\r\n  const context = useEditableContext(SUBMIT_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const editing = useStore((state) => state.editing);\r\n\r\n  const propsRef = useAsRef({\r\n    onClick: onClickProp,\r\n  });\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<SubmitElement>) => {\r\n      if (context.disabled || context.readOnly) return;\r\n\r\n      propsRef.current.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      context.onSubmit(value);\r\n    },\r\n    [propsRef, context.onSubmit, value, context.disabled, context.readOnly],\r\n  );\r\n\r\n  const SubmitPrimitive = asChild ? SlotPrimitive.Slot : \"button\";\r\n\r\n  if (!editing && !context.readOnly) return null;\r\n\r\n  return (\r\n    <SubmitPrimitive\r\n      type=\"button\"\r\n      aria-controls={context.rootId}\r\n      data-slot=\"editable-submit\"\r\n      {...submitProps}\r\n      ref={ref}\r\n      onClick={onClick}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  Editable,\r\n  EditableLabel,\r\n  EditableArea,\r\n  EditablePreview,\r\n  EditableInput,\r\n  EditableTrigger,\r\n  EditableToolbar,\r\n  EditableCancel,\r\n  EditableSubmit,\r\n  //\r\n  useStore as useEditable,\r\n  //\r\n  type EditableProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\n\r\ntype InputValue = string[] | string;\r\n\r\ninterface VisuallyHiddenInputProps<T = InputValue>\r\n  extends Omit<\r\n    React.InputHTMLAttributes<HTMLInputElement>,\r\n    \"value\" | \"checked\" | \"onReset\"\r\n  > {\r\n  value?: T;\r\n  checked?: boolean;\r\n  control: HTMLElement | null;\r\n  bubbles?: boolean;\r\n}\r\n\r\nfunction VisuallyHiddenInput<T = InputValue>(\r\n  props: VisuallyHiddenInputProps<T>,\r\n) {\r\n  const {\r\n    control,\r\n    value,\r\n    checked,\r\n    bubbles = true,\r\n    type = \"hidden\",\r\n    style,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const isCheckInput = React.useMemo(\r\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\r\n    [type],\r\n  );\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  const prevValueRef = React.useRef<{\r\n    value: T | boolean | undefined;\r\n    previous: T | boolean | undefined;\r\n  }>({\r\n    value: isCheckInput ? checked : value,\r\n    previous: isCheckInput ? checked : value,\r\n  });\r\n\r\n  const prevValue = React.useMemo(() => {\r\n    const currentValue = isCheckInput ? checked : value;\r\n    if (prevValueRef.current.value !== currentValue) {\r\n      prevValueRef.current.previous = prevValueRef.current.value;\r\n      prevValueRef.current.value = currentValue;\r\n    }\r\n    return prevValueRef.current.previous;\r\n  }, [isCheckInput, value, checked]);\r\n\r\n  const [controlSize, setControlSize] = React.useState<{\r\n    width?: number;\r\n    height?: number;\r\n  }>({});\r\n\r\n  React.useLayoutEffect(() => {\r\n    if (!control) {\r\n      setControlSize({});\r\n      return;\r\n    }\r\n\r\n    setControlSize({\r\n      width: control.offsetWidth,\r\n      height: control.offsetHeight,\r\n    });\r\n\r\n    if (typeof window === \"undefined\") return;\r\n\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      if (!Array.isArray(entries) || !entries.length) return;\r\n\r\n      const entry = entries[0];\r\n      if (!entry) return;\r\n\r\n      let width: number;\r\n      let height: number;\r\n\r\n      if (\"borderBoxSize\" in entry) {\r\n        const borderSizeEntry = entry.borderBoxSize;\r\n        const borderSize = Array.isArray(borderSizeEntry)\r\n          ? borderSizeEntry[0]\r\n          : borderSizeEntry;\r\n        width = borderSize.inlineSize;\r\n        height = borderSize.blockSize;\r\n      } else {\r\n        width = control.offsetWidth;\r\n        height = control.offsetHeight;\r\n      }\r\n\r\n      setControlSize({ width, height });\r\n    });\r\n\r\n    resizeObserver.observe(control, { box: \"border-box\" });\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [control]);\r\n\r\n  React.useEffect(() => {\r\n    const input = inputRef.current;\r\n    if (!input) return;\r\n\r\n    const inputProto = window.HTMLInputElement.prototype;\r\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\r\n    const eventType = isCheckInput ? \"click\" : \"input\";\r\n    const currentValue = isCheckInput ? checked : value;\r\n\r\n    const serializedCurrentValue = isCheckInput\r\n      ? checked\r\n      : typeof value === \"object\" && value !== null\r\n        ? JSON.stringify(value)\r\n        : value;\r\n\r\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\r\n\r\n    const setter = descriptor?.set;\r\n\r\n    if (prevValue !== currentValue && setter) {\r\n      const event = new Event(eventType, { bubbles });\r\n      setter.call(input, serializedCurrentValue);\r\n      input.dispatchEvent(event);\r\n    }\r\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\r\n\r\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\r\n    return {\r\n      ...style,\r\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\r\n        ? controlSize\r\n        : {}),\r\n      border: 0,\r\n      clip: \"rect(0 0 0 0)\",\r\n      clipPath: \"inset(50%)\",\r\n      height: \"1px\",\r\n      margin: \"-1px\",\r\n      overflow: \"hidden\",\r\n      padding: 0,\r\n      position: \"absolute\",\r\n      whiteSpace: \"nowrap\",\r\n      width: \"1px\",\r\n    };\r\n  }, [style, controlSize]);\r\n\r\n  return (\r\n    <input\r\n      type={type}\r\n      {...inputProps}\r\n      ref={inputRef}\r\n      aria-hidden={isCheckInput}\r\n      tabIndex={-1}\r\n      defaultChecked={isCheckInput ? checked : undefined}\r\n      style={composedStyle}\r\n    />\r\n  );\r\n}\r\n\r\nexport { VisuallyHiddenInput };\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}