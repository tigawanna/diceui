{
  "name": "tour",
  "dependencies": [
    "@floating-ui/react-dom",
    "radix-ui"
  ],
  "registryDependencies": [
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/tour.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  autoUpdate,\r\n  flip,\r\n  hide,\r\n  limitShift,\r\n  type Middleware,\r\n  offset,\r\n  arrow as onArrow,\r\n  type Placement,\r\n  shift,\r\n  useFloating,\r\n} from \"@floating-ui/react-dom\";\r\nimport { ChevronLeft, ChevronRight, X } from \"lucide-react\";\r\nimport {\r\n  Direction as DirectionPrimitive,\r\n  Slot as SlotPrimitive,\r\n} from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"Tour\";\r\nconst PORTAL_NAME = \"TourPortal\";\r\nconst STEP_NAME = \"TourStep\";\r\nconst ARROW_NAME = \"TourArrow\";\r\nconst HEADER_NAME = \"TourHeader\";\r\nconst TITLE_NAME = \"TourTitle\";\r\nconst DESCRIPTION_NAME = \"TourDescription\";\r\nconst CLOSE_NAME = \"TourClose\";\r\nconst PREV_NAME = \"TourPrev\";\r\nconst NEXT_NAME = \"TourNext\";\r\nconst SKIP_NAME = \"TourSkip\";\r\nconst FOOTER_NAME = \"TourFooter\";\r\n\r\nconst POINTER_DOWN_OUTSIDE = \"tour.pointerDownOutside\";\r\nconst INTERACT_OUTSIDE = \"tour.interactOutside\";\r\nconst OPEN_AUTO_FOCUS = \"tour.openAutoFocus\";\r\nconst CLOSE_AUTO_FOCUS = \"tour.closeAutoFocus\";\r\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\r\n\r\nconst SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"] as const;\r\nconst ALIGN_OPTIONS = [\"start\", \"center\", \"end\"] as const;\r\n\r\nconst DEFAULT_ALIGN_OFFSET = 0;\r\nconst DEFAULT_SIDE_OFFSET = 16;\r\nconst DEFAULT_SPOTLIGHT_PADDING = 4;\r\n\r\ntype Side = (typeof SIDE_OPTIONS)[number];\r\ntype Align = (typeof ALIGN_OPTIONS)[number];\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\ninterface ScrollOffset {\r\n  top?: number;\r\n  bottom?: number;\r\n  left?: number;\r\n  right?: number;\r\n}\r\n\r\ntype Boundary = Element | null;\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype StepElement = React.ComponentRef<typeof TourStep>;\r\ntype CloseElement = React.ComponentRef<typeof TourClose>;\r\ntype PrevElement = React.ComponentRef<typeof TourPrev>;\r\ntype NextElement = React.ComponentRef<typeof TourNext>;\r\ntype SkipElement = React.ComponentRef<typeof TourSkip>;\r\ntype FooterElement = React.ComponentRef<typeof TourFooter>;\r\n\r\nconst OPPOSITE_SIDE: Record<Side, Side> = {\r\n  top: \"bottom\",\r\n  right: \"left\",\r\n  bottom: \"top\",\r\n  left: \"right\",\r\n};\r\n\r\n/**\r\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/focus-guards/src/focus-guards.tsx\r\n */\r\nlet focusGuardCount = 0;\r\n\r\nfunction createFocusGuard() {\r\n  const element = document.createElement(\"span\");\r\n  element.setAttribute(\"data-tour-focus-guard\", \"\");\r\n  element.tabIndex = 0;\r\n  element.style.outline = \"none\";\r\n  element.style.opacity = \"0\";\r\n  element.style.position = \"fixed\";\r\n  element.style.pointerEvents = \"none\";\r\n  return element;\r\n}\r\n\r\nfunction useFocusGuards() {\r\n  React.useEffect(() => {\r\n    const edgeGuards = document.querySelectorAll(\"[data-tour-focus-guard]\");\r\n    document.body.insertAdjacentElement(\r\n      \"afterbegin\",\r\n      edgeGuards[0] ?? createFocusGuard(),\r\n    );\r\n    document.body.insertAdjacentElement(\r\n      \"beforeend\",\r\n      edgeGuards[1] ?? createFocusGuard(),\r\n    );\r\n    focusGuardCount++;\r\n\r\n    return () => {\r\n      if (focusGuardCount === 1) {\r\n        const guards = document.querySelectorAll(\"[data-tour-focus-guard]\");\r\n        for (const node of guards) {\r\n          node.remove();\r\n        }\r\n      }\r\n      focusGuardCount--;\r\n    };\r\n  }, []);\r\n}\r\n\r\nfunction useFocusTrap(\r\n  containerRef: React.RefObject<HTMLElement | null>,\r\n  enabled: boolean,\r\n  tourOpen: boolean,\r\n  onOpenAutoFocus?: (event: OpenAutoFocusEvent) => void,\r\n  onCloseAutoFocus?: (event: CloseAutoFocusEvent) => void,\r\n) {\r\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\r\n  const onOpenAutoFocusRef = useAsRef(onOpenAutoFocus);\r\n  const onCloseAutoFocusRef = useAsRef(onCloseAutoFocus);\r\n  const tourOpenRef = useAsRef(tourOpen);\r\n\r\n  React.useEffect(() => {\r\n    if (!enabled) return;\r\n\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const previouslyFocusedElement =\r\n      document.activeElement as HTMLElement | null;\r\n\r\n    function getTabbableCandidates() {\r\n      if (!container) return [];\r\n\r\n      const nodes: HTMLElement[] = [];\r\n      const walker = document.createTreeWalker(\r\n        container,\r\n        NodeFilter.SHOW_ELEMENT,\r\n        {\r\n          acceptNode: (node: Element) => {\r\n            const element = node as HTMLElement;\r\n            const isHiddenInput =\r\n              element.tagName === \"INPUT\" &&\r\n              (element as HTMLInputElement).type === \"hidden\";\r\n            if (element.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\r\n            return element.tabIndex >= 0\r\n              ? NodeFilter.FILTER_ACCEPT\r\n              : NodeFilter.FILTER_SKIP;\r\n          },\r\n        },\r\n      );\r\n      while (walker.nextNode()) {\r\n        nodes.push(walker.currentNode as HTMLElement);\r\n      }\r\n      return nodes;\r\n    }\r\n\r\n    function getTabbableEdges() {\r\n      const candidates = getTabbableCandidates();\r\n      const first = candidates[0];\r\n      const last = candidates[candidates.length - 1];\r\n      return [first, last] as const;\r\n    }\r\n\r\n    function onFocusIn(event: FocusEvent) {\r\n      if (!container) return;\r\n\r\n      const target = event.target as HTMLElement | null;\r\n      if (container.contains(target)) {\r\n        lastFocusedElementRef.current = target;\r\n      } else {\r\n        const elementToFocus =\r\n          lastFocusedElementRef.current ?? getTabbableCandidates()[0];\r\n        elementToFocus?.focus({ preventScroll: true });\r\n      }\r\n    }\r\n\r\n    function onKeyDown(event: KeyboardEvent) {\r\n      if (event.key !== \"Tab\" || event.altKey || event.ctrlKey || event.metaKey)\r\n        return;\r\n\r\n      const [first, last] = getTabbableEdges();\r\n      const hasTabbableElements = first && last;\r\n\r\n      if (!hasTabbableElements) {\r\n        if (document.activeElement === container) event.preventDefault();\r\n        return;\r\n      }\r\n\r\n      if (!event.shiftKey && document.activeElement === last) {\r\n        event.preventDefault();\r\n        first?.focus({ preventScroll: true });\r\n      } else if (event.shiftKey && document.activeElement === first) {\r\n        event.preventDefault();\r\n        last?.focus({ preventScroll: true });\r\n      }\r\n    }\r\n\r\n    const openAutoFocusEvent = new CustomEvent(OPEN_AUTO_FOCUS, EVENT_OPTIONS);\r\n    if (onOpenAutoFocusRef.current) {\r\n      container.addEventListener(\r\n        OPEN_AUTO_FOCUS,\r\n        onOpenAutoFocusRef.current as EventListener,\r\n        { once: true },\r\n      );\r\n    }\r\n    container.dispatchEvent(openAutoFocusEvent);\r\n\r\n    if (!openAutoFocusEvent.defaultPrevented) {\r\n      const tabbableCandidates = getTabbableCandidates();\r\n      if (tabbableCandidates.length > 0) {\r\n        tabbableCandidates[0]?.focus({ preventScroll: true });\r\n      } else {\r\n        container.focus({ preventScroll: true });\r\n      }\r\n    }\r\n\r\n    document.addEventListener(\"focusin\", onFocusIn);\r\n    container.addEventListener(\"keydown\", onKeyDown);\r\n\r\n    return () => {\r\n      document.removeEventListener(\"focusin\", onFocusIn);\r\n      container.removeEventListener(\"keydown\", onKeyDown);\r\n\r\n      if (!tourOpenRef.current) {\r\n        setTimeout(() => {\r\n          const closeAutoFocusEvent = new CustomEvent(\r\n            CLOSE_AUTO_FOCUS,\r\n            EVENT_OPTIONS,\r\n          );\r\n          if (onCloseAutoFocusRef.current) {\r\n            container.addEventListener(\r\n              CLOSE_AUTO_FOCUS,\r\n              onCloseAutoFocusRef.current as EventListener,\r\n              { once: true },\r\n            );\r\n          }\r\n          container.dispatchEvent(closeAutoFocusEvent);\r\n\r\n          if (!closeAutoFocusEvent.defaultPrevented) {\r\n            if (\r\n              previouslyFocusedElement &&\r\n              document.body.contains(previouslyFocusedElement)\r\n            ) {\r\n              previouslyFocusedElement.focus({ preventScroll: true });\r\n            }\r\n          }\r\n\r\n          if (onCloseAutoFocusRef.current) {\r\n            container.removeEventListener(\r\n              CLOSE_AUTO_FOCUS,\r\n              onCloseAutoFocusRef.current as EventListener,\r\n            );\r\n          }\r\n        }, 0);\r\n      }\r\n    };\r\n  }, [\r\n    containerRef,\r\n    enabled,\r\n    onOpenAutoFocusRef,\r\n    onCloseAutoFocusRef,\r\n    tourOpenRef,\r\n  ]);\r\n}\r\n\r\nfunction getDataState(open: boolean) {\r\n  return open ? \"open\" : \"closed\";\r\n}\r\n\r\ninterface StepData {\r\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\r\n  align?: Align;\r\n  alignOffset?: number;\r\n  side?: Side;\r\n  sideOffset?: number;\r\n  collisionBoundary?: Boundary | Boundary[];\r\n  collisionPadding?: number | Partial<Record<Side, number>>;\r\n  arrowPadding?: number;\r\n  sticky?: \"partial\" | \"always\";\r\n  hideWhenDetached?: boolean;\r\n  avoidCollisions?: boolean;\r\n  onStepEnter?: () => void;\r\n  onStepLeave?: () => void;\r\n  required?: boolean;\r\n}\r\n\r\ninterface StoreState {\r\n  open: boolean;\r\n  value: number;\r\n  steps: StepData[];\r\n  maskPath: string;\r\n  spotlightRect: { x: number; y: number; width: number; height: number } | null;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(\r\n    key: K,\r\n    value: StoreState[K],\r\n    opts?: unknown,\r\n  ) => void;\r\n  notify: () => void;\r\n  addStep: (stepData: StepData) => { id: string; index: number };\r\n  removeStep: (id: string) => void;\r\n}\r\n\r\nfunction useStore<T>(\r\n  selector: (state: StoreState) => T,\r\n  ogStore?: Store | null,\r\n): T {\r\n  const contextStore = React.useContext(StoreContext);\r\n\r\n  const store = ogStore ?? contextStore;\r\n\r\n  if (!store) {\r\n    throw new Error(`\\`useStore\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\nfunction getTargetElement(\r\n  target: string | React.RefObject<HTMLElement> | HTMLElement,\r\n): HTMLElement | null {\r\n  if (typeof target === \"string\") {\r\n    return document.querySelector(target);\r\n  }\r\n  if (target && \"current\" in target) {\r\n    return target.current;\r\n  }\r\n  if (target instanceof HTMLElement) {\r\n    return target;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction getDefaultScrollBehavior(): ScrollBehavior {\r\n  if (typeof window === \"undefined\") return \"smooth\";\r\n  return window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\r\n    ? \"auto\"\r\n    : \"smooth\";\r\n}\r\n\r\nfunction onScrollToElement(\r\n  element: HTMLElement,\r\n  scrollBehavior: ScrollBehavior = getDefaultScrollBehavior(),\r\n  scrollOffset?: ScrollOffset,\r\n) {\r\n  const offset: Required<ScrollOffset> = {\r\n    top: 100,\r\n    bottom: 100,\r\n    left: 0,\r\n    right: 0,\r\n    ...scrollOffset,\r\n  };\r\n  const rect = element.getBoundingClientRect();\r\n  const viewportHeight = window.innerHeight;\r\n  const viewportWidth = window.innerWidth;\r\n\r\n  const isInViewport =\r\n    rect.top >= offset.top &&\r\n    rect.bottom <= viewportHeight - offset.bottom &&\r\n    rect.left >= offset.left &&\r\n    rect.right <= viewportWidth - offset.right;\r\n\r\n  if (!isInViewport) {\r\n    const elementTop = rect.top + window.scrollY;\r\n    const scrollTop = elementTop - offset.top;\r\n\r\n    window.scrollTo({\r\n      top: Math.max(0, scrollTop),\r\n      behavior: scrollBehavior,\r\n    });\r\n  }\r\n}\r\n\r\nfunction getSideAndAlignFromPlacement(placement: Placement): [Side, Align] {\r\n  const [side, align = \"center\"] = placement.split(\"-\") as [Side, Align?];\r\n  return [side, align];\r\n}\r\n\r\nfunction getPlacement(side: Side, align: Align): Placement {\r\n  if (align === \"center\") {\r\n    return side as Placement;\r\n  }\r\n  return `${side}-${align}` as Placement;\r\n}\r\n\r\nfunction updateMask(\r\n  store: Store,\r\n  targetElement: HTMLElement,\r\n  padding: number = DEFAULT_SPOTLIGHT_PADDING,\r\n) {\r\n  const clientRect = targetElement.getBoundingClientRect();\r\n  const viewportWidth = window.innerWidth;\r\n  const viewportHeight = window.innerHeight;\r\n\r\n  const x = Math.max(0, clientRect.left - padding);\r\n  const y = Math.max(0, clientRect.top - padding);\r\n  const width = Math.min(viewportWidth - x, clientRect.width + padding * 2);\r\n  const height = Math.min(viewportHeight - y, clientRect.height + padding * 2);\r\n\r\n  const path = `polygon(0% 0%, 0% 100%, ${x}px 100%, ${x}px ${y}px, ${x + width}px ${y}px, ${x + width}px ${y + height}px, ${x}px ${y + height}px, ${x}px 100%, 100% 100%, 100% 0%)`;\r\n  store.setState(\"maskPath\", path);\r\n  store.setState(\"spotlightRect\", { x, y, width, height });\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface TourContextValue {\r\n  dir: Direction;\r\n  alignOffset: number;\r\n  sideOffset: number;\r\n  spotlightPadding: number;\r\n  dismissible: boolean;\r\n  modal: boolean;\r\n  stepFooter?: React.ReactElement;\r\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\r\n  onInteractOutside?: (event: InteractOutsideEvent) => void;\r\n  onOpenAutoFocus?: (event: OpenAutoFocusEvent) => void;\r\n  onCloseAutoFocus?: (event: CloseAutoFocusEvent) => void;\r\n}\r\n\r\nconst TourContext = React.createContext<TourContextValue | null>(null);\r\n\r\nfunction useTourContext(consumerName: string) {\r\n  const context = React.useContext(TourContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface StepContextValue {\r\n  arrowX?: number;\r\n  arrowY?: number;\r\n  placedAlign: Align;\r\n  placedSide: Side;\r\n  shouldHideArrow: boolean;\r\n  onArrowChange: (arrow: HTMLSpanElement | null) => void;\r\n  onFooterChange: (footer: FooterElement | null) => void;\r\n}\r\n\r\nconst StepContext = React.createContext<StepContextValue | null>(null);\r\n\r\nfunction useStepContext(consumerName: string) {\r\n  const context = React.useContext(StepContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${STEP_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nconst DefaultFooterContext = React.createContext(false);\r\n\r\ninterface PortalContextValue {\r\n  portal: HTMLElement | null;\r\n  onPortalChange: (node: HTMLElement | null) => void;\r\n}\r\n\r\nconst PortalContext = React.createContext<PortalContextValue | null>(null);\r\n\r\nfunction usePortalContext(consumerName: string) {\r\n  const context = React.useContext(PortalContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useScrollLock(enabled: boolean) {\r\n  React.useEffect(() => {\r\n    if (!enabled) return;\r\n\r\n    const originalStyle = window.getComputedStyle(document.body).overflow;\r\n    const scrollbarWidth =\r\n      window.innerWidth - document.documentElement.clientWidth;\r\n\r\n    document.body.style.overflow = \"hidden\";\r\n    if (scrollbarWidth > 0) {\r\n      document.body.style.paddingRight = `${scrollbarWidth}px`;\r\n    }\r\n\r\n    return () => {\r\n      document.body.style.overflow = originalStyle;\r\n      document.body.style.paddingRight = \"\";\r\n    };\r\n  }, [enabled]);\r\n}\r\n\r\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\r\ntype InteractOutsideEvent = CustomEvent<{\r\n  originalEvent: PointerEvent | FocusEvent;\r\n}>;\r\ntype OpenAutoFocusEvent = CustomEvent<Record<string, never>>;\r\ntype CloseAutoFocusEvent = CustomEvent<Record<string, never>>;\r\n\r\ninterface TourProps extends DivProps {\r\n  open?: boolean;\r\n  defaultOpen?: boolean;\r\n  onOpenChange?: (open: boolean) => void;\r\n  value?: number;\r\n  defaultValue?: number;\r\n  onValueChange?: (step: number) => void;\r\n  onComplete?: () => void;\r\n  onSkip?: () => void;\r\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\r\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\r\n  onInteractOutside?: (event: InteractOutsideEvent) => void;\r\n  onOpenAutoFocus?: (event: OpenAutoFocusEvent) => void;\r\n  onCloseAutoFocus?: (event: CloseAutoFocusEvent) => void;\r\n  dir?: Direction;\r\n  alignOffset?: number;\r\n  sideOffset?: number;\r\n  spotlightPadding?: number;\r\n  autoScroll?: boolean;\r\n  scrollBehavior?: ScrollBehavior;\r\n  scrollOffset?: ScrollOffset;\r\n  dismissible?: boolean;\r\n  modal?: boolean;\r\n  stepFooter?: React.ReactElement;\r\n}\r\n\r\nfunction Tour(props: TourProps) {\r\n  const {\r\n    open: openProp,\r\n    defaultOpen = false,\r\n    onOpenChange,\r\n    value: valueProp,\r\n    defaultValue = 0,\r\n    onValueChange,\r\n    onComplete,\r\n    onSkip,\r\n    autoScroll = true,\r\n    scrollBehavior = getDefaultScrollBehavior(),\r\n    scrollOffset,\r\n    onEscapeKeyDown,\r\n    onPointerDownOutside,\r\n    onInteractOutside,\r\n    onOpenAutoFocus,\r\n    onCloseAutoFocus,\r\n    dir: dirProp,\r\n    alignOffset = DEFAULT_ALIGN_OFFSET,\r\n    sideOffset = DEFAULT_SIDE_OFFSET,\r\n    spotlightPadding = DEFAULT_SPOTLIGHT_PADDING,\r\n    dismissible = true,\r\n    modal = true,\r\n    stepFooter,\r\n    asChild,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const dir = DirectionPrimitive.useDirection(dirProp);\r\n\r\n  const [portal, setPortal] = React.useState<HTMLElement | null>(null);\r\n  const prevOpenRef = React.useRef<boolean | undefined>(undefined);\r\n  const previouslyFocusedElementRef = React.useRef<HTMLElement | null>(null);\r\n\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    open: openProp ?? defaultOpen,\r\n    value: valueProp ?? defaultValue,\r\n    steps: [],\r\n    maskPath: \"\",\r\n    spotlightRect: null,\r\n  }));\r\n  const listenersRef = useLazyRef<Set<() => void>>(() => new Set());\r\n  const stepIdsMapRef = useLazyRef<Map<string, number>>(() => new Map());\r\n  const stepIdCounterRef = useLazyRef(() => ({ current: 0 }));\r\n  const propsRef = useAsRef({\r\n    valueProp,\r\n    onOpenChange,\r\n    onValueChange,\r\n    onComplete,\r\n    onSkip,\r\n    onEscapeKeyDown,\r\n    onCloseAutoFocus,\r\n    autoScroll,\r\n    scrollBehavior,\r\n    scrollOffset,\r\n  });\r\n\r\n  const store: Store = React.useMemo(\r\n    () => ({\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => {\r\n        return stateRef.current;\r\n      },\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n        stateRef.current[key] = value;\r\n\r\n        if (key === \"open\" && typeof value === \"boolean\") {\r\n          propsRef.current.onOpenChange?.(value);\r\n\r\n          if (value) {\r\n            if (stateRef.current.steps.length > 0) {\r\n              if (stateRef.current.value >= stateRef.current.steps.length) {\r\n                store.setState(\"value\", 0);\r\n              }\r\n            }\r\n          } else {\r\n            if (\r\n              stateRef.current.value <\r\n              (stateRef.current.steps.length || 0) - 1\r\n            ) {\r\n              propsRef.current.onSkip?.();\r\n            }\r\n          }\r\n        } else if (key === \"value\" && typeof value === \"number\") {\r\n          const prevStep = stateRef.current.steps[stateRef.current.value];\r\n          const nextStep = stateRef.current.steps[value];\r\n\r\n          prevStep?.onStepLeave?.();\r\n          nextStep?.onStepEnter?.();\r\n\r\n          if (value >= stateRef.current.steps.length) {\r\n            propsRef.current.onComplete?.();\r\n\r\n            if (propsRef.current.valueProp !== undefined) {\r\n              propsRef.current.onValueChange?.(value);\r\n            }\r\n\r\n            store.setState(\"open\", false);\r\n            return;\r\n          }\r\n\r\n          if (propsRef.current.valueProp !== undefined) {\r\n            propsRef.current.onValueChange?.(value);\r\n            return;\r\n          }\r\n\r\n          propsRef.current.onValueChange?.(value);\r\n\r\n          if (nextStep && propsRef.current.autoScroll) {\r\n            const targetElement = getTargetElement(nextStep.target);\r\n            if (targetElement) {\r\n              onScrollToElement(\r\n                targetElement,\r\n                propsRef.current.scrollBehavior,\r\n                propsRef.current.scrollOffset,\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        listenersRef.current.forEach((l) => {\r\n          l();\r\n        });\r\n      },\r\n      addStep: (stepData) => {\r\n        const id = `step-${stepIdCounterRef.current.current++}`;\r\n        const index = stateRef.current.steps.length;\r\n        stepIdsMapRef.current.set(id, index);\r\n        stateRef.current.steps = [...stateRef.current.steps, stepData];\r\n        store.notify();\r\n        return { id, index };\r\n      },\r\n      removeStep: (id) => {\r\n        const index = stepIdsMapRef.current.get(id);\r\n        if (index === undefined) return;\r\n\r\n        stateRef.current.steps = stateRef.current.steps.filter(\r\n          (_, i) => i !== index,\r\n        );\r\n\r\n        stepIdsMapRef.current.delete(id);\r\n\r\n        for (const [stepId, stepIndex] of stepIdsMapRef.current.entries()) {\r\n          if (stepIndex > index) {\r\n            stepIdsMapRef.current.set(stepId, stepIndex - 1);\r\n          }\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n    }),\r\n    [stateRef, listenersRef, stepIdsMapRef, stepIdCounterRef, propsRef],\r\n  );\r\n\r\n  const open = useStore((state) => state.open, store);\r\n\r\n  React.useEffect(() => {\r\n    function onKeyDown(event: KeyboardEvent) {\r\n      if (open && event.key === \"Escape\") {\r\n        if (propsRef.current.onEscapeKeyDown) {\r\n          propsRef.current.onEscapeKeyDown(event);\r\n          if (event.defaultPrevented) return;\r\n        }\r\n        store.setState(\"open\", false);\r\n      }\r\n    }\r\n\r\n    document.addEventListener(\"keydown\", onKeyDown);\r\n    return () => document.removeEventListener(\"keydown\", onKeyDown);\r\n  }, [store, open, propsRef]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const wasOpen = prevOpenRef.current;\r\n\r\n    if (open && !wasOpen) {\r\n      previouslyFocusedElementRef.current =\r\n        document.activeElement as HTMLElement | null;\r\n    } else if (!open && wasOpen) {\r\n      setTimeout(() => {\r\n        const container = portal ?? document.body;\r\n        const closeAutoFocusEvent = new CustomEvent(\r\n          CLOSE_AUTO_FOCUS,\r\n          EVENT_OPTIONS,\r\n        );\r\n\r\n        if (propsRef.current.onCloseAutoFocus) {\r\n          container.addEventListener(\r\n            CLOSE_AUTO_FOCUS,\r\n            propsRef.current.onCloseAutoFocus as EventListener,\r\n            { once: true },\r\n          );\r\n        }\r\n        container.dispatchEvent(closeAutoFocusEvent);\r\n\r\n        if (!closeAutoFocusEvent.defaultPrevented) {\r\n          const elementToFocus = previouslyFocusedElementRef.current;\r\n          if (elementToFocus && document.body.contains(elementToFocus)) {\r\n            elementToFocus.focus({ preventScroll: true });\r\n          }\r\n        }\r\n\r\n        previouslyFocusedElementRef.current = null;\r\n      }, 0);\r\n    }\r\n\r\n    prevOpenRef.current = open;\r\n  }, [open, portal, propsRef]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (openProp !== undefined) {\r\n      store.setState(\"open\", openProp);\r\n    }\r\n  }, [openProp, store]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (valueProp !== undefined) {\r\n      store.setState(\"value\", valueProp);\r\n    }\r\n  }, [valueProp, store]);\r\n\r\n  const contextValue = React.useMemo<TourContextValue>(\r\n    () => ({\r\n      dir,\r\n      alignOffset,\r\n      sideOffset,\r\n      spotlightPadding,\r\n      dismissible,\r\n      modal,\r\n      stepFooter,\r\n      onPointerDownOutside,\r\n      onInteractOutside,\r\n      onOpenAutoFocus,\r\n      onCloseAutoFocus,\r\n    }),\r\n    [\r\n      dir,\r\n      alignOffset,\r\n      sideOffset,\r\n      spotlightPadding,\r\n      dismissible,\r\n      modal,\r\n      stepFooter,\r\n      onPointerDownOutside,\r\n      onInteractOutside,\r\n      onOpenAutoFocus,\r\n      onCloseAutoFocus,\r\n    ],\r\n  );\r\n\r\n  const portalContextValue = React.useMemo<PortalContextValue>(\r\n    () => ({\r\n      portal,\r\n      onPortalChange: setPortal,\r\n    }),\r\n    [portal],\r\n  );\r\n\r\n  useScrollLock(open && modal);\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <TourContext.Provider value={contextValue}>\r\n        <PortalContext.Provider value={portalContextValue}>\r\n          <RootPrimitive data-slot=\"tour\" dir={dir} {...rootProps} />\r\n        </PortalContext.Provider>\r\n      </TourContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface TourStepProps extends DivProps {\r\n  target: string | React.RefObject<HTMLElement> | HTMLElement;\r\n  side?: Side;\r\n  sideOffset?: number;\r\n  align?: Align;\r\n  alignOffset?: number;\r\n  collisionBoundary?: Boundary | Boundary[];\r\n  collisionPadding?: number | Partial<Record<Side, number>>;\r\n  arrowPadding?: number;\r\n  sticky?: \"partial\" | \"always\";\r\n  hideWhenDetached?: boolean;\r\n  avoidCollisions?: boolean;\r\n  required?: boolean;\r\n  forceMount?: boolean;\r\n  onStepEnter?: () => void;\r\n  onStepLeave?: () => void;\r\n}\r\n\r\nfunction TourStep(props: TourStepProps) {\r\n  const {\r\n    target,\r\n    side = \"bottom\",\r\n    sideOffset,\r\n    align = \"center\",\r\n    alignOffset,\r\n    collisionBoundary = [],\r\n    collisionPadding = 0,\r\n    arrowPadding = 0,\r\n    sticky = \"partial\",\r\n    hideWhenDetached = false,\r\n    avoidCollisions = true,\r\n    required = false,\r\n    forceMount = false,\r\n    onStepEnter,\r\n    onStepLeave,\r\n    onPointerDownCapture: onPointerDownCaptureProp,\r\n    onFocusCapture: onFocusCaptureProp,\r\n    onBlurCapture: onBlurCaptureProp,\r\n    children,\r\n    className,\r\n    style,\r\n    asChild,\r\n    ...stepProps\r\n  } = props;\r\n\r\n  const store = useStoreContext(STEP_NAME);\r\n\r\n  const [arrow, setArrow] = React.useState<HTMLSpanElement | null>(null);\r\n  const [footer, setFooter] = React.useState<FooterElement | null>(null);\r\n\r\n  const stepRef = React.useRef<StepElement | null>(null);\r\n  const stepIdRef = React.useRef<string>(\"\");\r\n  const stepOrderRef = React.useRef<number>(-1);\r\n  const isPointerInsideReactTreeRef = React.useRef(false);\r\n  const isFocusInsideReactTreeRef = React.useRef(false);\r\n\r\n  const open = useStore((state) => state.open);\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n  const context = useTourContext(STEP_NAME);\r\n\r\n  const resolvedSideOffset = sideOffset ?? context.sideOffset;\r\n  const resolvedAlignOffset = alignOffset ?? context.alignOffset;\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const { id, index } = store.addStep({\r\n      target,\r\n      align,\r\n      alignOffset: resolvedAlignOffset,\r\n      side,\r\n      sideOffset: resolvedSideOffset,\r\n      collisionBoundary,\r\n      collisionPadding,\r\n      arrowPadding,\r\n      sticky,\r\n      hideWhenDetached,\r\n      avoidCollisions,\r\n      onStepEnter,\r\n      onStepLeave,\r\n      required,\r\n    });\r\n    stepIdRef.current = id;\r\n    stepOrderRef.current = index;\r\n\r\n    return () => {\r\n      store.removeStep(stepIdRef.current);\r\n    };\r\n  }, [\r\n    target,\r\n    side,\r\n    resolvedSideOffset,\r\n    align,\r\n    resolvedAlignOffset,\r\n    collisionPadding,\r\n    arrowPadding,\r\n    sticky,\r\n    hideWhenDetached,\r\n    avoidCollisions,\r\n    required,\r\n    onStepEnter,\r\n    onStepLeave,\r\n    store,\r\n  ]);\r\n\r\n  const stepData = steps[value];\r\n  const targetElement = stepData ? getTargetElement(stepData.target) : null;\r\n\r\n  const isCurrentStep = stepOrderRef.current === value;\r\n\r\n  const middleware = React.useMemo(() => {\r\n    if (!stepData) return [];\r\n\r\n    const mainAxisOffset = stepData.sideOffset ?? resolvedSideOffset;\r\n    const crossAxisOffset = stepData.alignOffset ?? resolvedAlignOffset;\r\n\r\n    const padding =\r\n      typeof stepData.collisionPadding === \"number\"\r\n        ? stepData.collisionPadding\r\n        : {\r\n            top: stepData.collisionPadding?.top ?? 0,\r\n            right: stepData.collisionPadding?.right ?? 0,\r\n            bottom: stepData.collisionPadding?.bottom ?? 0,\r\n            left: stepData.collisionPadding?.left ?? 0,\r\n          };\r\n\r\n    const boundary = Array.isArray(stepData.collisionBoundary)\r\n      ? stepData.collisionBoundary\r\n      : stepData.collisionBoundary\r\n        ? [stepData.collisionBoundary]\r\n        : [];\r\n    const hasExplicitBoundaries = boundary.length > 0;\r\n\r\n    const detectOverflowOptions = {\r\n      padding,\r\n      boundary: boundary.filter((b): b is Element => b !== null),\r\n      altBoundary: hasExplicitBoundaries,\r\n    };\r\n\r\n    return [\r\n      offset({\r\n        mainAxis: mainAxisOffset,\r\n        alignmentAxis: crossAxisOffset,\r\n      }),\r\n      stepData.avoidCollisions &&\r\n        shift({\r\n          mainAxis: true,\r\n          crossAxis: false,\r\n          limiter: stepData.sticky === \"partial\" ? limitShift() : undefined,\r\n          ...detectOverflowOptions,\r\n        }),\r\n      stepData.avoidCollisions && flip({ ...detectOverflowOptions }),\r\n      arrow && onArrow({ element: arrow, padding: stepData.arrowPadding }),\r\n      stepData.hideWhenDetached &&\r\n        hide({\r\n          strategy: \"referenceHidden\",\r\n          ...detectOverflowOptions,\r\n        }),\r\n    ].filter(Boolean) as Middleware[];\r\n  }, [stepData, resolvedSideOffset, resolvedAlignOffset, arrow]);\r\n\r\n  const placement = getPlacement(\r\n    stepData?.side ?? side,\r\n    stepData?.align ?? align,\r\n  );\r\n\r\n  const {\r\n    refs,\r\n    floatingStyles,\r\n    placement: finalPlacement,\r\n    middlewareData,\r\n  } = useFloating({\r\n    placement,\r\n    middleware,\r\n    strategy: \"fixed\",\r\n    whileElementsMounted: autoUpdate,\r\n    elements: {\r\n      reference: targetElement,\r\n    },\r\n  });\r\n\r\n  const composedRef = useComposedRefs(refs.setFloating, stepRef);\r\n\r\n  const [placedSide, placedAlign] =\r\n    getSideAndAlignFromPlacement(finalPlacement);\r\n\r\n  const arrowX = middlewareData.arrow?.x;\r\n  const arrowY = middlewareData.arrow?.y;\r\n  const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\r\n  const isHidden = hideWhenDetached && middlewareData.hide?.referenceHidden;\r\n\r\n  const stepContextValue = React.useMemo<StepContextValue>(\r\n    () => ({\r\n      arrowX,\r\n      arrowY,\r\n      placedAlign,\r\n      placedSide,\r\n      shouldHideArrow: cannotCenterArrow,\r\n      onArrowChange: setArrow,\r\n      onFooterChange: setFooter,\r\n    }),\r\n    [arrowX, arrowY, placedSide, placedAlign, cannotCenterArrow],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (open && targetElement && isCurrentStep) {\r\n      updateMask(store, targetElement, context.spotlightPadding);\r\n\r\n      let rafId: number | null = null;\r\n\r\n      function onResize() {\r\n        if (targetElement) {\r\n          updateMask(store, targetElement, context.spotlightPadding);\r\n        }\r\n      }\r\n\r\n      function onScroll() {\r\n        if (rafId !== null) return;\r\n        rafId = requestAnimationFrame(() => {\r\n          if (targetElement) {\r\n            updateMask(store, targetElement, context.spotlightPadding);\r\n          }\r\n          rafId = null;\r\n        });\r\n      }\r\n\r\n      window.addEventListener(\"resize\", onResize);\r\n      window.addEventListener(\"scroll\", onScroll, { passive: true });\r\n      return () => {\r\n        window.removeEventListener(\"resize\", onResize);\r\n        window.removeEventListener(\"scroll\", onScroll);\r\n        if (rafId !== null) {\r\n          cancelAnimationFrame(rafId);\r\n        }\r\n      };\r\n    }\r\n  }, [open, targetElement, isCurrentStep, store, context.spotlightPadding]);\r\n\r\n  React.useEffect(() => {\r\n    if (!open || !isCurrentStep) return;\r\n\r\n    const stepElement = stepRef.current;\r\n    if (!stepElement) return;\r\n\r\n    const ownerDocument = stepElement.ownerDocument;\r\n\r\n    function onPointerDown(event: PointerEvent) {\r\n      if (event.target && !isPointerInsideReactTreeRef.current) {\r\n        const pointerDownOutsideEvent = new CustomEvent(POINTER_DOWN_OUTSIDE, {\r\n          ...EVENT_OPTIONS,\r\n          detail: { originalEvent: event },\r\n        });\r\n\r\n        context.onPointerDownOutside?.(pointerDownOutsideEvent);\r\n\r\n        const interactOutsideEvent = new CustomEvent(INTERACT_OUTSIDE, {\r\n          ...EVENT_OPTIONS,\r\n          detail: { originalEvent: event },\r\n        });\r\n        context.onInteractOutside?.(interactOutsideEvent);\r\n\r\n        if (\r\n          !pointerDownOutsideEvent.defaultPrevented &&\r\n          !interactOutsideEvent.defaultPrevented &&\r\n          context.dismissible\r\n        ) {\r\n          store.setState(\"open\", false);\r\n        }\r\n      }\r\n\r\n      isPointerInsideReactTreeRef.current = false;\r\n    }\r\n\r\n    const timerId = window.setTimeout(() => {\r\n      ownerDocument.addEventListener(\"pointerdown\", onPointerDown);\r\n    }, 0);\r\n\r\n    return () => {\r\n      window.clearTimeout(timerId);\r\n      ownerDocument.removeEventListener(\"pointerdown\", onPointerDown);\r\n    };\r\n  }, [open, isCurrentStep, store, context]);\r\n\r\n  React.useEffect(() => {\r\n    if (!open || !isCurrentStep) return;\r\n\r\n    const stepElement = stepRef.current;\r\n    if (!stepElement) return;\r\n\r\n    const ownerDocument = stepElement.ownerDocument;\r\n\r\n    function onFocusIn(event: FocusEvent) {\r\n      const target = event.target as HTMLElement;\r\n\r\n      const isFocusInStep = stepElement?.contains(target);\r\n      const isFocusInTarget = targetElement?.contains(target);\r\n\r\n      if (\r\n        event.target &&\r\n        !isFocusInsideReactTreeRef.current &&\r\n        !isFocusInStep &&\r\n        !isFocusInTarget\r\n      ) {\r\n        const interactOutsideEvent = new CustomEvent(INTERACT_OUTSIDE, {\r\n          ...EVENT_OPTIONS,\r\n          detail: { originalEvent: event },\r\n        });\r\n\r\n        context.onInteractOutside?.(interactOutsideEvent);\r\n\r\n        if (!interactOutsideEvent.defaultPrevented && context.dismissible) {\r\n          store.setState(\"open\", false);\r\n        }\r\n      }\r\n    }\r\n\r\n    ownerDocument.addEventListener(\"focusin\", onFocusIn);\r\n\r\n    return () => {\r\n      ownerDocument.removeEventListener(\"focusin\", onFocusIn);\r\n    };\r\n  }, [open, isCurrentStep, store, context, targetElement]);\r\n\r\n  const onPointerDownCapture = React.useCallback(\r\n    (event: React.PointerEvent<StepElement>) => {\r\n      onPointerDownCaptureProp?.(event);\r\n      isPointerInsideReactTreeRef.current = true;\r\n    },\r\n    [onPointerDownCaptureProp],\r\n  );\r\n\r\n  const onFocusCapture = React.useCallback(\r\n    (event: React.FocusEvent<StepElement>) => {\r\n      onFocusCaptureProp?.(event);\r\n      isFocusInsideReactTreeRef.current = true;\r\n    },\r\n    [onFocusCaptureProp],\r\n  );\r\n\r\n  const onBlurCapture = React.useCallback(\r\n    (event: React.FocusEvent<StepElement>) => {\r\n      onBlurCaptureProp?.(event);\r\n      isFocusInsideReactTreeRef.current = false;\r\n    },\r\n    [onBlurCaptureProp],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (!open || !isCurrentStep || !targetElement) return;\r\n\r\n    function onTargetPointerDownCapture() {\r\n      isPointerInsideReactTreeRef.current = true;\r\n    }\r\n\r\n    function onTargetFocusCapture() {\r\n      isFocusInsideReactTreeRef.current = true;\r\n    }\r\n\r\n    function onTargetBlurCapture() {\r\n      isFocusInsideReactTreeRef.current = false;\r\n    }\r\n\r\n    targetElement.addEventListener(\r\n      \"pointerdown\",\r\n      onTargetPointerDownCapture,\r\n      true,\r\n    );\r\n    targetElement.addEventListener(\"focus\", onTargetFocusCapture, true);\r\n    targetElement.addEventListener(\"blur\", onTargetBlurCapture, true);\r\n\r\n    return () => {\r\n      targetElement.removeEventListener(\r\n        \"pointerdown\",\r\n        onTargetPointerDownCapture,\r\n        true,\r\n      );\r\n      targetElement.removeEventListener(\"focus\", onTargetFocusCapture, true);\r\n      targetElement.removeEventListener(\"blur\", onTargetBlurCapture, true);\r\n    };\r\n  }, [open, isCurrentStep, targetElement]);\r\n\r\n  useFocusGuards();\r\n  useFocusTrap(\r\n    stepRef,\r\n    open && isCurrentStep,\r\n    open,\r\n    context.onOpenAutoFocus,\r\n    context.onCloseAutoFocus,\r\n  );\r\n\r\n  if (!open || !stepData || (!targetElement && !forceMount) || !isCurrentStep) {\r\n    return null;\r\n  }\r\n\r\n  const StepPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StepContext.Provider value={stepContextValue}>\r\n      <StepPrimitive\r\n        ref={composedRef}\r\n        data-slot=\"tour-step\"\r\n        data-side={placedSide}\r\n        data-align={placedAlign}\r\n        dir={context.dir}\r\n        tabIndex={-1}\r\n        {...stepProps}\r\n        onPointerDownCapture={onPointerDownCapture}\r\n        onFocusCapture={onFocusCapture}\r\n        onBlurCapture={onBlurCapture}\r\n        className={cn(\r\n          \"fixed z-50 flex w-80 flex-col gap-4 rounded-lg border bg-popover p-4 text-popover-foreground shadow-md outline-none\",\r\n          className,\r\n        )}\r\n        style={{\r\n          ...style,\r\n          ...floatingStyles,\r\n          visibility: isHidden ? \"hidden\" : undefined,\r\n          pointerEvents: isHidden ? \"none\" : undefined,\r\n        }}\r\n      >\r\n        {children}\r\n        {!footer && (\r\n          <DefaultFooterContext.Provider value={true}>\r\n            {context.stepFooter}\r\n          </DefaultFooterContext.Provider>\r\n        )}\r\n      </StepPrimitive>\r\n    </StepContext.Provider>\r\n  );\r\n}\r\n\r\ninterface TourSpotlightProps extends DivProps {\r\n  forceMount?: boolean;\r\n}\r\n\r\nfunction TourSpotlight(props: TourSpotlightProps) {\r\n  const {\r\n    asChild,\r\n    className,\r\n    style,\r\n    forceMount = false,\r\n    ...backdropProps\r\n  } = props;\r\n\r\n  const open = useStore((state) => state.open);\r\n  const maskPath = useStore((state) => state.maskPath);\r\n\r\n  if (!open && !forceMount) return null;\r\n\r\n  const SpotlightPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <SpotlightPrimitive\r\n      data-slot=\"tour-spotlight\"\r\n      data-state={getDataState(open)}\r\n      {...backdropProps}\r\n      className={cn(\r\n        \"data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=open]:animate-in\",\r\n        className,\r\n      )}\r\n      style={{\r\n        clipPath: maskPath,\r\n        ...style,\r\n      }}\r\n    />\r\n  );\r\n}\r\n\r\ninterface TourSpotlightRingProps extends DivProps {\r\n  forceMount?: boolean;\r\n}\r\n\r\nfunction TourSpotlightRing(props: TourSpotlightRingProps) {\r\n  const { asChild, className, style, forceMount = false, ...ringProps } = props;\r\n\r\n  const open = useStore((state) => state.open);\r\n  const spotlightRect = useStore((state) => state.spotlightRect);\r\n\r\n  if (!open && !forceMount) return null;\r\n  if (!spotlightRect) return null;\r\n\r\n  const RingPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <RingPrimitive\r\n      data-slot=\"tour-spotlight-ring\"\r\n      data-state={getDataState(open)}\r\n      {...ringProps}\r\n      className={cn(\r\n        \"pointer-events-none fixed z-50 border-ring ring-[3px] ring-ring/50\",\r\n        className,\r\n      )}\r\n      style={{\r\n        left: spotlightRect.x,\r\n        top: spotlightRect.y,\r\n        width: spotlightRect.width,\r\n        height: spotlightRect.height,\r\n        ...style,\r\n      }}\r\n    />\r\n  );\r\n}\r\n\r\ninterface TourPortalProps {\r\n  children?: React.ReactNode;\r\n  container?: HTMLElement | null;\r\n}\r\n\r\nfunction TourPortal(props: TourPortalProps) {\r\n  const { children, container } = props;\r\n\r\n  const portalContext = usePortalContext(PORTAL_NAME);\r\n\r\n  const [mounted, setMounted] = React.useState(false);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    setMounted(true);\r\n\r\n    const node = container ?? document.body;\r\n\r\n    portalContext?.onPortalChange(node);\r\n    return () => {\r\n      portalContext?.onPortalChange(null);\r\n    };\r\n  }, [container, portalContext]);\r\n\r\n  if (!mounted) return null;\r\n\r\n  const portalContainer = container ?? portalContext?.portal ?? document.body;\r\n\r\n  return ReactDOM.createPortal(children, portalContainer);\r\n}\r\n\r\ninterface TourArrowProps extends React.ComponentProps<\"svg\"> {\r\n  width?: number;\r\n  height?: number;\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction TourArrow(props: TourArrowProps) {\r\n  const {\r\n    width = 10,\r\n    height = 5,\r\n    className,\r\n    children,\r\n    asChild,\r\n    ...arrowProps\r\n  } = props;\r\n\r\n  const stepContext = useStepContext(ARROW_NAME);\r\n  const baseSide = OPPOSITE_SIDE[stepContext.placedSide];\r\n\r\n  return (\r\n    <span\r\n      ref={stepContext.onArrowChange}\r\n      data-slot=\"tour-arrow\"\r\n      style={{\r\n        position: \"absolute\",\r\n        left:\r\n          stepContext.arrowX != null ? `${stepContext.arrowX}px` : undefined,\r\n        top: stepContext.arrowY != null ? `${stepContext.arrowY}px` : undefined,\r\n        [baseSide]: 0,\r\n        transformOrigin: {\r\n          top: \"\",\r\n          right: \"0 0\",\r\n          bottom: \"center 0\",\r\n          left: \"100% 0\",\r\n        }[stepContext.placedSide],\r\n        transform: {\r\n          top: \"translateY(100%)\",\r\n          right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\r\n          bottom: \"rotate(180deg)\",\r\n          left: \"translateY(50%) rotate(-90deg) translateX(50%)\",\r\n        }[stepContext.placedSide],\r\n        visibility: stepContext.shouldHideArrow ? \"hidden\" : undefined,\r\n      }}\r\n    >\r\n      <svg\r\n        viewBox=\"0 0 30 10\"\r\n        preserveAspectRatio=\"none\"\r\n        width={width}\r\n        height={height}\r\n        {...arrowProps}\r\n        className={cn(\"block fill-popover stroke-border\", className)}\r\n      >\r\n        {asChild ? children : <polygon points=\"0,0 30,0 15,10\" />}\r\n      </svg>\r\n    </span>\r\n  );\r\n}\r\n\r\nfunction TourHeader(props: DivProps) {\r\n  const { asChild, className, ...headerProps } = props;\r\n\r\n  const context = useTourContext(HEADER_NAME);\r\n\r\n  const HeaderPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <HeaderPrimitive\r\n      data-slot=\"tour-header\"\r\n      dir={context.dir}\r\n      {...headerProps}\r\n      className={cn(\r\n        \"flex flex-col gap-1.5 text-center sm:text-left\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nfunction TourTitle(props: DivProps) {\r\n  const { asChild, className, ...titleProps } = props;\r\n\r\n  const context = useTourContext(TITLE_NAME);\r\n\r\n  const TitlePrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <TitlePrimitive\r\n      data-slot=\"tour-title\"\r\n      dir={context.dir}\r\n      {...titleProps}\r\n      className={cn(\r\n        \"font-semibold text-lg leading-none tracking-tight\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nfunction TourDescription(props: DivProps) {\r\n  const { asChild, className, ...descriptionProps } = props;\r\n\r\n  const context = useTourContext(DESCRIPTION_NAME);\r\n\r\n  const DescriptionPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <DescriptionPrimitive\r\n      data-slot=\"tour-description\"\r\n      dir={context.dir}\r\n      {...descriptionProps}\r\n      className={cn(\"text-muted-foreground text-sm\", className)}\r\n    />\r\n  );\r\n}\r\n\r\ninterface TourCloseProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction TourClose(props: TourCloseProps) {\r\n  const {\r\n    asChild,\r\n    className,\r\n    onClick: onClickProp,\r\n    ...closeButtonProps\r\n  } = props;\r\n\r\n  const store = useStoreContext(CLOSE_NAME);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<CloseElement>) => {\r\n      onClickProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      store.setState(\"open\", false);\r\n    },\r\n    [store, onClickProp],\r\n  );\r\n\r\n  const ClosePrimitive = asChild ? SlotPrimitive.Slot : \"button\";\r\n\r\n  return (\r\n    <ClosePrimitive\r\n      type=\"button\"\r\n      aria-label=\"Close tour\"\r\n      className={cn(\r\n        \"absolute top-4 right-4 rounded-xs opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0\",\r\n        className,\r\n      )}\r\n      onClick={onClick}\r\n      {...closeButtonProps}\r\n    >\r\n      <X className=\"size-4\" />\r\n    </ClosePrimitive>\r\n  );\r\n}\r\n\r\nfunction TourPrev(props: React.ComponentProps<typeof Button>) {\r\n  const { children, onClick: onClickProp, ...prevButtonProps } = props;\r\n\r\n  const store = useStoreContext(PREV_NAME);\r\n  const value = useStore((state) => state.value);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<PrevElement>) => {\r\n      onClickProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (value > 0) {\r\n        store.setState(\"value\", value - 1);\r\n      }\r\n    },\r\n    [value, store, onClickProp],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      aria-label=\"Previous step\"\r\n      data-slot=\"tour-prev\"\r\n      variant=\"outline\"\r\n      {...prevButtonProps}\r\n      onClick={onClick}\r\n      disabled={value === 0}\r\n    >\r\n      {children ?? (\r\n        <>\r\n          <ChevronLeft />\r\n          Previous\r\n        </>\r\n      )}\r\n    </Button>\r\n  );\r\n}\r\n\r\nfunction TourNext(props: React.ComponentProps<typeof Button>) {\r\n  const { children, onClick: onClickProp, ...nextButtonProps } = props;\r\n  const store = useStoreContext(NEXT_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n\r\n  const isLastStep = value === steps.length - 1;\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<NextElement>) => {\r\n      onClickProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      store.setState(\"value\", value + 1);\r\n    },\r\n    [value, store, onClickProp],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      aria-label=\"Next step\"\r\n      data-slot=\"tour-next\"\r\n      {...nextButtonProps}\r\n      onClick={onClick}\r\n    >\r\n      {children ?? (\r\n        <>\r\n          {isLastStep ? \"Finish\" : \"Next\"}\r\n          {!isLastStep && <ChevronRight />}\r\n        </>\r\n      )}\r\n    </Button>\r\n  );\r\n}\r\n\r\nfunction TourSkip(props: React.ComponentProps<typeof Button>) {\r\n  const { children, onClick: onClickProp, ...skipButtonProps } = props;\r\n\r\n  const store = useStoreContext(SKIP_NAME);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<SkipElement>) => {\r\n      onClickProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      store.setState(\"open\", false);\r\n    },\r\n    [store, onClickProp],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      aria-label=\"Skip tour\"\r\n      data-slot=\"tour-skip\"\r\n      variant=\"outline\"\r\n      {...skipButtonProps}\r\n      onClick={onClick}\r\n    >\r\n      {children ?? \"Skip\"}\r\n    </Button>\r\n  );\r\n}\r\n\r\ninterface TourStepCounterProps extends DivProps {\r\n  format?: (current: number, total: number) => string;\r\n}\r\n\r\nfunction TourStepCounter(props: TourStepCounterProps) {\r\n  const {\r\n    format = (current, total) => `${current} / ${total}`,\r\n    asChild,\r\n    className,\r\n    children,\r\n    ...stepCounterProps\r\n  } = props;\r\n\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n\r\n  const StepCounterPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StepCounterPrimitive\r\n      data-slot=\"tour-step-counter\"\r\n      {...stepCounterProps}\r\n      className={cn(\"text-muted-foreground text-sm\", className)}\r\n    >\r\n      {children ?? format(value + 1, steps.length)}\r\n    </StepCounterPrimitive>\r\n  );\r\n}\r\n\r\nfunction TourFooter(props: DivProps) {\r\n  const { asChild, className, ref, ...footerProps } = props;\r\n\r\n  const stepContext = useStepContext(FOOTER_NAME);\r\n  const hasDefaultFooter = React.useContext(DefaultFooterContext);\r\n  const context = useTourContext(FOOTER_NAME);\r\n\r\n  const composedRef = useComposedRefs(\r\n    ref,\r\n    hasDefaultFooter ? undefined : stepContext.onFooterChange,\r\n  );\r\n\r\n  const FooterPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <FooterPrimitive\r\n      data-slot=\"tour-footer\"\r\n      dir={context.dir}\r\n      {...footerProps}\r\n      ref={composedRef}\r\n      className={cn(\r\n        \"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  Tour,\r\n  TourPortal,\r\n  TourSpotlight,\r\n  TourSpotlightRing,\r\n  TourStep,\r\n  TourArrow,\r\n  TourHeader,\r\n  TourTitle,\r\n  TourDescription,\r\n  TourClose,\r\n  TourPrev,\r\n  TourNext,\r\n  TourSkip,\r\n  TourStepCounter,\r\n  TourFooter,\r\n  //\r\n  type TourProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}