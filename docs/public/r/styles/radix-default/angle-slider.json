{
  "name": "angle-slider",
  "dependencies": [
    "radix-ui"
  ],
  "registryDependencies": [
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/angle-slider.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  Direction as DirectionPrimitive,\r\n  Slot as SlotPrimitive,\r\n} from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { VisuallyHiddenInput } from \"@/registry/bases/radix/components/visually-hidden-input\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"AngleSlider\";\r\nconst THUMB_NAME = \"AngleSliderThumb\";\r\n\r\nconst PAGE_KEYS = [\"PageUp\", \"PageDown\"];\r\nconst ARROW_KEYS = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof AngleSlider>;\r\ntype ThumbElement = React.ComponentRef<typeof AngleSliderThumb>;\r\n\r\nfunction clamp(value: number, [min, max]: [number, number]) {\r\n  return Math.min(max, Math.max(min, value));\r\n}\r\n\r\nfunction getNextSortedValues(\r\n  prevValues: number[] = [],\r\n  nextValue: number,\r\n  atIndex: number,\r\n) {\r\n  const nextValues = [...prevValues];\r\n  nextValues[atIndex] = nextValue;\r\n  return nextValues.sort((a, b) => a - b);\r\n}\r\n\r\nfunction getStepsBetweenValues(values: number[]) {\r\n  return values.slice(0, -1).map((value, index) => {\r\n    const nextValue = values[index + 1];\r\n    return nextValue !== undefined ? nextValue - value : 0;\r\n  });\r\n}\r\n\r\nfunction hasMinStepsBetweenValues(\r\n  values: number[],\r\n  minStepsBetweenValues: number,\r\n) {\r\n  if (minStepsBetweenValues > 0) {\r\n    const stepsBetweenValues = getStepsBetweenValues(values);\r\n    const actualMinStepsBetweenValues =\r\n      stepsBetweenValues.length > 0 ? Math.min(...stepsBetweenValues) : 0;\r\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction getDecimalCount(value: number) {\r\n  return (String(value).split(\".\")[1] ?? \"\").length;\r\n}\r\n\r\nfunction roundValue(value: number, decimalCount: number) {\r\n  const rounder = 10 ** decimalCount;\r\n  return Math.round(value * rounder) / rounder;\r\n}\r\n\r\nfunction getClosestValueIndex(values: number[], nextValue: number) {\r\n  if (values.length === 1) return 0;\r\n  const distances = values.map((value) => Math.abs(value - nextValue));\r\n  const closestDistance = Math.min(...distances);\r\n  return distances.indexOf(closestDistance);\r\n}\r\n\r\ninterface ThumbData {\r\n  id: string;\r\n  element: ThumbElement;\r\n  index: number;\r\n  value: number;\r\n}\r\n\r\ninterface StoreState {\r\n  values: number[];\r\n  thumbs: Map<number, ThumbData>;\r\n  valueIndexToChange: number;\r\n  min: number;\r\n  max: number;\r\n  step: number;\r\n  size: number;\r\n  thickness: number;\r\n  startAngle: number;\r\n  endAngle: number;\r\n  minStepsBetweenThumbs: number;\r\n  disabled: boolean;\r\n  inverted: boolean;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  notify: () => void;\r\n  addThumb: (index: number, thumbData: ThumbData) => void;\r\n  removeThumb: (index: number) => void;\r\n  updateValue: (\r\n    value: number,\r\n    atIndex: number,\r\n    options?: { commit?: boolean },\r\n  ) => void;\r\n  getValueFromPointer: (\r\n    clientX: number,\r\n    clientY: number,\r\n    rect: DOMRect,\r\n  ) => number;\r\n  getAngleFromValue: (value: number) => number;\r\n  getPositionFromAngle: (angle: number) => { x: number; y: number };\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: StoreState) => T): T {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface SliderContextValue {\r\n  dir: Direction;\r\n  name?: string;\r\n  form?: string;\r\n}\r\n\r\nconst SliderContext = React.createContext<SliderContextValue | null>(null);\r\n\r\nfunction useSliderContext(consumerName: string) {\r\n  const context = React.useContext(SliderContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface AngleSliderProps extends Omit<DivProps, \"defaultValue\"> {\r\n  value?: number[];\r\n  defaultValue?: number[];\r\n  onValueChange?: (value: number[]) => void;\r\n  onValueCommit?: (value: number[]) => void;\r\n  min?: number;\r\n  max?: number;\r\n  step?: number;\r\n  minStepsBetweenThumbs?: number;\r\n  size?: number;\r\n  thickness?: number;\r\n  startAngle?: number;\r\n  endAngle?: number;\r\n  dir?: Direction;\r\n  form?: string;\r\n  name?: string;\r\n  disabled?: boolean;\r\n  inverted?: boolean;\r\n}\r\n\r\nfunction AngleSlider(props: AngleSliderProps) {\r\n  const {\r\n    value,\r\n    defaultValue = [0],\r\n    onValueChange,\r\n    onValueCommit,\r\n    min = 0,\r\n    max = 100,\r\n    step = 1,\r\n    minStepsBetweenThumbs = 0,\r\n    size = 60,\r\n    thickness = 8,\r\n    startAngle = -90,\r\n    endAngle = 270,\r\n    dir: dirProp,\r\n    form,\r\n    name,\r\n    disabled = false,\r\n    inverted = false,\r\n    asChild,\r\n    className,\r\n    ref,\r\n    onPointerMove: onPointerMoveProp,\r\n    onPointerUp: onPointerUpProp,\r\n    onPointerDown: onPointerDownProp,\r\n    onKeyDown: onKeyDownProp,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    values: value ?? defaultValue,\r\n    thumbs: new Map(),\r\n    valueIndexToChange: 0,\r\n    min,\r\n    max,\r\n    step,\r\n    minStepsBetweenThumbs,\r\n    disabled,\r\n    inverted,\r\n    size,\r\n    thickness,\r\n    startAngle,\r\n    endAngle,\r\n  }));\r\n\r\n  const propsRef = useAsRef({\r\n    onValueChange,\r\n    onValueCommit,\r\n    onPointerMove: onPointerMoveProp,\r\n    onPointerUp: onPointerUpProp,\r\n    onPointerDown: onPointerDownProp,\r\n    onKeyDown: onKeyDownProp,\r\n  });\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n\r\n        if (key === \"values\" && Array.isArray(value)) {\r\n          const hasChanged = String(stateRef.current.values) !== String(value);\r\n          stateRef.current.values = value;\r\n          if (hasChanged) {\r\n            propsRef.current.onValueChange?.(value);\r\n          }\r\n        } else {\r\n          stateRef.current[key] = value;\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      addThumb: (index, thumbData) => {\r\n        stateRef.current.thumbs.set(index, thumbData);\r\n        store.notify();\r\n      },\r\n      removeThumb: (index) => {\r\n        stateRef.current.thumbs.delete(index);\r\n        store.notify();\r\n      },\r\n      updateValue: (value, atIndex, { commit = false } = {}) => {\r\n        const { min, max, step, minStepsBetweenThumbs } = stateRef.current;\r\n        const decimalCount = getDecimalCount(step);\r\n        const snapToStep = roundValue(\r\n          Math.round((value - min) / step) * step + min,\r\n          decimalCount,\r\n        );\r\n        const nextValue = clamp(snapToStep, [min, max]);\r\n\r\n        const nextValues = getNextSortedValues(\r\n          stateRef.current.values,\r\n          nextValue,\r\n          atIndex,\r\n        );\r\n\r\n        if (\r\n          hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)\r\n        ) {\r\n          stateRef.current.valueIndexToChange = nextValues.indexOf(nextValue);\r\n          const hasChanged =\r\n            String(nextValues) !== String(stateRef.current.values);\r\n\r\n          if (hasChanged) {\r\n            stateRef.current.values = nextValues;\r\n            propsRef.current.onValueChange?.(nextValues);\r\n            if (commit) propsRef.current.onValueCommit?.(nextValues);\r\n            store.notify();\r\n          }\r\n        }\r\n      },\r\n      getValueFromPointer: (clientX, clientY, rect) => {\r\n        const { min, max, inverted, startAngle, endAngle } = stateRef.current;\r\n        const centerX = rect.left + rect.width / 2;\r\n        const centerY = rect.top + rect.height / 2;\r\n\r\n        const deltaX = clientX - centerX;\r\n        const deltaY = clientY - centerY;\r\n        let angle = (Math.atan2(deltaY, deltaX) * 180) / Math.PI;\r\n\r\n        if (angle < 0) angle += 360;\r\n\r\n        angle = (angle - startAngle + 360) % 360;\r\n\r\n        const totalAngle = (endAngle - startAngle + 360) % 360 || 360;\r\n\r\n        let percent = angle / totalAngle;\r\n        if (inverted) percent = 1 - percent;\r\n\r\n        return min + percent * (max - min);\r\n      },\r\n      getAngleFromValue: (value) => {\r\n        const { min, max, inverted, startAngle, endAngle } = stateRef.current;\r\n        let percent = (value - min) / (max - min);\r\n        if (inverted) percent = 1 - percent;\r\n\r\n        const totalAngle = (endAngle - startAngle + 360) % 360 || 360;\r\n        const angle = startAngle + percent * totalAngle;\r\n\r\n        return angle;\r\n      },\r\n      getPositionFromAngle: (angle) => {\r\n        const { size } = stateRef.current;\r\n        const radians = (angle * Math.PI) / 180;\r\n\r\n        return {\r\n          x: size * Math.cos(radians),\r\n          y: size * Math.sin(radians),\r\n        };\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (value !== undefined) {\r\n      store.setState(\"values\", value);\r\n    }\r\n  }, [value, store]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const currentState = store.getState();\r\n\r\n    if (currentState.min !== min) {\r\n      store.setState(\"min\", min);\r\n    }\r\n    if (currentState.max !== max) {\r\n      store.setState(\"max\", max);\r\n    }\r\n    if (currentState.step !== step) {\r\n      store.setState(\"step\", step);\r\n    }\r\n    if (currentState.minStepsBetweenThumbs !== minStepsBetweenThumbs) {\r\n      store.setState(\"minStepsBetweenThumbs\", minStepsBetweenThumbs);\r\n    }\r\n    if (currentState.size !== size) {\r\n      store.setState(\"size\", size);\r\n    }\r\n    if (currentState.thickness !== thickness) {\r\n      store.setState(\"thickness\", thickness);\r\n    }\r\n    if (currentState.startAngle !== startAngle) {\r\n      store.setState(\"startAngle\", startAngle);\r\n    }\r\n    if (currentState.endAngle !== endAngle) {\r\n      store.setState(\"endAngle\", endAngle);\r\n    }\r\n    if (currentState.disabled !== disabled) {\r\n      store.setState(\"disabled\", disabled);\r\n    }\r\n    if (currentState.inverted !== inverted) {\r\n      store.setState(\"inverted\", inverted);\r\n    }\r\n  }, [\r\n    store,\r\n    min,\r\n    max,\r\n    step,\r\n    minStepsBetweenThumbs,\r\n    size,\r\n    thickness,\r\n    startAngle,\r\n    endAngle,\r\n    disabled,\r\n    inverted,\r\n  ]);\r\n\r\n  const dir = DirectionPrimitive.useDirection(dirProp);\r\n\r\n  const [sliderElement, setSliderElement] = React.useState<RootElement | null>(\r\n    null,\r\n  );\r\n  const composedRef = useComposedRefs(ref, setSliderElement);\r\n  const valuesBeforeSlideStartRef = React.useRef(value ?? defaultValue);\r\n\r\n  const contextValue = React.useMemo<SliderContextValue>(\r\n    () => ({\r\n      dir,\r\n      name,\r\n      form,\r\n    }),\r\n    [dir, name, form],\r\n  );\r\n\r\n  const onSliderStart = React.useCallback(\r\n    (pointerValue: number) => {\r\n      if (disabled) return;\r\n\r\n      const values = store.getState().values;\r\n      const closestIndex = getClosestValueIndex(values, pointerValue);\r\n      store.setState(\"valueIndexToChange\", closestIndex);\r\n      store.updateValue(pointerValue, closestIndex);\r\n    },\r\n    [store, disabled],\r\n  );\r\n\r\n  const onSliderMove = React.useCallback(\r\n    (pointerValue: number) => {\r\n      if (disabled) return;\r\n\r\n      const valueIndexToChange = store.getState().valueIndexToChange;\r\n      store.updateValue(pointerValue, valueIndexToChange);\r\n    },\r\n    [store, disabled],\r\n  );\r\n\r\n  const onSliderEnd = React.useCallback(() => {\r\n    if (disabled) return;\r\n\r\n    const state = store.getState();\r\n    const prevValue =\r\n      valuesBeforeSlideStartRef.current[state.valueIndexToChange];\r\n    const nextValue = state.values[state.valueIndexToChange];\r\n    const hasChanged = nextValue !== prevValue;\r\n\r\n    if (hasChanged) {\r\n      onValueCommit?.(state.values);\r\n    }\r\n  }, [store, disabled, onValueCommit]);\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<RootElement>) => {\r\n      propsRef.current.onKeyDown?.(event);\r\n      if (event.defaultPrevented || disabled) return;\r\n\r\n      const state = store.getState();\r\n      const { values, valueIndexToChange, min, max, step } = state;\r\n      const currentValue = values[valueIndexToChange] ?? min;\r\n\r\n      if (event.key === \"Home\") {\r\n        event.preventDefault();\r\n        store.updateValue(min, 0, { commit: true });\r\n      } else if (event.key === \"End\") {\r\n        event.preventDefault();\r\n        store.updateValue(max, values.length - 1, { commit: true });\r\n      } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\r\n        event.preventDefault();\r\n\r\n        const isPageKey = PAGE_KEYS.includes(event.key);\r\n        const isSkipKey =\r\n          isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));\r\n        const multiplier = isSkipKey ? 10 : 1;\r\n\r\n        let direction = 0;\r\n        const isDecreaseKey = [\"ArrowLeft\", \"ArrowUp\", \"PageUp\"].includes(\r\n          event.key,\r\n        );\r\n        direction = isDecreaseKey ? -1 : 1;\r\n        if (inverted) direction *= -1;\r\n\r\n        const stepInDirection = step * multiplier * direction;\r\n        store.updateValue(currentValue + stepInDirection, valueIndexToChange, {\r\n          commit: true,\r\n        });\r\n      }\r\n    },\r\n    [store, propsRef, disabled, inverted],\r\n  );\r\n\r\n  const onPointerDown = React.useCallback(\r\n    (event: React.PointerEvent<RootElement>) => {\r\n      propsRef.current.onPointerDown?.(event);\r\n      if (event.defaultPrevented || disabled) return;\r\n\r\n      const target = event.target as HTMLElement;\r\n      target.setPointerCapture(event.pointerId);\r\n      event.preventDefault();\r\n\r\n      if (!disabled) {\r\n        valuesBeforeSlideStartRef.current = store.getState().values;\r\n\r\n        const thumbs = Array.from(store.getState().thumbs.values());\r\n        const clickedThumb = thumbs.find((thumb) =>\r\n          thumb.element.contains(target),\r\n        );\r\n\r\n        if (clickedThumb) {\r\n          clickedThumb.element.focus();\r\n          store.setState(\"valueIndexToChange\", clickedThumb.index);\r\n        } else if (sliderElement) {\r\n          const rect = sliderElement.getBoundingClientRect();\r\n          const pointerValue = store.getValueFromPointer(\r\n            event.clientX,\r\n            event.clientY,\r\n            rect,\r\n          );\r\n          onSliderStart(pointerValue);\r\n        }\r\n      }\r\n    },\r\n    [store, propsRef, disabled, sliderElement, onSliderStart],\r\n  );\r\n\r\n  const onPointerMove = React.useCallback(\r\n    (event: React.PointerEvent<RootElement>) => {\r\n      propsRef.current.onPointerMove?.(event);\r\n      if (event.defaultPrevented || disabled) return;\r\n\r\n      const target = event.target as HTMLElement;\r\n      if (target.hasPointerCapture(event.pointerId) && sliderElement) {\r\n        const rect = sliderElement.getBoundingClientRect();\r\n        const pointerValue = store.getValueFromPointer(\r\n          event.clientX,\r\n          event.clientY,\r\n          rect,\r\n        );\r\n        onSliderMove(pointerValue);\r\n      }\r\n    },\r\n    [store, propsRef, disabled, sliderElement, onSliderMove],\r\n  );\r\n\r\n  const onPointerUp = React.useCallback(\r\n    (event: React.PointerEvent<RootElement>) => {\r\n      propsRef.current.onPointerUp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const target = event.target as RootElement;\r\n      if (target.hasPointerCapture(event.pointerId)) {\r\n        target.releasePointerCapture(event.pointerId);\r\n        onSliderEnd();\r\n      }\r\n    },\r\n    [propsRef, onSliderEnd],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <SliderContext.Provider value={contextValue}>\r\n        <RootPrimitive\r\n          data-disabled={disabled ? \"\" : undefined}\r\n          data-slot=\"angle-slider\"\r\n          dir={dir}\r\n          {...rootProps}\r\n          ref={composedRef}\r\n          className={cn(\r\n            \"relative touch-none select-none\",\r\n            disabled && \"opacity-50\",\r\n            className,\r\n          )}\r\n          style={{\r\n            width: `${size * 2 + 40}px`,\r\n            height: `${size * 2 + 40}px`,\r\n          }}\r\n          onKeyDown={onKeyDown}\r\n          onPointerDown={onPointerDown}\r\n          onPointerMove={onPointerMove}\r\n          onPointerUp={onPointerUp}\r\n        />\r\n      </SliderContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\nfunction AngleSliderTrack(props: React.ComponentProps<\"svg\">) {\r\n  const { className, children, ...trackProps } = props;\r\n\r\n  const disabled = useStore((state) => state.disabled);\r\n  const size = useStore((state) => state.size);\r\n  const thickness = useStore((state) => state.thickness);\r\n  const startAngle = useStore((state) => state.startAngle);\r\n  const endAngle = useStore((state) => state.endAngle);\r\n\r\n  const center = size + 20;\r\n  const trackRadius = size;\r\n\r\n  const totalAngle = (endAngle - startAngle + 360) % 360 || 360;\r\n  const isFullCircle = totalAngle >= 359;\r\n\r\n  const startRadians = (startAngle * Math.PI) / 180;\r\n  const endRadians = (endAngle * Math.PI) / 180;\r\n\r\n  const startX = center + trackRadius * Math.cos(startRadians);\r\n  const startY = center + trackRadius * Math.sin(startRadians);\r\n  const endX = center + trackRadius * Math.cos(endRadians);\r\n  const endY = center + trackRadius * Math.sin(endRadians);\r\n\r\n  const largeArcFlag = totalAngle > 180 ? 1 : 0;\r\n\r\n  return (\r\n    <svg\r\n      aria-hidden=\"true\"\r\n      focusable=\"false\"\r\n      data-disabled={disabled ? \"\" : undefined}\r\n      data-slot=\"angle-slider-track\"\r\n      width={center * 2}\r\n      height={center * 2}\r\n      {...trackProps}\r\n      className={cn(\"absolute inset-0\", className)}\r\n    >\r\n      {isFullCircle ? (\r\n        <circle\r\n          data-slot=\"angle-slider-track-rail\"\r\n          cx={center}\r\n          cy={center}\r\n          r={trackRadius}\r\n          fill=\"none\"\r\n          stroke=\"currentColor\"\r\n          strokeWidth={thickness}\r\n          strokeLinecap=\"round\"\r\n          vectorEffect=\"non-scaling-stroke\"\r\n          className=\"stroke-muted\"\r\n        />\r\n      ) : (\r\n        <path\r\n          data-slot=\"angle-slider-track-rail\"\r\n          d={`M ${startX} ${startY} A ${trackRadius} ${trackRadius} 0 ${largeArcFlag} 1 ${endX} ${endY}`}\r\n          fill=\"none\"\r\n          stroke=\"currentColor\"\r\n          strokeWidth={thickness}\r\n          strokeLinecap=\"round\"\r\n          vectorEffect=\"non-scaling-stroke\"\r\n          className=\"stroke-muted\"\r\n        />\r\n      )}\r\n      {children}\r\n    </svg>\r\n  );\r\n}\r\n\r\nfunction AngleSliderRange(props: React.ComponentProps<\"path\">) {\r\n  const { className, ...rangeProps } = props;\r\n\r\n  const values = useStore((state) => state.values);\r\n  const min = useStore((state) => state.min);\r\n  const max = useStore((state) => state.max);\r\n  const disabled = useStore((state) => state.disabled);\r\n  const size = useStore((state) => state.size);\r\n  const thickness = useStore((state) => state.thickness);\r\n  const startAngle = useStore((state) => state.startAngle);\r\n  const endAngle = useStore((state) => state.endAngle);\r\n\r\n  const center = size + 20;\r\n  const trackRadius = size;\r\n\r\n  const sortedValues = [...values].sort((a, b) => a - b);\r\n\r\n  const rangeStart = values.length <= 1 ? min : (sortedValues[0] ?? min);\r\n  const rangeEnd =\r\n    values.length <= 1\r\n      ? (sortedValues[0] ?? min)\r\n      : (sortedValues[sortedValues.length - 1] ?? max);\r\n\r\n  const rangeStartPercent = (rangeStart - min) / (max - min);\r\n  const rangeEndPercent = (rangeEnd - min) / (max - min);\r\n\r\n  const totalAngle = (endAngle - startAngle + 360) % 360 || 360;\r\n  const rangeStartAngle = startAngle + rangeStartPercent * totalAngle;\r\n  const rangeEndAngle = startAngle + rangeEndPercent * totalAngle;\r\n\r\n  const rangeStartRadians = (rangeStartAngle * Math.PI) / 180;\r\n  const rangeEndRadians = (rangeEndAngle * Math.PI) / 180;\r\n\r\n  const startX = center + trackRadius * Math.cos(rangeStartRadians);\r\n  const startY = center + trackRadius * Math.sin(rangeStartRadians);\r\n  const endX = center + trackRadius * Math.cos(rangeEndRadians);\r\n  const endY = center + trackRadius * Math.sin(rangeEndRadians);\r\n\r\n  const rangeAngle = (rangeEndAngle - rangeStartAngle + 360) % 360;\r\n  const largeArcFlag = rangeAngle > 180 ? 1 : 0;\r\n\r\n  if (rangeStart === rangeEnd) return null;\r\n\r\n  return (\r\n    <path\r\n      data-disabled={disabled ? \"\" : undefined}\r\n      data-slot=\"angle-slider-range\"\r\n      d={`M ${startX} ${startY} A ${trackRadius} ${trackRadius} 0 ${largeArcFlag} 1 ${endX} ${endY}`}\r\n      fill=\"none\"\r\n      stroke=\"currentColor\"\r\n      strokeWidth={thickness}\r\n      strokeLinecap=\"round\"\r\n      vectorEffect=\"non-scaling-stroke\"\r\n      {...rangeProps}\r\n      className={cn(\"stroke-primary\", className)}\r\n    />\r\n  );\r\n}\r\n\r\ninterface AngleSliderThumbProps extends DivProps {\r\n  index?: number;\r\n}\r\n\r\nfunction AngleSliderThumb(props: AngleSliderThumbProps) {\r\n  const { index: indexProp, className, asChild, ref, ...thumbProps } = props;\r\n\r\n  const context = useSliderContext(THUMB_NAME);\r\n  const store = useStoreContext(THUMB_NAME);\r\n  const values = useStore((state) => state.values);\r\n  const min = useStore((state) => state.min);\r\n  const max = useStore((state) => state.max);\r\n  const step = useStore((state) => state.step);\r\n  const disabled = useStore((state) => state.disabled);\r\n  const size = useStore((state) => state.size);\r\n\r\n  const thumbId = React.useId();\r\n  const [thumbElement, setThumbElement] = React.useState<ThumbElement | null>(\r\n    null,\r\n  );\r\n  const composedRef = useComposedRefs(ref, setThumbElement);\r\n\r\n  const isFormControl = thumbElement\r\n    ? context.form || !!thumbElement.closest(\"form\")\r\n    : true;\r\n\r\n  const index = indexProp ?? 0;\r\n  const value = values[index];\r\n\r\n  React.useEffect(() => {\r\n    if (thumbElement && value !== undefined) {\r\n      store.addThumb(index, {\r\n        id: thumbId,\r\n        element: thumbElement,\r\n        index,\r\n        value,\r\n      });\r\n\r\n      return () => {\r\n        store.removeThumb(index);\r\n      };\r\n    }\r\n  }, [thumbElement, thumbId, index, value, store]);\r\n\r\n  const thumbStyle = React.useMemo<React.CSSProperties>(() => {\r\n    if (value === undefined) return {};\r\n\r\n    const angle = store.getAngleFromValue(value);\r\n    const position = store.getPositionFromAngle(angle);\r\n    const center = size + 20;\r\n\r\n    return {\r\n      position: \"absolute\",\r\n      left: `${center + position.x}px`,\r\n      top: `${center + position.y}px`,\r\n      transform: \"translate(-50%, -50%)\",\r\n    };\r\n  }, [value, store, size]);\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<ThumbElement>) => {\r\n      props.onFocus?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      store.setState(\"valueIndexToChange\", index);\r\n    },\r\n    [props.onFocus, store, index],\r\n  );\r\n\r\n  const ThumbPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  if (value === undefined) return null;\r\n\r\n  return (\r\n    <span style={thumbStyle}>\r\n      <ThumbPrimitive\r\n        id={thumbId}\r\n        role=\"slider\"\r\n        aria-valuemin={min}\r\n        aria-valuenow={value}\r\n        aria-valuemax={max}\r\n        aria-orientation=\"vertical\"\r\n        data-disabled={disabled ? \"\" : undefined}\r\n        data-slot=\"angle-slider-thumb\"\r\n        tabIndex={disabled ? undefined : 0}\r\n        {...thumbProps}\r\n        ref={composedRef}\r\n        className={cn(\r\n          \"block size-4 shrink-0 rounded-full border border-primary bg-background shadow-sm ring-ring/50 transition-[color,box-shadow] hover:ring-4 focus-visible:outline-hidden focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50\",\r\n          className,\r\n        )}\r\n        onFocus={onFocus}\r\n      />\r\n      {isFormControl && value !== undefined && (\r\n        <VisuallyHiddenInput\r\n          key={index}\r\n          control={thumbElement}\r\n          name={\r\n            context.name\r\n              ? context.name + (values.length > 1 ? \"[]\" : \"\")\r\n              : undefined\r\n          }\r\n          form={context.form}\r\n          value={value.toString()}\r\n          type=\"number\"\r\n          min={min}\r\n          max={max}\r\n          step={step}\r\n          disabled={disabled}\r\n        />\r\n      )}\r\n    </span>\r\n  );\r\n}\r\n\r\ninterface AngleSliderValueProps extends DivProps {\r\n  unit?: string;\r\n  formatValue?: (value: number | number[]) => string;\r\n}\r\n\r\nfunction AngleSliderValue(props: AngleSliderValueProps) {\r\n  const {\r\n    unit = \"Â°\",\r\n    formatValue,\r\n    className,\r\n    style,\r\n    asChild,\r\n    children,\r\n    ...valueProps\r\n  } = props;\r\n\r\n  const values = useStore((state) => state.values);\r\n  const size = useStore((state) => state.size);\r\n  const disabled = useStore((state) => state.disabled);\r\n\r\n  const center = size + 20;\r\n\r\n  const displayValue = React.useMemo(() => {\r\n    if (formatValue) {\r\n      return formatValue(values.length === 1 ? (values[0] ?? 0) : values);\r\n    }\r\n\r\n    if (values.length === 1) {\r\n      return `${values[0] ?? 0}${unit}`;\r\n    }\r\n\r\n    const sortedValues = [...values].sort((a, b) => a - b);\r\n    return `${sortedValues[0]}${unit} - ${sortedValues[sortedValues.length - 1]}${unit}`;\r\n  }, [values, formatValue, unit]);\r\n\r\n  const valueStyle = React.useMemo<React.CSSProperties>(\r\n    () => ({\r\n      position: \"absolute\",\r\n      left: `${center}px`,\r\n      top: `${center}px`,\r\n      transform: \"translate(-50%, -50%)\",\r\n    }),\r\n    [center],\r\n  );\r\n\r\n  const ValuePrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <ValuePrimitive\r\n      data-disabled={disabled ? \"\" : undefined}\r\n      data-slot=\"angle-slider-value\"\r\n      {...valueProps}\r\n      className={cn(\r\n        \"pointer-events-none flex select-none items-center justify-center font-medium text-foreground text-sm\",\r\n        className,\r\n      )}\r\n      style={{\r\n        ...valueStyle,\r\n        ...style,\r\n      }}\r\n    >\r\n      {children ?? displayValue}\r\n    </ValuePrimitive>\r\n  );\r\n}\r\n\r\nexport {\r\n  AngleSlider,\r\n  AngleSliderTrack,\r\n  AngleSliderRange,\r\n  AngleSliderThumb,\r\n  AngleSliderValue,\r\n  //\r\n  useStore as useAngleSlider,\r\n  //\r\n  type AngleSliderProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\n\r\ntype InputValue = string[] | string;\r\n\r\ninterface VisuallyHiddenInputProps<T = InputValue>\r\n  extends Omit<\r\n    React.InputHTMLAttributes<HTMLInputElement>,\r\n    \"value\" | \"checked\" | \"onReset\"\r\n  > {\r\n  value?: T;\r\n  checked?: boolean;\r\n  control: HTMLElement | null;\r\n  bubbles?: boolean;\r\n}\r\n\r\nfunction VisuallyHiddenInput<T = InputValue>(\r\n  props: VisuallyHiddenInputProps<T>,\r\n) {\r\n  const {\r\n    control,\r\n    value,\r\n    checked,\r\n    bubbles = true,\r\n    type = \"hidden\",\r\n    style,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const isCheckInput = React.useMemo(\r\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\r\n    [type],\r\n  );\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  const prevValueRef = React.useRef<{\r\n    value: T | boolean | undefined;\r\n    previous: T | boolean | undefined;\r\n  }>({\r\n    value: isCheckInput ? checked : value,\r\n    previous: isCheckInput ? checked : value,\r\n  });\r\n\r\n  const prevValue = React.useMemo(() => {\r\n    const currentValue = isCheckInput ? checked : value;\r\n    if (prevValueRef.current.value !== currentValue) {\r\n      prevValueRef.current.previous = prevValueRef.current.value;\r\n      prevValueRef.current.value = currentValue;\r\n    }\r\n    return prevValueRef.current.previous;\r\n  }, [isCheckInput, value, checked]);\r\n\r\n  const [controlSize, setControlSize] = React.useState<{\r\n    width?: number;\r\n    height?: number;\r\n  }>({});\r\n\r\n  React.useLayoutEffect(() => {\r\n    if (!control) {\r\n      setControlSize({});\r\n      return;\r\n    }\r\n\r\n    setControlSize({\r\n      width: control.offsetWidth,\r\n      height: control.offsetHeight,\r\n    });\r\n\r\n    if (typeof window === \"undefined\") return;\r\n\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      if (!Array.isArray(entries) || !entries.length) return;\r\n\r\n      const entry = entries[0];\r\n      if (!entry) return;\r\n\r\n      let width: number;\r\n      let height: number;\r\n\r\n      if (\"borderBoxSize\" in entry) {\r\n        const borderSizeEntry = entry.borderBoxSize;\r\n        const borderSize = Array.isArray(borderSizeEntry)\r\n          ? borderSizeEntry[0]\r\n          : borderSizeEntry;\r\n        width = borderSize.inlineSize;\r\n        height = borderSize.blockSize;\r\n      } else {\r\n        width = control.offsetWidth;\r\n        height = control.offsetHeight;\r\n      }\r\n\r\n      setControlSize({ width, height });\r\n    });\r\n\r\n    resizeObserver.observe(control, { box: \"border-box\" });\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [control]);\r\n\r\n  React.useEffect(() => {\r\n    const input = inputRef.current;\r\n    if (!input) return;\r\n\r\n    const inputProto = window.HTMLInputElement.prototype;\r\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\r\n    const eventType = isCheckInput ? \"click\" : \"input\";\r\n    const currentValue = isCheckInput ? checked : value;\r\n\r\n    const serializedCurrentValue = isCheckInput\r\n      ? checked\r\n      : typeof value === \"object\" && value !== null\r\n        ? JSON.stringify(value)\r\n        : value;\r\n\r\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\r\n\r\n    const setter = descriptor?.set;\r\n\r\n    if (prevValue !== currentValue && setter) {\r\n      const event = new Event(eventType, { bubbles });\r\n      setter.call(input, serializedCurrentValue);\r\n      input.dispatchEvent(event);\r\n    }\r\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\r\n\r\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\r\n    return {\r\n      ...style,\r\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\r\n        ? controlSize\r\n        : {}),\r\n      border: 0,\r\n      clip: \"rect(0 0 0 0)\",\r\n      clipPath: \"inset(50%)\",\r\n      height: \"1px\",\r\n      margin: \"-1px\",\r\n      overflow: \"hidden\",\r\n      padding: 0,\r\n      position: \"absolute\",\r\n      whiteSpace: \"nowrap\",\r\n      width: \"1px\",\r\n    };\r\n  }, [style, controlSize]);\r\n\r\n  return (\r\n    <input\r\n      type={type}\r\n      {...inputProps}\r\n      ref={inputRef}\r\n      aria-hidden={isCheckInput}\r\n      tabIndex={-1}\r\n      defaultChecked={isCheckInput ? checked : undefined}\r\n      style={composedStyle}\r\n    />\r\n  );\r\n}\r\n\r\nexport { VisuallyHiddenInput };\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}