{
  "name": "scroller",
  "dependencies": [
    "radix-ui"
  ],
  "files": [
    {
      "path": "ui/scroller.tsx",
      "content": "\"use client\";\r\n\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\nimport {\r\n  ChevronDown,\r\n  ChevronLeft,\r\n  ChevronRight,\r\n  ChevronUp,\r\n} from \"lucide-react\";\r\nimport { Slot as SlotPrimitive } from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst DATA_TOP_SCROLL = \"data-top-scroll\";\r\nconst DATA_BOTTOM_SCROLL = \"data-bottom-scroll\";\r\nconst DATA_LEFT_SCROLL = \"data-left-scroll\";\r\nconst DATA_RIGHT_SCROLL = \"data-right-scroll\";\r\nconst DATA_TOP_BOTTOM_SCROLL = \"data-top-bottom-scroll\";\r\nconst DATA_LEFT_RIGHT_SCROLL = \"data-left-right-scroll\";\r\n\r\nconst scrollerVariants = cva(\"\", {\r\n  variants: {\r\n    orientation: {\r\n      vertical: [\r\n        \"overflow-y-auto\",\r\n        \"data-[top-scroll=true]:[mask-image:linear-gradient(0deg,#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\r\n        \"data-[bottom-scroll=true]:[mask-image:linear-gradient(180deg,#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\r\n        \"data-[top-bottom-scroll=true]:[mask-image:linear-gradient(#000,#000,transparent_0,#000_var(--scroll-shadow-size),#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\r\n      ],\r\n      horizontal: [\r\n        \"overflow-x-auto\",\r\n        \"data-[left-scroll=true]:[mask-image:linear-gradient(270deg,#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\r\n        \"data-[right-scroll=true]:[mask-image:linear-gradient(90deg,#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\r\n        \"data-[left-right-scroll=true]:[mask-image:linear-gradient(to_right,#000,#000,transparent_0,#000_var(--scroll-shadow-size),#000_calc(100%_-_var(--scroll-shadow-size)),transparent)]\",\r\n      ],\r\n    },\r\n    hideScrollbar: {\r\n      true: \"[-ms-overflow-style:none] [scrollbar-width:none] [&::-webkit-scrollbar]:hidden\",\r\n      false: \"\",\r\n    },\r\n  },\r\n  defaultVariants: {\r\n    orientation: \"vertical\",\r\n    hideScrollbar: false,\r\n  },\r\n});\r\n\r\ntype ScrollDirection = \"up\" | \"down\" | \"left\" | \"right\";\r\n\r\ntype ScrollVisibility = {\r\n  [key in ScrollDirection]: boolean;\r\n};\r\n\r\ninterface ScrollerProps\r\n  extends VariantProps<typeof scrollerVariants>,\r\n    React.ComponentProps<\"div\"> {\r\n  size?: number;\r\n  offset?: number;\r\n  asChild?: boolean;\r\n  withNavigation?: boolean;\r\n  scrollStep?: number;\r\n  scrollTriggerMode?: \"press\" | \"hover\" | \"click\";\r\n}\r\n\r\nfunction Scroller(props: ScrollerProps) {\r\n  const {\r\n    orientation = \"vertical\",\r\n    hideScrollbar,\r\n    className,\r\n    size = 40,\r\n    offset = 0,\r\n    scrollStep = 40,\r\n    style,\r\n    asChild,\r\n    withNavigation = false,\r\n    scrollTriggerMode = \"press\",\r\n    ref,\r\n    ...scrollerProps\r\n  } = props;\r\n\r\n  const containerRef = React.useRef<HTMLDivElement | null>(null);\r\n  const composedRef = useComposedRefs(ref, containerRef);\r\n  const [scrollVisibility, setScrollVisibility] =\r\n    React.useState<ScrollVisibility>({\r\n      up: false,\r\n      down: false,\r\n      left: false,\r\n      right: false,\r\n    });\r\n\r\n  const onScrollBy = React.useCallback(\r\n    (direction: ScrollDirection) => {\r\n      const container = containerRef.current;\r\n      if (!container) return;\r\n\r\n      const scrollMap: Record<ScrollDirection, () => void> = {\r\n        up: () => (container.scrollTop -= scrollStep),\r\n        down: () => (container.scrollTop += scrollStep),\r\n        left: () => (container.scrollLeft -= scrollStep),\r\n        right: () => (container.scrollLeft += scrollStep),\r\n      };\r\n\r\n      scrollMap[direction]();\r\n    },\r\n    [scrollStep],\r\n  );\r\n\r\n  const scrollHandlers = React.useMemo(\r\n    () => ({\r\n      up: () => onScrollBy(\"up\"),\r\n      down: () => onScrollBy(\"down\"),\r\n      left: () => onScrollBy(\"left\"),\r\n      right: () => onScrollBy(\"right\"),\r\n    }),\r\n    [onScrollBy],\r\n  );\r\n\r\n  React.useLayoutEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    function onScroll() {\r\n      if (!container) return;\r\n\r\n      const isVertical = orientation === \"vertical\";\r\n\r\n      if (isVertical) {\r\n        const scrollTop = container.scrollTop;\r\n        const clientHeight = container.clientHeight;\r\n        const scrollHeight = container.scrollHeight;\r\n\r\n        if (withNavigation) {\r\n          setScrollVisibility((prev) => {\r\n            const newUp = scrollTop > offset;\r\n            const newDown = scrollTop + clientHeight < scrollHeight;\r\n\r\n            if (prev.up !== newUp || prev.down !== newDown) {\r\n              return {\r\n                ...prev,\r\n                up: newUp,\r\n                down: newDown,\r\n              };\r\n            }\r\n            return prev;\r\n          });\r\n        }\r\n\r\n        const hasTopScroll = scrollTop > offset;\r\n        const hasBottomScroll =\r\n          scrollTop + clientHeight + offset < scrollHeight;\r\n        const isVerticallyScrollable = scrollHeight > clientHeight;\r\n\r\n        if (hasTopScroll && hasBottomScroll && isVerticallyScrollable) {\r\n          container.setAttribute(DATA_TOP_BOTTOM_SCROLL, \"true\");\r\n          container.removeAttribute(DATA_TOP_SCROLL);\r\n          container.removeAttribute(DATA_BOTTOM_SCROLL);\r\n        } else {\r\n          container.removeAttribute(DATA_TOP_BOTTOM_SCROLL);\r\n          if (hasTopScroll) container.setAttribute(DATA_TOP_SCROLL, \"true\");\r\n          else container.removeAttribute(DATA_TOP_SCROLL);\r\n          if (hasBottomScroll && isVerticallyScrollable)\r\n            container.setAttribute(DATA_BOTTOM_SCROLL, \"true\");\r\n          else container.removeAttribute(DATA_BOTTOM_SCROLL);\r\n        }\r\n      }\r\n\r\n      const scrollLeft = container.scrollLeft;\r\n      const clientWidth = container.clientWidth;\r\n      const scrollWidth = container.scrollWidth;\r\n\r\n      if (withNavigation) {\r\n        setScrollVisibility((prev) => {\r\n          const newLeft = scrollLeft > offset;\r\n          const newRight = scrollLeft + clientWidth < scrollWidth;\r\n\r\n          if (prev.left !== newLeft || prev.right !== newRight) {\r\n            return {\r\n              ...prev,\r\n              left: newLeft,\r\n              right: newRight,\r\n            };\r\n          }\r\n          return prev;\r\n        });\r\n      }\r\n\r\n      const hasLeftScroll = scrollLeft > offset;\r\n      const hasRightScroll = scrollLeft + clientWidth + offset < scrollWidth;\r\n      const isHorizontallyScrollable = scrollWidth > clientWidth;\r\n\r\n      if (hasLeftScroll && hasRightScroll && isHorizontallyScrollable) {\r\n        container.setAttribute(DATA_LEFT_RIGHT_SCROLL, \"true\");\r\n        container.removeAttribute(DATA_LEFT_SCROLL);\r\n        container.removeAttribute(DATA_RIGHT_SCROLL);\r\n      } else {\r\n        container.removeAttribute(DATA_LEFT_RIGHT_SCROLL);\r\n        if (hasLeftScroll) container.setAttribute(DATA_LEFT_SCROLL, \"true\");\r\n        else container.removeAttribute(DATA_LEFT_SCROLL);\r\n        if (hasRightScroll && isHorizontallyScrollable)\r\n          container.setAttribute(DATA_RIGHT_SCROLL, \"true\");\r\n        else container.removeAttribute(DATA_RIGHT_SCROLL);\r\n      }\r\n    }\r\n\r\n    onScroll();\r\n    container.addEventListener(\"scroll\", onScroll);\r\n    window.addEventListener(\"resize\", onScroll);\r\n\r\n    return () => {\r\n      container.removeEventListener(\"scroll\", onScroll);\r\n      window.removeEventListener(\"resize\", onScroll);\r\n    };\r\n  }, [orientation, offset, withNavigation]);\r\n\r\n  const composedStyle = React.useMemo<React.CSSProperties>(\r\n    () => ({\r\n      \"--scroll-shadow-size\": `${size}px`,\r\n      ...style,\r\n    }),\r\n    [size, style],\r\n  );\r\n\r\n  const activeDirections = React.useMemo<ScrollDirection[]>(() => {\r\n    if (!withNavigation) return [];\r\n    return orientation === \"vertical\" ? [\"up\", \"down\"] : [\"left\", \"right\"];\r\n  }, [orientation, withNavigation]);\r\n\r\n  const ScrollerPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  const ScrollerImpl = (\r\n    <ScrollerPrimitive\r\n      data-slot=\"scroller\"\r\n      {...scrollerProps}\r\n      ref={composedRef}\r\n      style={composedStyle}\r\n      className={cn(\r\n        scrollerVariants({ orientation, hideScrollbar, className }),\r\n      )}\r\n    />\r\n  );\r\n\r\n  const navigationButtons = React.useMemo(() => {\r\n    if (!withNavigation) return null;\r\n\r\n    return activeDirections\r\n      .filter((direction) => scrollVisibility[direction])\r\n      .map((direction) => (\r\n        <ScrollButton\r\n          key={direction}\r\n          data-slot=\"scroll-button\"\r\n          direction={direction}\r\n          onClick={scrollHandlers[direction]}\r\n          triggerMode={scrollTriggerMode}\r\n        />\r\n      ));\r\n  }, [\r\n    activeDirections,\r\n    scrollVisibility,\r\n    scrollHandlers,\r\n    scrollTriggerMode,\r\n    withNavigation,\r\n  ]);\r\n\r\n  if (withNavigation) {\r\n    return (\r\n      <div className=\"relative w-full\">\r\n        {navigationButtons}\r\n        {ScrollerImpl}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return ScrollerImpl;\r\n}\r\n\r\nconst scrollButtonVariants = cva(\r\n  \"absolute z-10 transition-opacity [&>svg]:size-4 [&>svg]:opacity-80 hover:[&>svg]:opacity-100\",\r\n  {\r\n    variants: {\r\n      direction: {\r\n        up: \"top-2 left-1/2 -translate-x-1/2\",\r\n        down: \"bottom-2 left-1/2 -translate-x-1/2\",\r\n        left: \"top-1/2 left-2 -translate-y-1/2\",\r\n        right: \"top-1/2 right-2 -translate-y-1/2\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      direction: \"up\",\r\n    },\r\n  },\r\n);\r\n\r\nconst directionToIcon: Record<ScrollDirection, React.ElementType> = {\r\n  up: ChevronUp,\r\n  down: ChevronDown,\r\n  left: ChevronLeft,\r\n  right: ChevronRight,\r\n} as const;\r\n\r\ninterface ScrollButtonProps extends React.ComponentProps<\"button\"> {\r\n  direction: ScrollDirection;\r\n  triggerMode?: \"press\" | \"hover\" | \"click\";\r\n}\r\n\r\nfunction ScrollButton(props: ScrollButtonProps) {\r\n  const {\r\n    direction,\r\n    className,\r\n    triggerMode = \"press\",\r\n    onClick,\r\n    ref,\r\n    ...buttonProps\r\n  } = props;\r\n\r\n  const [autoScrollTimer, setAutoScrollTimer] = React.useState<number | null>(\r\n    null,\r\n  );\r\n\r\n  const onAutoScrollStart = React.useCallback(\r\n    (event?: React.MouseEvent<HTMLButtonElement>) => {\r\n      if (autoScrollTimer !== null) return;\r\n\r\n      if (triggerMode === \"press\") {\r\n        const timer = window.setInterval(onClick ?? (() => {}), 50);\r\n        setAutoScrollTimer(timer);\r\n      } else if (triggerMode === \"hover\") {\r\n        const timer = window.setInterval(() => {\r\n          if (event) onClick?.(event);\r\n        }, 50);\r\n        setAutoScrollTimer(timer);\r\n      }\r\n    },\r\n    [autoScrollTimer, onClick, triggerMode],\r\n  );\r\n\r\n  const onAutoScrollStop = React.useCallback(() => {\r\n    if (autoScrollTimer === null) return;\r\n\r\n    window.clearInterval(autoScrollTimer);\r\n    setAutoScrollTimer(null);\r\n  }, [autoScrollTimer]);\r\n\r\n  const eventHandlers = React.useMemo(() => {\r\n    const triggerModeHandlers: Record<\r\n      NonNullable<ScrollerProps[\"scrollTriggerMode\"]>,\r\n      React.ComponentProps<\"button\">\r\n    > = {\r\n      press: {\r\n        onPointerDown: onAutoScrollStart,\r\n        onPointerUp: onAutoScrollStop,\r\n        onPointerLeave: onAutoScrollStop,\r\n        onClick: () => {},\r\n      },\r\n      hover: {\r\n        onPointerEnter: onAutoScrollStart,\r\n        onPointerLeave: onAutoScrollStop,\r\n        onClick: () => {},\r\n      },\r\n      click: {\r\n        onClick,\r\n      },\r\n    } as const;\r\n\r\n    return triggerModeHandlers[triggerMode] ?? {};\r\n  }, [triggerMode, onAutoScrollStart, onAutoScrollStop, onClick]);\r\n\r\n  React.useEffect(() => {\r\n    return () => onAutoScrollStop();\r\n  }, [onAutoScrollStop]);\r\n\r\n  const Icon = directionToIcon[direction];\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      {...buttonProps}\r\n      {...eventHandlers}\r\n      ref={ref}\r\n      className={cn(scrollButtonVariants({ direction, className }))}\r\n    >\r\n      <Icon />\r\n    </button>\r\n  );\r\n}\r\n\r\nexport { Scroller };\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}