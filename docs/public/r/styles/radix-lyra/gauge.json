{
  "name": "gauge",
  "dependencies": [
    "radix-ui"
  ],
  "files": [
    {
      "path": "ui/gauge.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot as SlotPrimitive } from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst GAUGE_NAME = \"Gauge\";\r\nconst INDICATOR_NAME = \"GaugeIndicator\";\r\nconst TRACK_NAME = \"GaugeTrack\";\r\nconst RANGE_NAME = \"GaugeRange\";\r\nconst VALUE_TEXT_NAME = \"GaugeValueText\";\r\nconst LABEL_NAME = \"GaugeLabel\";\r\n\r\nconst DEFAULT_MAX = 100;\r\nconst DEFAULT_START_ANGLE = 0;\r\nconst DEFAULT_END_ANGLE = 360;\r\n\r\ntype GaugeState = \"indeterminate\" | \"complete\" | \"loading\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ninterface PathProps extends React.ComponentProps<\"path\"> {}\r\n\r\nfunction getGaugeState(\r\n  value: number | undefined | null,\r\n  maxValue: number,\r\n): GaugeState {\r\n  return value == null\r\n    ? \"indeterminate\"\r\n    : value === maxValue\r\n      ? \"complete\"\r\n      : \"loading\";\r\n}\r\n\r\nfunction getIsValidNumber(value: unknown): value is number {\r\n  return typeof value === \"number\" && Number.isFinite(value);\r\n}\r\n\r\nfunction getIsValidMaxNumber(max: unknown): max is number {\r\n  return getIsValidNumber(max) && max > 0;\r\n}\r\n\r\nfunction getIsValidValueNumber(\r\n  value: unknown,\r\n  min: number,\r\n  max: number,\r\n): value is number {\r\n  return getIsValidNumber(value) && value <= max && value >= min;\r\n}\r\n\r\nfunction getDefaultValueText(value: number, min: number, max: number): string {\r\n  const percentage = max === min ? 100 : ((value - min) / (max - min)) * 100;\r\n  return Math.round(percentage).toString();\r\n}\r\n\r\nfunction getInvalidValueError(\r\n  propValue: string,\r\n  componentName: string,\r\n): string {\r\n  return `Invalid prop \\`value\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`. The \\`value\\` prop must be a number between \\`min\\` and \\`max\\` (inclusive), or \\`null\\`/\\`undefined\\` for indeterminate state. The value will be clamped to the valid range.`;\r\n}\r\n\r\nfunction getInvalidMaxError(propValue: string, componentName: string): string {\r\n  return `Invalid prop \\`max\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`. Only numbers greater than 0 are valid. Defaulting to ${DEFAULT_MAX}.`;\r\n}\r\n\r\nfunction getNormalizedAngle(angle: number) {\r\n  return ((angle % 360) + 360) % 360;\r\n}\r\n\r\nfunction polarToCartesian(\r\n  centerX: number,\r\n  centerY: number,\r\n  radius: number,\r\n  angleInDegrees: number,\r\n) {\r\n  const angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180.0;\r\n  return {\r\n    x: centerX + radius * Math.cos(angleInRadians),\r\n    y: centerY + radius * Math.sin(angleInRadians),\r\n  };\r\n}\r\n\r\nfunction describeArc(\r\n  x: number,\r\n  y: number,\r\n  radius: number,\r\n  startAngle: number,\r\n  endAngle: number,\r\n) {\r\n  const angleDiff = endAngle - startAngle;\r\n\r\n  // For full circles (360 degrees), draw as two semi-circles\r\n  if (Math.abs(angleDiff) >= 360) {\r\n    const start = polarToCartesian(x, y, radius, startAngle);\r\n    const mid = polarToCartesian(x, y, radius, startAngle + 180);\r\n    return [\r\n      \"M\",\r\n      start.x,\r\n      start.y,\r\n      \"A\",\r\n      radius,\r\n      radius,\r\n      0,\r\n      0,\r\n      1,\r\n      mid.x,\r\n      mid.y,\r\n      \"A\",\r\n      radius,\r\n      radius,\r\n      0,\r\n      0,\r\n      1,\r\n      start.x,\r\n      start.y,\r\n    ].join(\" \");\r\n  }\r\n\r\n  const start = polarToCartesian(x, y, radius, startAngle);\r\n  const end = polarToCartesian(x, y, radius, endAngle);\r\n  const largeArcFlag = angleDiff <= 180 ? \"0\" : \"1\";\r\n\r\n  return [\r\n    \"M\",\r\n    start.x,\r\n    start.y,\r\n    \"A\",\r\n    radius,\r\n    radius,\r\n    0,\r\n    largeArcFlag,\r\n    1,\r\n    end.x,\r\n    end.y,\r\n  ].join(\" \");\r\n}\r\n\r\ninterface GaugeContextValue {\r\n  value: number | null;\r\n  valueText: string | undefined;\r\n  max: number;\r\n  min: number;\r\n  state: GaugeState;\r\n  radius: number;\r\n  thickness: number;\r\n  size: number;\r\n  center: number;\r\n  percentage: number | null;\r\n  startAngle: number;\r\n  endAngle: number;\r\n  arcLength: number;\r\n  arcCenterY: number;\r\n  valueTextId?: string;\r\n  labelId?: string;\r\n}\r\n\r\nconst GaugeContext = React.createContext<GaugeContextValue | null>(null);\r\n\r\nfunction useGaugeContext(consumerName: string) {\r\n  const context = React.useContext(GaugeContext);\r\n  if (!context) {\r\n    throw new Error(\r\n      `\\`${consumerName}\\` must be used within \\`${GAUGE_NAME}\\``,\r\n    );\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface GaugeProps extends DivProps {\r\n  value?: number | null | undefined;\r\n  getValueText?(value: number, min: number, max: number): string;\r\n  min?: number;\r\n  max?: number;\r\n  size?: number;\r\n  thickness?: number;\r\n  startAngle?: number;\r\n  endAngle?: number;\r\n}\r\n\r\nfunction Gauge(props: GaugeProps) {\r\n  const {\r\n    value: valueProp = null,\r\n    getValueText = getDefaultValueText,\r\n    min: minProp = 0,\r\n    max: maxProp,\r\n    size = 120,\r\n    thickness = 8,\r\n    startAngle = DEFAULT_START_ANGLE,\r\n    endAngle = DEFAULT_END_ANGLE,\r\n    asChild,\r\n    className,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  if ((maxProp || maxProp === 0) && !getIsValidMaxNumber(maxProp)) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.error(getInvalidMaxError(`${maxProp}`, GAUGE_NAME));\r\n    }\r\n  }\r\n\r\n  const rawMax = getIsValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;\r\n  const min = getIsValidNumber(minProp) ? minProp : 0;\r\n  const max = rawMax <= min ? min + 1 : rawMax;\r\n\r\n  if (process.env.NODE_ENV !== \"production\" && thickness >= size) {\r\n    console.warn(\r\n      `Gauge: thickness (${thickness}) should be less than size (${size}) for proper rendering.`,\r\n    );\r\n  }\r\n\r\n  if (valueProp !== null && !getIsValidValueNumber(valueProp, min, max)) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.error(getInvalidValueError(`${valueProp}`, GAUGE_NAME));\r\n    }\r\n  }\r\n\r\n  const value = getIsValidValueNumber(valueProp, min, max)\r\n    ? valueProp\r\n    : getIsValidNumber(valueProp) && valueProp > max\r\n      ? max\r\n      : getIsValidNumber(valueProp) && valueProp < min\r\n        ? min\r\n        : null;\r\n\r\n  const valueText = getIsValidNumber(value)\r\n    ? getValueText(value, min, max)\r\n    : undefined;\r\n  const state = getGaugeState(value, max);\r\n  const radius = Math.max(0, (size - thickness) / 2);\r\n  const center = size / 2;\r\n\r\n  const angleDiff = Math.abs(endAngle - startAngle);\r\n  const arcLength = (Math.min(angleDiff, 360) / 360) * (2 * Math.PI * radius);\r\n\r\n  const percentage = getIsValidNumber(value)\r\n    ? max === min\r\n      ? 1\r\n      : (value - min) / (max - min)\r\n    : null;\r\n\r\n  // Calculate the visual center Y of the arc for text positioning\r\n  // For full circles, use geometric center. For partial arcs, calculate based on bounding box\r\n  const angleDiffDeg = Math.abs(endAngle - startAngle);\r\n  const isFullCircle = angleDiffDeg >= 360;\r\n\r\n  let arcCenterY = center;\r\n  if (!isFullCircle) {\r\n    const startRad = (startAngle * Math.PI) / 180;\r\n    const endRad = (endAngle * Math.PI) / 180;\r\n\r\n    const startY = center - radius * Math.cos(startRad);\r\n    const endY = center - radius * Math.cos(endRad);\r\n\r\n    let minY = Math.min(startY, endY);\r\n    let maxY = Math.max(startY, endY);\r\n\r\n    const normStart = getNormalizedAngle(startAngle);\r\n    const normEnd = getNormalizedAngle(endAngle);\r\n\r\n    const includesTop =\r\n      normStart > normEnd\r\n        ? normStart <= 270 || normEnd >= 270\r\n        : normStart <= 270 && normEnd >= 270;\r\n    const includesBottom =\r\n      normStart > normEnd\r\n        ? normStart <= 90 || normEnd >= 90\r\n        : normStart <= 90 && normEnd >= 90;\r\n\r\n    if (includesTop) minY = Math.min(minY, center - radius);\r\n    if (includesBottom) maxY = Math.max(maxY, center + radius);\r\n\r\n    arcCenterY = (minY + maxY) / 2;\r\n  }\r\n\r\n  const labelId = React.useId();\r\n  const valueTextId = React.useId();\r\n\r\n  const contextValue = React.useMemo<GaugeContextValue>(\r\n    () => ({\r\n      value,\r\n      valueText,\r\n      max,\r\n      min,\r\n      state,\r\n      radius,\r\n      thickness,\r\n      size,\r\n      center,\r\n      percentage,\r\n      startAngle,\r\n      endAngle,\r\n      arcLength,\r\n      arcCenterY,\r\n      valueTextId,\r\n      labelId,\r\n    }),\r\n    [\r\n      value,\r\n      valueText,\r\n      max,\r\n      min,\r\n      state,\r\n      radius,\r\n      thickness,\r\n      size,\r\n      center,\r\n      percentage,\r\n      startAngle,\r\n      endAngle,\r\n      arcLength,\r\n      arcCenterY,\r\n      valueTextId,\r\n      labelId,\r\n    ],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <GaugeContext.Provider value={contextValue}>\r\n      <RootPrimitive\r\n        role=\"meter\"\r\n        aria-describedby={valueText ? valueTextId : undefined}\r\n        aria-labelledby={labelId}\r\n        aria-valuemax={max}\r\n        aria-valuemin={min}\r\n        aria-valuenow={getIsValidNumber(value) ? value : undefined}\r\n        aria-valuetext={valueText}\r\n        data-state={state}\r\n        data-value={value ?? undefined}\r\n        data-max={max}\r\n        data-min={min}\r\n        data-percentage={percentage}\r\n        {...rootProps}\r\n        className={cn(\r\n          \"relative inline-flex w-fit flex-col items-center justify-center\",\r\n          className,\r\n        )}\r\n      />\r\n    </GaugeContext.Provider>\r\n  );\r\n}\r\n\r\nfunction GaugeIndicator(props: React.ComponentProps<\"svg\">) {\r\n  const { className, ...indicatorProps } = props;\r\n\r\n  const { size, state, value, max, min, percentage } =\r\n    useGaugeContext(INDICATOR_NAME);\r\n\r\n  return (\r\n    <svg\r\n      aria-hidden=\"true\"\r\n      focusable=\"false\"\r\n      viewBox={`0 0 ${size} ${size}`}\r\n      data-state={state}\r\n      data-value={value ?? undefined}\r\n      data-max={max}\r\n      data-min={min}\r\n      data-percentage={percentage}\r\n      width={size}\r\n      height={size}\r\n      {...indicatorProps}\r\n      className={cn(\"transform\", className)}\r\n    />\r\n  );\r\n}\r\n\r\nfunction GaugeTrack(props: PathProps) {\r\n  const { className, ...trackProps } = props;\r\n\r\n  const { center, radius, startAngle, endAngle, thickness, state } =\r\n    useGaugeContext(TRACK_NAME);\r\n\r\n  const pathData = describeArc(center, center, radius, startAngle, endAngle);\r\n\r\n  return (\r\n    <path\r\n      data-state={state}\r\n      d={pathData}\r\n      fill=\"none\"\r\n      stroke=\"currentColor\"\r\n      strokeWidth={thickness}\r\n      strokeLinecap=\"round\"\r\n      vectorEffect=\"non-scaling-stroke\"\r\n      {...trackProps}\r\n      className={cn(\"text-muted-foreground/20\", className)}\r\n    />\r\n  );\r\n}\r\n\r\nfunction GaugeRange(props: PathProps) {\r\n  const { className, ...rangeProps } = props;\r\n\r\n  const {\r\n    center,\r\n    radius,\r\n    startAngle,\r\n    endAngle,\r\n    value,\r\n    max,\r\n    min,\r\n    state,\r\n    thickness,\r\n    arcLength,\r\n    percentage,\r\n  } = useGaugeContext(RANGE_NAME);\r\n\r\n  const pathData = describeArc(center, center, radius, startAngle, endAngle);\r\n\r\n  const strokeDasharray = arcLength;\r\n  const strokeDashoffset =\r\n    state === \"indeterminate\"\r\n      ? 0\r\n      : percentage !== null\r\n        ? arcLength - percentage * arcLength\r\n        : arcLength;\r\n\r\n  return (\r\n    <path\r\n      data-state={state}\r\n      data-value={value ?? undefined}\r\n      data-max={max}\r\n      data-min={min}\r\n      d={pathData}\r\n      fill=\"none\"\r\n      stroke=\"currentColor\"\r\n      strokeWidth={thickness}\r\n      strokeLinecap=\"round\"\r\n      strokeDasharray={strokeDasharray}\r\n      strokeDashoffset={strokeDashoffset}\r\n      vectorEffect=\"non-scaling-stroke\"\r\n      {...rangeProps}\r\n      className={cn(\r\n        \"text-primary transition-[stroke-dashoffset] duration-700 ease-out\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nfunction GaugeValueText(props: DivProps) {\r\n  const { asChild, className, children, style, ...valueTextProps } = props;\r\n\r\n  const { valueTextId, state, arcCenterY, valueText } =\r\n    useGaugeContext(VALUE_TEXT_NAME);\r\n\r\n  const ValueTextPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <ValueTextPrimitive\r\n      id={valueTextId}\r\n      data-state={state}\r\n      {...valueTextProps}\r\n      style={{\r\n        top: `${arcCenterY}px`,\r\n        ...style,\r\n      }}\r\n      className={cn(\r\n        \"absolute right-0 left-0 flex -translate-y-1/2 items-center justify-center font-semibold text-2xl\",\r\n        className,\r\n      )}\r\n    >\r\n      {children ?? valueText}\r\n    </ValueTextPrimitive>\r\n  );\r\n}\r\n\r\nfunction GaugeLabel(props: DivProps) {\r\n  const { asChild, className, ...labelProps } = props;\r\n\r\n  const { labelId, state } = useGaugeContext(LABEL_NAME);\r\n\r\n  const LabelPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <LabelPrimitive\r\n      id={labelId}\r\n      data-state={state}\r\n      {...labelProps}\r\n      className={cn(\r\n        \"mt-2 font-medium text-muted-foreground text-sm\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nfunction GaugeCombined(props: GaugeProps) {\r\n  return (\r\n    <Gauge {...props}>\r\n      <GaugeIndicator>\r\n        <GaugeTrack />\r\n        <GaugeRange />\r\n      </GaugeIndicator>\r\n      <GaugeValueText />\r\n    </Gauge>\r\n  );\r\n}\r\n\r\nexport {\r\n  Gauge,\r\n  GaugeIndicator,\r\n  GaugeTrack,\r\n  GaugeRange,\r\n  GaugeValueText,\r\n  GaugeLabel,\r\n  GaugeCombined,\r\n  //\r\n  type GaugeProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}