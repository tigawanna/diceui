{
  "name": "key-value",
  "dependencies": [
    "radix-ui"
  ],
  "registryDependencies": [
    "button",
    "input",
    "textarea",
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/key-value.tsx",
      "content": "\"use client\";\r\n\r\nimport { PlusIcon, XIcon } from \"lucide-react\";\r\nimport { Slot as SlotPrimitive } from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { Textarea } from \"@/components/ui/textarea\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { VisuallyHiddenInput } from \"@/registry/bases/radix/components/visually-hidden-input\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"KeyValue\";\r\nconst LIST_NAME = \"KeyValueList\";\r\nconst ITEM_NAME = \"KeyValueItem\";\r\nconst KEY_INPUT_NAME = \"KeyValueKeyInput\";\r\nconst VALUE_INPUT_NAME = \"KeyValueValueInput\";\r\nconst REMOVE_NAME = \"KeyValueRemove\";\r\nconst ADD_NAME = \"KeyValueAdd\";\r\nconst ERROR_NAME = \"KeyValueError\";\r\n\r\ntype Orientation = \"vertical\" | \"horizontal\";\r\ntype Field = \"key\" | \"value\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof KeyValue>;\r\ntype KeyInputElement = React.ComponentRef<typeof KeyValueKeyInput>;\r\ntype RemoveElement = React.ComponentRef<typeof KeyValueRemove>;\r\ntype AddElement = React.ComponentRef<typeof KeyValueAdd>;\r\n\r\nfunction getErrorId(rootId: string, itemId: string, field: Field) {\r\n  return `${rootId}-${itemId}-${field}-error`;\r\n}\r\n\r\nfunction removeQuotes(string: string, shouldStrip: boolean): string {\r\n  if (!shouldStrip) return string;\r\n\r\n  const trimmed = string.trim();\r\n  if (\r\n    (trimmed.startsWith('\"') && trimmed.endsWith('\"')) ||\r\n    (trimmed.startsWith(\"'\") && trimmed.endsWith(\"'\"))\r\n  ) {\r\n    return trimmed.slice(1, -1);\r\n  }\r\n  return trimmed;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => KeyValueState;\r\n  setState: <K extends keyof KeyValueState>(\r\n    key: K,\r\n    value: KeyValueState[K],\r\n  ) => void;\r\n  notify: () => void;\r\n}\r\n\r\nfunction useStore<T>(\r\n  selector: (state: KeyValueState) => T,\r\n  ogStore?: Store | null,\r\n): T {\r\n  const contextStore = React.useContext(StoreContext);\r\n\r\n  const store = ogStore ?? contextStore;\r\n\r\n  if (!store) {\r\n    throw new Error(`\\`useStore\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface ItemData {\r\n  id: string;\r\n  key: string;\r\n  value: string;\r\n}\r\n\r\ninterface KeyValueState {\r\n  value: ItemData[];\r\n  focusedId: string | null;\r\n  errors: Record<string, { key?: string; value?: string }>;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KeyValueContextValue {\r\n  onPaste?: (event: ClipboardEvent, items: ItemData[]) => void;\r\n  onAdd?: (value: ItemData) => void;\r\n  onRemove?: (value: ItemData) => void;\r\n  onKeyValidate?: (key: string, value: ItemData[]) => string | undefined;\r\n  onValueValidate?: (\r\n    value: string,\r\n    key: string,\r\n    items: ItemData[],\r\n  ) => string | undefined;\r\n  rootId: string;\r\n  maxItems?: number;\r\n  minItems: number;\r\n  keyPlaceholder: string;\r\n  valuePlaceholder: string;\r\n  allowDuplicateKeys: boolean;\r\n  enablePaste: boolean;\r\n  trim: boolean;\r\n  stripQuotes: boolean;\r\n  disabled: boolean;\r\n  readOnly: boolean;\r\n  required: boolean;\r\n}\r\n\r\nconst KeyValueContext = React.createContext<KeyValueContextValue | null>(null);\r\n\r\nfunction useKeyValueContext(consumerName: string) {\r\n  const context = React.useContext(KeyValueContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KeyValueProps extends Omit<DivProps, \"onPaste\" | \"defaultValue\"> {\r\n  id?: string;\r\n  defaultValue?: ItemData[];\r\n  value?: ItemData[];\r\n  onValueChange?: (value: ItemData[]) => void;\r\n  maxItems?: number;\r\n  minItems?: number;\r\n  keyPlaceholder?: string;\r\n  valuePlaceholder?: string;\r\n  name?: string;\r\n  allowDuplicateKeys?: boolean;\r\n  enablePaste?: boolean;\r\n  trim?: boolean;\r\n  stripQuotes?: boolean;\r\n  disabled?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  onPaste?: (event: ClipboardEvent, items: ItemData[]) => void;\r\n  onAdd?: (value: ItemData) => void;\r\n  onRemove?: (value: ItemData) => void;\r\n  onKeyValidate?: (key: string, value: ItemData[]) => string | undefined;\r\n  onValueValidate?: (\r\n    value: string,\r\n    key: string,\r\n    items: ItemData[],\r\n  ) => string | undefined;\r\n}\r\n\r\nfunction KeyValue(props: KeyValueProps) {\r\n  const {\r\n    value: valueProp,\r\n    defaultValue,\r\n    onValueChange,\r\n    onPaste,\r\n    onAdd,\r\n    onRemove,\r\n    onKeyValidate,\r\n    onValueValidate,\r\n    maxItems,\r\n    minItems = 0,\r\n    keyPlaceholder = \"Key\",\r\n    valuePlaceholder = \"Value\",\r\n    allowDuplicateKeys = false,\r\n    asChild,\r\n    enablePaste = true,\r\n    trim = true,\r\n    stripQuotes = true,\r\n    disabled = false,\r\n    readOnly = false,\r\n    required = false,\r\n    className,\r\n    id,\r\n    name,\r\n    ref,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const instanceId = React.useId();\r\n  const rootId = id ?? instanceId;\r\n\r\n  const [formTrigger, setFormTrigger] = React.useState<RootElement | null>(\r\n    null,\r\n  );\r\n  const composedRef = useComposedRefs(ref, (node) => setFormTrigger(node));\r\n  const isFormControl = formTrigger ? !!formTrigger.closest(\"form\") : true;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<KeyValueState>(() => ({\r\n    value: valueProp ??\r\n      defaultValue ?? [{ id: crypto.randomUUID(), key: \"\", value: \"\" }],\r\n    focusedId: null,\r\n    errors: {},\r\n  }));\r\n  const propsRef = useAsRef({ onValueChange });\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, val) => {\r\n        if (Object.is(stateRef.current[key], val)) return;\r\n\r\n        if (key === \"value\" && Array.isArray(val)) {\r\n          stateRef.current.value = val as ItemData[];\r\n          propsRef.current.onValueChange?.(val as ItemData[]);\r\n        } else {\r\n          stateRef.current[key] = val;\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef]);\r\n\r\n  const value = useStore((state) => state.value, store);\r\n  const errors = useStore((state) => state.errors, store);\r\n  const isInvalid = Object.keys(errors).length > 0;\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (valueProp !== undefined) {\r\n      store.setState(\"value\", valueProp);\r\n    }\r\n  }, [valueProp]);\r\n\r\n  const contextValue = React.useMemo<KeyValueContextValue>(\r\n    () => ({\r\n      onPaste,\r\n      onAdd,\r\n      onRemove,\r\n      onKeyValidate,\r\n      onValueValidate,\r\n      rootId,\r\n      maxItems,\r\n      minItems,\r\n      keyPlaceholder,\r\n      valuePlaceholder,\r\n      allowDuplicateKeys,\r\n      enablePaste,\r\n      trim,\r\n      stripQuotes,\r\n      disabled,\r\n      readOnly,\r\n      required,\r\n    }),\r\n    [\r\n      onPaste,\r\n      onAdd,\r\n      onRemove,\r\n      onKeyValidate,\r\n      onValueValidate,\r\n      rootId,\r\n      disabled,\r\n      readOnly,\r\n      required,\r\n      maxItems,\r\n      minItems,\r\n      keyPlaceholder,\r\n      valuePlaceholder,\r\n      allowDuplicateKeys,\r\n      enablePaste,\r\n      trim,\r\n      stripQuotes,\r\n    ],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <KeyValueContext.Provider value={contextValue}>\r\n        <RootPrimitive\r\n          id={id}\r\n          data-slot=\"key-value\"\r\n          data-disabled={disabled ? \"\" : undefined}\r\n          data-invalid={isInvalid ? \"\" : undefined}\r\n          data-readonly={readOnly ? \"\" : undefined}\r\n          {...rootProps}\r\n          ref={composedRef}\r\n          className={cn(\"flex flex-col gap-2\", className)}\r\n        />\r\n        {isFormControl && (\r\n          <VisuallyHiddenInput\r\n            type=\"hidden\"\r\n            control={formTrigger}\r\n            name={name}\r\n            value={value}\r\n            disabled={disabled}\r\n            readOnly={readOnly}\r\n            required={required}\r\n          />\r\n        )}\r\n      </KeyValueContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface KeyValueListProps extends DivProps {\r\n  orientation?: Orientation;\r\n}\r\n\r\nfunction KeyValueList(props: KeyValueListProps) {\r\n  const { orientation = \"vertical\", asChild, className, ...listProps } = props;\r\n\r\n  const value = useStore((state) => state.value);\r\n\r\n  const ListPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <ListPrimitive\r\n      role=\"list\"\r\n      aria-orientation={orientation}\r\n      data-slot=\"key-value-list\"\r\n      data-orientation={orientation}\r\n      {...listProps}\r\n      className={cn(\r\n        \"flex\",\r\n        orientation === \"vertical\" ? \"flex-col gap-2\" : \"flex-row gap-2\",\r\n        className,\r\n      )}\r\n    >\r\n      {value.map((item) => {\r\n        const children = React.Children.toArray(props.children);\r\n\r\n        return (\r\n          <KeyValueItemContext.Provider key={item.id} value={item}>\r\n            {children}\r\n          </KeyValueItemContext.Provider>\r\n        );\r\n      })}\r\n    </ListPrimitive>\r\n  );\r\n}\r\n\r\nconst KeyValueItemContext = React.createContext<ItemData | null>(null);\r\n\r\nfunction useKeyValueItemContext(consumerName: string) {\r\n  const context = React.useContext(KeyValueItemContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${LIST_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KeyValueItemProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueItem(props: KeyValueItemProps) {\r\n  const { asChild, className, ...itemProps } = props;\r\n  const itemData = useKeyValueItemContext(ITEM_NAME);\r\n\r\n  const focusedId = useStore((state) => state.focusedId);\r\n\r\n  const ItemPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <ItemPrimitive\r\n      role=\"listitem\"\r\n      data-slot=\"key-value-item\"\r\n      data-highlighted={focusedId === itemData.id ? \"\" : undefined}\r\n      {...itemProps}\r\n      className={cn(\"flex items-start gap-2\", className)}\r\n    />\r\n  );\r\n}\r\n\r\ninterface KeyValueKeyInputProps extends React.ComponentProps<\"input\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueKeyInput(props: KeyValueKeyInputProps) {\r\n  const {\r\n    onChange: onChangeProp,\r\n    onPaste: onPasteProp,\r\n    asChild,\r\n    disabled,\r\n    readOnly,\r\n    required,\r\n    ...keyInputProps\r\n  } = props;\r\n\r\n  const context = useKeyValueContext(KEY_INPUT_NAME);\r\n  const itemData = useKeyValueItemContext(KEY_INPUT_NAME);\r\n  const store = useStoreContext(KEY_INPUT_NAME);\r\n  const errors = useStore((state) => state.errors);\r\n\r\n  const propsRef = useAsRef({\r\n    onChange: onChangeProp,\r\n    onPaste: onPasteProp,\r\n  });\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n  const isReadOnly = readOnly || context.readOnly;\r\n  const isRequired = required || context.required;\r\n  const isInvalid = errors[itemData.id]?.key !== undefined;\r\n\r\n  const onChange = React.useCallback(\r\n    (event: React.ChangeEvent<KeyInputElement>) => {\r\n      const state = store.getState();\r\n      const newValue = state.value.map((item) => {\r\n        if (item.id !== itemData.id) return item;\r\n        const updated = { ...item, key: event.target.value };\r\n        if (context.trim) updated.key = updated.key.trim();\r\n        return updated;\r\n      });\r\n\r\n      store.setState(\"value\", newValue);\r\n\r\n      const updatedItemData = newValue.find((item) => item.id === itemData.id);\r\n      if (updatedItemData) {\r\n        const errors: { key?: string; value?: string } = {};\r\n\r\n        if (context.onKeyValidate) {\r\n          const keyError = context.onKeyValidate(updatedItemData.key, newValue);\r\n          if (keyError) errors.key = keyError;\r\n        }\r\n\r\n        if (!context.allowDuplicateKeys) {\r\n          const duplicateKey = newValue.find(\r\n            (item) =>\r\n              item.id !== updatedItemData.id &&\r\n              item.key === updatedItemData.key &&\r\n              updatedItemData.key !== \"\",\r\n          );\r\n          if (duplicateKey) {\r\n            errors.key = \"Duplicate key\";\r\n          }\r\n        }\r\n\r\n        if (context.onValueValidate) {\r\n          const valueError = context.onValueValidate(\r\n            updatedItemData.value,\r\n            updatedItemData.key,\r\n            newValue,\r\n          );\r\n          if (valueError) errors.value = valueError;\r\n        }\r\n\r\n        const newErrorsState = { ...state.errors };\r\n        if (Object.keys(errors).length > 0) {\r\n          newErrorsState[itemData.id] = errors;\r\n        } else {\r\n          delete newErrorsState[itemData.id];\r\n        }\r\n        store.setState(\"errors\", newErrorsState);\r\n      }\r\n\r\n      propsRef.current.onChange?.(event);\r\n    },\r\n    [store, itemData.id, context, propsRef],\r\n  );\r\n\r\n  const onPaste = React.useCallback(\r\n    (event: React.ClipboardEvent<KeyInputElement>) => {\r\n      if (!context.enablePaste) return;\r\n\r\n      propsRef.current.onPaste?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const content = event.clipboardData.getData(\"text\");\r\n      const lines = content.split(/\\r?\\n/).filter((line) => line.trim());\r\n\r\n      if (lines.length > 1) {\r\n        event.preventDefault();\r\n\r\n        const parsed: ItemData[] = [];\r\n\r\n        for (const line of lines) {\r\n          let key = \"\";\r\n          let value = \"\";\r\n\r\n          if (line.includes(\"=\")) {\r\n            const parts = line.split(\"=\");\r\n            key = parts[0]?.trim() ?? \"\";\r\n            value = removeQuotes(\r\n              parts.slice(1).join(\"=\").trim(),\r\n              context.stripQuotes,\r\n            );\r\n          } else if (line.includes(\":\")) {\r\n            const parts = line.split(\":\");\r\n            key = parts[0]?.trim() ?? \"\";\r\n            value = removeQuotes(\r\n              parts.slice(1).join(\":\").trim(),\r\n              context.stripQuotes,\r\n            );\r\n          } else if (/\\s{2,}|\\t/.test(line)) {\r\n            const parts = line.split(/\\s{2,}|\\t/);\r\n            key = parts[0]?.trim() ?? \"\";\r\n            value = removeQuotes(\r\n              parts.slice(1).join(\" \").trim(),\r\n              context.stripQuotes,\r\n            );\r\n          }\r\n\r\n          if (key) {\r\n            parsed.push({ id: crypto.randomUUID(), key, value });\r\n          }\r\n        }\r\n\r\n        if (parsed.length > 0) {\r\n          const state = store.getState();\r\n          const currentIndex = state.value.findIndex(\r\n            (item) => item.id === itemData.id,\r\n          );\r\n\r\n          let newValue: ItemData[];\r\n          if (itemData.key === \"\" && itemData.value === \"\") {\r\n            newValue = [\r\n              ...state.value.slice(0, currentIndex),\r\n              ...parsed,\r\n              ...state.value.slice(currentIndex + 1),\r\n            ];\r\n          } else {\r\n            newValue = [\r\n              ...state.value.slice(0, currentIndex + 1),\r\n              ...parsed,\r\n              ...state.value.slice(currentIndex + 1),\r\n            ];\r\n          }\r\n\r\n          if (context.maxItems !== undefined) {\r\n            newValue = newValue.slice(0, context.maxItems);\r\n          }\r\n\r\n          store.setState(\"value\", newValue);\r\n\r\n          if (context.onPaste) {\r\n            context.onPaste(\r\n              event.nativeEvent as unknown as ClipboardEvent,\r\n              parsed,\r\n            );\r\n          }\r\n        }\r\n      }\r\n    },\r\n    [context, store, itemData, propsRef],\r\n  );\r\n\r\n  const KeyInputPrimitive = asChild ? SlotPrimitive.Slot : Input;\r\n\r\n  return (\r\n    <KeyInputPrimitive\r\n      aria-invalid={isInvalid}\r\n      aria-describedby={\r\n        isInvalid ? getErrorId(context.rootId, itemData.id, \"key\") : undefined\r\n      }\r\n      data-slot=\"key-value-key-input\"\r\n      autoCapitalize=\"off\"\r\n      autoComplete=\"off\"\r\n      autoCorrect=\"off\"\r\n      spellCheck=\"false\"\r\n      disabled={isDisabled}\r\n      readOnly={isReadOnly}\r\n      required={isRequired}\r\n      placeholder={context.keyPlaceholder}\r\n      {...keyInputProps}\r\n      value={itemData.key}\r\n      onChange={onChange}\r\n      onPaste={onPaste}\r\n    />\r\n  );\r\n}\r\n\r\ninterface KeyValueValueInputProps\r\n  extends Omit<React.ComponentProps<\"textarea\">, \"rows\"> {\r\n  maxRows?: number;\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction KeyValueValueInput(props: KeyValueValueInputProps) {\r\n  const {\r\n    onChange: onChangeProp,\r\n    asChild,\r\n    disabled,\r\n    readOnly,\r\n    required,\r\n    className,\r\n    maxRows,\r\n    style,\r\n    ...valueInputProps\r\n  } = props;\r\n\r\n  const context = useKeyValueContext(VALUE_INPUT_NAME);\r\n  const itemData = useKeyValueItemContext(VALUE_INPUT_NAME);\r\n  const store = useStoreContext(VALUE_INPUT_NAME);\r\n  const errors = useStore((state) => state.errors);\r\n\r\n  const propsRef = useAsRef({\r\n    onChange: onChangeProp,\r\n  });\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n  const isReadOnly = readOnly || context.readOnly;\r\n  const isRequired = required || context.required;\r\n  const isInvalid = errors[itemData.id]?.value !== undefined;\r\n  const maxHeight = maxRows ? `calc(${maxRows} * 1.5em + 1rem)` : undefined;\r\n\r\n  const onChange = React.useCallback(\r\n    (event: React.ChangeEvent<HTMLTextAreaElement>) => {\r\n      propsRef.current.onChange?.(event);\r\n\r\n      const state = store.getState();\r\n      const newValue = state.value.map((item) => {\r\n        if (item.id !== itemData.id) return item;\r\n        const updated = { ...item, value: event.target.value };\r\n        if (context.trim) updated.value = updated.value.trim();\r\n        return updated;\r\n      });\r\n\r\n      store.setState(\"value\", newValue);\r\n\r\n      const updatedItemData = newValue.find((item) => item.id === itemData.id);\r\n      if (updatedItemData) {\r\n        const errors: { key?: string; value?: string } = {};\r\n\r\n        if (context.onKeyValidate) {\r\n          const keyError = context.onKeyValidate(updatedItemData.key, newValue);\r\n          if (keyError) errors.key = keyError;\r\n        }\r\n\r\n        if (!context.allowDuplicateKeys) {\r\n          const duplicateKey = newValue.find(\r\n            (item) =>\r\n              item.id !== updatedItemData.id &&\r\n              item.key === updatedItemData.key &&\r\n              updatedItemData.key !== \"\",\r\n          );\r\n          if (duplicateKey) {\r\n            errors.key = \"Duplicate key\";\r\n          }\r\n        }\r\n\r\n        if (context.onValueValidate) {\r\n          const valueError = context.onValueValidate(\r\n            updatedItemData.value,\r\n            updatedItemData.key,\r\n            newValue,\r\n          );\r\n          if (valueError) errors.value = valueError;\r\n        }\r\n\r\n        const newErrorsState = { ...state.errors };\r\n        if (Object.keys(errors).length > 0) {\r\n          newErrorsState[itemData.id] = errors;\r\n        } else {\r\n          delete newErrorsState[itemData.id];\r\n        }\r\n        store.setState(\"errors\", newErrorsState);\r\n      }\r\n    },\r\n    [store, itemData.id, context, propsRef],\r\n  );\r\n\r\n  const ValueInputPrimitive = asChild ? SlotPrimitive.Slot : Textarea;\r\n\r\n  return (\r\n    <ValueInputPrimitive\r\n      aria-invalid={isInvalid}\r\n      aria-describedby={\r\n        isInvalid ? getErrorId(context.rootId, itemData.id, \"value\") : undefined\r\n      }\r\n      data-slot=\"key-value-value-input\"\r\n      autoCapitalize=\"off\"\r\n      autoComplete=\"off\"\r\n      autoCorrect=\"off\"\r\n      spellCheck=\"false\"\r\n      disabled={isDisabled}\r\n      readOnly={isReadOnly}\r\n      required={isRequired}\r\n      placeholder={context.valuePlaceholder}\r\n      {...valueInputProps}\r\n      className={cn(\r\n        \"field-sizing-content min-h-9 resize-none\",\r\n        maxRows && \"overflow-y-auto\",\r\n        className,\r\n      )}\r\n      style={{\r\n        ...style,\r\n        ...(maxHeight && { maxHeight }),\r\n      }}\r\n      value={itemData.value}\r\n      onChange={onChange}\r\n    />\r\n  );\r\n}\r\n\r\ninterface KeyValueRemoveProps extends React.ComponentProps<typeof Button> {}\r\n\r\nfunction KeyValueRemove(props: KeyValueRemoveProps) {\r\n  const { onClick: onClickProp, children, ...removeProps } = props;\r\n\r\n  const context = useKeyValueContext(REMOVE_NAME);\r\n  const itemData = useKeyValueItemContext(REMOVE_NAME);\r\n  const store = useStoreContext(REMOVE_NAME);\r\n\r\n  const propsRef = useAsRef({\r\n    onClick: onClickProp,\r\n  });\r\n  const value = useStore((state) => state.value);\r\n  const isDisabled = context.disabled || value.length <= context.minItems;\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<RemoveElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n\r\n      const state = store.getState();\r\n      if (state.value.length <= context.minItems) return;\r\n\r\n      const itemToRemove = state.value.find((item) => item.id === itemData.id);\r\n      if (!itemToRemove) return;\r\n\r\n      const newValue = state.value.filter((item) => item.id !== itemData.id);\r\n      const newErrors = { ...state.errors };\r\n      delete newErrors[itemData.id];\r\n\r\n      store.setState(\"value\", newValue);\r\n      store.setState(\"errors\", newErrors);\r\n\r\n      context.onRemove?.(itemToRemove);\r\n    },\r\n    [store, context, itemData.id, propsRef],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      data-slot=\"key-value-remove\"\r\n      variant=\"outline\"\r\n      size=\"icon\"\r\n      disabled={isDisabled}\r\n      {...removeProps}\r\n      onClick={onClick}\r\n    >\r\n      {children ?? <XIcon />}\r\n    </Button>\r\n  );\r\n}\r\n\r\nfunction KeyValueAdd(props: React.ComponentProps<typeof Button>) {\r\n  const { onClick: onClickProp, children, ...addProps } = props;\r\n\r\n  const context = useKeyValueContext(ADD_NAME);\r\n  const store = useStoreContext(ADD_NAME);\r\n\r\n  const propsRef = useAsRef({\r\n    onClick: onClickProp,\r\n  });\r\n  const value = useStore((state) => state.value);\r\n  const isDisabled =\r\n    context.disabled ||\r\n    (context.maxItems !== undefined && value.length >= context.maxItems);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<AddElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n\r\n      const state = store.getState();\r\n      if (\r\n        context.maxItems !== undefined &&\r\n        state.value.length >= context.maxItems\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const newItem: ItemData = {\r\n        id: crypto.randomUUID(),\r\n        key: \"\",\r\n        value: \"\",\r\n      };\r\n\r\n      const newValue = [...state.value, newItem];\r\n      store.setState(\"value\", newValue);\r\n      store.setState(\"focusedId\", newItem.id);\r\n\r\n      context.onAdd?.(newItem);\r\n    },\r\n    [store, context, propsRef],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      data-slot=\"key-value-add\"\r\n      variant=\"outline\"\r\n      disabled={isDisabled}\r\n      {...addProps}\r\n      onClick={onClick}\r\n    >\r\n      {children ?? (\r\n        <>\r\n          <PlusIcon />\r\n          Add\r\n        </>\r\n      )}\r\n    </Button>\r\n  );\r\n}\r\n\r\ninterface KeyValueErrorProps extends DivProps {\r\n  field: Field;\r\n}\r\n\r\nfunction KeyValueError(props: KeyValueErrorProps) {\r\n  const { field, asChild, className, ...errorProps } = props;\r\n\r\n  const context = useKeyValueContext(ERROR_NAME);\r\n  const itemData = useKeyValueItemContext(ERROR_NAME);\r\n\r\n  const errors = useStore((state) => state.errors);\r\n  const error = errors[itemData.id]?.[field];\r\n\r\n  if (!error) return null;\r\n\r\n  const ErrorPrimitive = asChild ? SlotPrimitive.Slot : \"span\";\r\n\r\n  return (\r\n    <ErrorPrimitive\r\n      id={getErrorId(context.rootId, itemData.id, field)}\r\n      role=\"alert\"\r\n      {...errorProps}\r\n      className={cn(\"font-medium text-destructive text-sm\", className)}\r\n    >\r\n      {error}\r\n    </ErrorPrimitive>\r\n  );\r\n}\r\n\r\nexport {\r\n  KeyValue,\r\n  KeyValueList,\r\n  KeyValueItem,\r\n  KeyValueKeyInput,\r\n  KeyValueValueInput,\r\n  KeyValueRemove,\r\n  KeyValueAdd,\r\n  KeyValueError,\r\n  //\r\n  useStore as useKeyValueStore,\r\n  //\r\n  type KeyValueProps,\r\n  type ItemData as KeyValueItemData,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\n\r\ntype InputValue = string[] | string;\r\n\r\ninterface VisuallyHiddenInputProps<T = InputValue>\r\n  extends Omit<\r\n    React.InputHTMLAttributes<HTMLInputElement>,\r\n    \"value\" | \"checked\" | \"onReset\"\r\n  > {\r\n  value?: T;\r\n  checked?: boolean;\r\n  control: HTMLElement | null;\r\n  bubbles?: boolean;\r\n}\r\n\r\nfunction VisuallyHiddenInput<T = InputValue>(\r\n  props: VisuallyHiddenInputProps<T>,\r\n) {\r\n  const {\r\n    control,\r\n    value,\r\n    checked,\r\n    bubbles = true,\r\n    type = \"hidden\",\r\n    style,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const isCheckInput = React.useMemo(\r\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\r\n    [type],\r\n  );\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  const prevValueRef = React.useRef<{\r\n    value: T | boolean | undefined;\r\n    previous: T | boolean | undefined;\r\n  }>({\r\n    value: isCheckInput ? checked : value,\r\n    previous: isCheckInput ? checked : value,\r\n  });\r\n\r\n  const prevValue = React.useMemo(() => {\r\n    const currentValue = isCheckInput ? checked : value;\r\n    if (prevValueRef.current.value !== currentValue) {\r\n      prevValueRef.current.previous = prevValueRef.current.value;\r\n      prevValueRef.current.value = currentValue;\r\n    }\r\n    return prevValueRef.current.previous;\r\n  }, [isCheckInput, value, checked]);\r\n\r\n  const [controlSize, setControlSize] = React.useState<{\r\n    width?: number;\r\n    height?: number;\r\n  }>({});\r\n\r\n  React.useLayoutEffect(() => {\r\n    if (!control) {\r\n      setControlSize({});\r\n      return;\r\n    }\r\n\r\n    setControlSize({\r\n      width: control.offsetWidth,\r\n      height: control.offsetHeight,\r\n    });\r\n\r\n    if (typeof window === \"undefined\") return;\r\n\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      if (!Array.isArray(entries) || !entries.length) return;\r\n\r\n      const entry = entries[0];\r\n      if (!entry) return;\r\n\r\n      let width: number;\r\n      let height: number;\r\n\r\n      if (\"borderBoxSize\" in entry) {\r\n        const borderSizeEntry = entry.borderBoxSize;\r\n        const borderSize = Array.isArray(borderSizeEntry)\r\n          ? borderSizeEntry[0]\r\n          : borderSizeEntry;\r\n        width = borderSize.inlineSize;\r\n        height = borderSize.blockSize;\r\n      } else {\r\n        width = control.offsetWidth;\r\n        height = control.offsetHeight;\r\n      }\r\n\r\n      setControlSize({ width, height });\r\n    });\r\n\r\n    resizeObserver.observe(control, { box: \"border-box\" });\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [control]);\r\n\r\n  React.useEffect(() => {\r\n    const input = inputRef.current;\r\n    if (!input) return;\r\n\r\n    const inputProto = window.HTMLInputElement.prototype;\r\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\r\n    const eventType = isCheckInput ? \"click\" : \"input\";\r\n    const currentValue = isCheckInput ? checked : value;\r\n\r\n    const serializedCurrentValue = isCheckInput\r\n      ? checked\r\n      : typeof value === \"object\" && value !== null\r\n        ? JSON.stringify(value)\r\n        : value;\r\n\r\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\r\n\r\n    const setter = descriptor?.set;\r\n\r\n    if (prevValue !== currentValue && setter) {\r\n      const event = new Event(eventType, { bubbles });\r\n      setter.call(input, serializedCurrentValue);\r\n      input.dispatchEvent(event);\r\n    }\r\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\r\n\r\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\r\n    return {\r\n      ...style,\r\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\r\n        ? controlSize\r\n        : {}),\r\n      border: 0,\r\n      clip: \"rect(0 0 0 0)\",\r\n      clipPath: \"inset(50%)\",\r\n      height: \"1px\",\r\n      margin: \"-1px\",\r\n      overflow: \"hidden\",\r\n      padding: 0,\r\n      position: \"absolute\",\r\n      whiteSpace: \"nowrap\",\r\n      width: \"1px\",\r\n    };\r\n  }, [style, controlSize]);\r\n\r\n  return (\r\n    <input\r\n      type={type}\r\n      {...inputProps}\r\n      ref={inputRef}\r\n      aria-hidden={isCheckInput}\r\n      tabIndex={-1}\r\n      defaultChecked={isCheckInput ? checked : undefined}\r\n      style={composedStyle}\r\n    />\r\n  );\r\n}\r\n\r\nexport { VisuallyHiddenInput };\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}