{
  "name": "speed-dial",
  "dependencies": [
    "radix-ui"
  ],
  "registryDependencies": [
    "button",
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/speed-dial.tsx",
      "content": "\"use client\";\r\n\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\nimport { Slot as SlotPrimitive } from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"SpeedDial\";\r\nconst TRIGGER_NAME = \"SpeedDialTrigger\";\r\nconst CONTENT_NAME = \"SpeedDialContent\";\r\nconst ITEM_NAME = \"SpeedDialItem\";\r\nconst ACTION_NAME = \"SpeedDialAction\";\r\nconst LABEL_NAME = \"SpeedDialLabel\";\r\n\r\nconst ACTION_SELECT = \"speedDial.actionSelect\";\r\nconst INTERACT_OUTSIDE = \"speedDial.interactOutside\";\r\nconst EVENT_OPTIONS = { bubbles: true, cancelable: true };\r\n\r\nconst DEFAULT_GAP = 8;\r\nconst DEFAULT_OFFSET = 8;\r\nconst DEFAULT_ITEM_DELAY = 50;\r\nconst DEFAULT_HOVER_CLOSE_DELAY = 100;\r\nconst DEFAULT_ANIMATION_DURATION = 200;\r\n\r\ntype Side = \"top\" | \"right\" | \"bottom\" | \"left\";\r\ntype ActivationMode = \"click\" | \"hover\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof SpeedDial>;\r\ntype ContentElement = React.ComponentRef<typeof SpeedDialContent>;\r\ntype TriggerElement = React.ComponentRef<typeof SpeedDialTrigger>;\r\ntype ActionElement = React.ComponentRef<typeof SpeedDialAction>;\r\n\r\ninterface InteractOutsideEvent extends CustomEvent {\r\n  detail: {\r\n    originalEvent: PointerEvent;\r\n  };\r\n}\r\n\r\nfunction getDataState(open: boolean): string {\r\n  return open ? \"open\" : \"closed\";\r\n}\r\n\r\nfunction getTransformOrigin(side: Side): string {\r\n  switch (side) {\r\n    case \"top\":\r\n      return \"bottom center\";\r\n    case \"bottom\":\r\n      return \"top center\";\r\n    case \"left\":\r\n      return \"right center\";\r\n    case \"right\":\r\n      return \"left center\";\r\n  }\r\n}\r\n\r\ninterface StoreState {\r\n  open: boolean;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  notify: () => void;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(\r\n  selector: (state: StoreState) => T,\r\n  ogStore?: Store | null,\r\n): T {\r\n  const contextStore = React.useContext(StoreContext);\r\n\r\n  const store = ogStore ?? contextStore;\r\n\r\n  if (!store) {\r\n    throw new Error(`\\`useStore\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface NodeData {\r\n  id: string;\r\n  ref: React.RefObject<HTMLElement | null>;\r\n  disabled: boolean;\r\n}\r\n\r\ninterface SpeedDialContextValue {\r\n  onNodeRegister: (node: NodeData) => void;\r\n  onNodeUnregister: (id: string) => void;\r\n  getNodes: () => NodeData[];\r\n  contentId: string;\r\n  rootRef: React.RefObject<RootElement | null>;\r\n  triggerRef: React.RefObject<TriggerElement | null>;\r\n  isPointerInsideReactTreeRef: React.RefObject<boolean>;\r\n  hoverCloseTimerRef: React.RefObject<number | null>;\r\n  side: Side;\r\n  activationMode: ActivationMode;\r\n  delay: number;\r\n  disabled: boolean;\r\n}\r\n\r\nconst SpeedDialContext = React.createContext<SpeedDialContextValue | null>(\r\n  null,\r\n);\r\n\r\nfunction useSpeedDialContext(consumerName: string) {\r\n  const context = React.useContext(SpeedDialContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface SpeedDialProps extends DivProps {\r\n  open?: boolean;\r\n  defaultOpen?: boolean;\r\n  onOpenChange?: (open: boolean) => void;\r\n  side?: Side;\r\n  activationMode?: ActivationMode;\r\n  delay?: number;\r\n  disabled?: boolean;\r\n}\r\n\r\nfunction SpeedDial(props: SpeedDialProps) {\r\n  const {\r\n    open: openProp,\r\n    defaultOpen,\r\n    onOpenChange,\r\n    onPointerDownCapture: onPointerDownCaptureProp,\r\n    side = \"top\",\r\n    activationMode = \"click\",\r\n    delay = 250,\r\n    asChild,\r\n    disabled = false,\r\n    className,\r\n    ref,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const contentId = React.useId();\r\n\r\n  const rootRef = React.useRef<RootElement | null>(null);\r\n  const composedRefs = useComposedRefs(ref, rootRef);\r\n\r\n  const triggerRef = React.useRef<TriggerElement | null>(null);\r\n\r\n  const nodesRef = React.useRef<Map<string, NodeData>>(new Map());\r\n  const isPointerInsideReactTreeRef = React.useRef(false);\r\n  const hoverCloseTimerRef = React.useRef<number | null>(null);\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    open: openProp ?? defaultOpen ?? false,\r\n  }));\r\n\r\n  const propsRef = useAsRef({\r\n    onOpenChange,\r\n    onPointerDownCapture: onPointerDownCaptureProp,\r\n  });\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n\r\n        if (key === \"open\" && typeof value === \"boolean\") {\r\n          stateRef.current.open = value;\r\n          propsRef.current.onOpenChange?.(value);\r\n        } else {\r\n          stateRef.current[key] = value;\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef]);\r\n\r\n  const getNodes = React.useCallback(() => {\r\n    return Array.from(nodesRef.current.values())\r\n      .filter((node) => node.ref.current)\r\n      .sort((a, b) => {\r\n        const elementA = a.ref.current;\r\n        const elementB = b.ref.current;\r\n        if (!elementA || !elementB) return 0;\r\n        const position = elementA.compareDocumentPosition(elementB);\r\n        if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\r\n          return -1;\r\n        }\r\n        if (position & Node.DOCUMENT_POSITION_PRECEDING) {\r\n          return 1;\r\n        }\r\n        return 0;\r\n      });\r\n  }, []);\r\n\r\n  const onNodeRegister = React.useCallback((node: NodeData) => {\r\n    nodesRef.current.set(node.id, node);\r\n  }, []);\r\n\r\n  const onNodeUnregister = React.useCallback((id: string) => {\r\n    nodesRef.current.delete(id);\r\n  }, []);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (openProp !== undefined) {\r\n      store.setState(\"open\", openProp);\r\n    }\r\n  }, [openProp]);\r\n\r\n  const open = useStore((state) => state.open, store);\r\n\r\n  const onPointerDownCapture = React.useCallback(\r\n    (event: React.PointerEvent<RootElement>) => {\r\n      propsRef.current?.onPointerDownCapture?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const target = event.target as HTMLElement;\r\n      const nodes = getNodes();\r\n      const isInteractiveElement = nodes.some((node) =>\r\n        node.ref.current?.contains(target),\r\n      );\r\n\r\n      isPointerInsideReactTreeRef.current = isInteractiveElement;\r\n    },\r\n    [propsRef, getNodes],\r\n  );\r\n\r\n  const contextValue = React.useMemo<SpeedDialContextValue>(\r\n    () => ({\r\n      getNodes,\r\n      onNodeRegister,\r\n      onNodeUnregister,\r\n      contentId,\r\n      rootRef,\r\n      triggerRef,\r\n      isPointerInsideReactTreeRef,\r\n      hoverCloseTimerRef,\r\n      side,\r\n      activationMode,\r\n      delay,\r\n      disabled,\r\n    }),\r\n    [\r\n      getNodes,\r\n      onNodeRegister,\r\n      onNodeUnregister,\r\n      contentId,\r\n      side,\r\n      activationMode,\r\n      delay,\r\n      disabled,\r\n    ],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <SpeedDialContext.Provider value={contextValue}>\r\n        <RootPrimitive\r\n          data-slot=\"speed-dial\"\r\n          data-state={getDataState(open)}\r\n          data-disabled={disabled}\r\n          {...rootProps}\r\n          ref={composedRefs}\r\n          className={cn(\"relative flex flex-col items-end\", className)}\r\n          onPointerDownCapture={onPointerDownCapture}\r\n        />\r\n      </SpeedDialContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\nfunction SpeedDialTrigger(props: React.ComponentProps<typeof Button>) {\r\n  const {\r\n    onClick: onClickProp,\r\n    onMouseEnter: onMouseEnterProp,\r\n    onMouseLeave: onMouseLeaveProp,\r\n    className,\r\n    disabled: disabledProp,\r\n    id,\r\n    ref,\r\n    ...triggerProps\r\n  } = props;\r\n\r\n  const store = useStoreContext(TRIGGER_NAME);\r\n\r\n  const {\r\n    onNodeRegister,\r\n    onNodeUnregister,\r\n    contentId,\r\n    hoverCloseTimerRef,\r\n    triggerRef,\r\n    activationMode,\r\n    delay,\r\n    disabled,\r\n  } = useSpeedDialContext(TRIGGER_NAME);\r\n\r\n  const open = useStore((state) => state.open);\r\n  const isDisabled = disabledProp || disabled;\r\n\r\n  const instanceId = React.useId();\r\n  const triggerId = id ?? instanceId;\r\n\r\n  const composedRef = useComposedRefs(ref, triggerRef);\r\n  const hoverOpenTimerRef = React.useRef<number | null>(null);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    onNodeRegister({\r\n      id: triggerId,\r\n      ref: triggerRef,\r\n      disabled: isDisabled,\r\n    });\r\n\r\n    return () => {\r\n      onNodeUnregister(triggerId);\r\n    };\r\n  }, [onNodeRegister, onNodeUnregister, triggerId, isDisabled]);\r\n\r\n  React.useEffect(() => {\r\n    return () => {\r\n      if (hoverOpenTimerRef.current) {\r\n        window.clearTimeout(hoverOpenTimerRef.current);\r\n      }\r\n      if (hoverCloseTimerRef.current) {\r\n        window.clearTimeout(hoverCloseTimerRef.current);\r\n      }\r\n    };\r\n  }, [hoverCloseTimerRef]);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<TriggerElement>) => {\r\n      onClickProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (hoverOpenTimerRef.current) {\r\n        window.clearTimeout(hoverOpenTimerRef.current);\r\n        hoverOpenTimerRef.current = null;\r\n      }\r\n      if (hoverCloseTimerRef.current) {\r\n        window.clearTimeout(hoverCloseTimerRef.current);\r\n        hoverCloseTimerRef.current = null;\r\n      }\r\n\r\n      store.setState(\"open\", !open);\r\n    },\r\n    [onClickProp, store, open, hoverCloseTimerRef],\r\n  );\r\n\r\n  const onMouseEnter = React.useCallback(\r\n    (event: React.MouseEvent<TriggerElement>) => {\r\n      onMouseEnterProp?.(event);\r\n      if (event.defaultPrevented || activationMode !== \"hover\" || isDisabled)\r\n        return;\r\n\r\n      if (hoverCloseTimerRef.current) {\r\n        window.clearTimeout(hoverCloseTimerRef.current);\r\n        hoverCloseTimerRef.current = null;\r\n      }\r\n\r\n      if (hoverOpenTimerRef.current) {\r\n        window.clearTimeout(hoverOpenTimerRef.current);\r\n      }\r\n\r\n      hoverOpenTimerRef.current = window.setTimeout(() => {\r\n        store.setState(\"open\", true);\r\n      }, delay);\r\n    },\r\n    [\r\n      onMouseEnterProp,\r\n      activationMode,\r\n      isDisabled,\r\n      store,\r\n      delay,\r\n      hoverCloseTimerRef,\r\n    ],\r\n  );\r\n\r\n  const onMouseLeave = React.useCallback(\r\n    (event: React.MouseEvent<TriggerElement>) => {\r\n      onMouseLeaveProp?.(event);\r\n      if (event.defaultPrevented || activationMode !== \"hover\" || isDisabled)\r\n        return;\r\n\r\n      if (hoverOpenTimerRef.current) {\r\n        window.clearTimeout(hoverOpenTimerRef.current);\r\n        hoverOpenTimerRef.current = null;\r\n      }\r\n\r\n      hoverCloseTimerRef.current = window.setTimeout(() => {\r\n        store.setState(\"open\", false);\r\n      }, DEFAULT_HOVER_CLOSE_DELAY);\r\n    },\r\n    [onMouseLeaveProp, activationMode, isDisabled, store, hoverCloseTimerRef],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      role=\"button\"\r\n      id={triggerId}\r\n      aria-controls={contentId}\r\n      aria-expanded={open}\r\n      aria-haspopup=\"menu\"\r\n      data-slot=\"speed-dial-trigger\"\r\n      data-state={getDataState(open)}\r\n      disabled={isDisabled}\r\n      size=\"icon\"\r\n      {...triggerProps}\r\n      ref={composedRef}\r\n      className={cn(\"size-11 rounded-full\", className)}\r\n      onClick={onClick}\r\n      onMouseEnter={onMouseEnter}\r\n      onMouseLeave={onMouseLeave}\r\n    />\r\n  );\r\n}\r\n\r\ninterface SpeedDialItemImplContextValue {\r\n  delay: number;\r\n  open: boolean;\r\n}\r\n\r\nconst SpeedDialItemImplContext =\r\n  React.createContext<SpeedDialItemImplContextValue | null>(null);\r\n\r\nfunction useSpeedDialItemImplContext() {\r\n  return React.useContext(SpeedDialItemImplContext);\r\n}\r\n\r\ninterface SpeedDialItemImplProps {\r\n  delay: number;\r\n  open: boolean;\r\n  children: React.ReactNode;\r\n}\r\n\r\nconst SpeedDialItemImpl = React.memo(function SpeedDialItemImpl({\r\n  delay,\r\n  open,\r\n  children,\r\n}: SpeedDialItemImplProps) {\r\n  const contextValue = React.useMemo<SpeedDialItemImplContextValue>(\r\n    () => ({ delay, open }),\r\n    [delay, open],\r\n  );\r\n\r\n  return (\r\n    <SpeedDialItemImplContext.Provider value={contextValue}>\r\n      {children}\r\n    </SpeedDialItemImplContext.Provider>\r\n  );\r\n});\r\n\r\nconst speedDialContentVariants = cva(\r\n  \"absolute z-50 flex gap-[var(--speed-dial-gap)] data-[state=closed]:pointer-events-none\",\r\n  {\r\n    variants: {\r\n      side: {\r\n        top: \"flex-col-reverse items-end\",\r\n        bottom: \"flex-col items-end\",\r\n        left: \"flex-row-reverse items-center\",\r\n        right: \"flex-row items-center\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      side: \"top\",\r\n    },\r\n  },\r\n);\r\n\r\ninterface SpeedDialContentProps\r\n  extends DivProps,\r\n    VariantProps<typeof speedDialContentVariants> {\r\n  offset?: number;\r\n  gap?: number;\r\n  forceMount?: boolean;\r\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\r\n  onInteractOutside?: (event: InteractOutsideEvent) => void;\r\n}\r\n\r\nfunction SpeedDialContent(props: SpeedDialContentProps) {\r\n  const {\r\n    offset = DEFAULT_OFFSET,\r\n    gap = DEFAULT_GAP,\r\n    forceMount = false,\r\n    onEscapeKeyDown,\r\n    onInteractOutside,\r\n    onMouseEnter: onMouseEnterProp,\r\n    onMouseLeave: onMouseLeaveProp,\r\n    asChild,\r\n    className,\r\n    children,\r\n    style,\r\n    ref,\r\n    ...contentProps\r\n  } = props;\r\n\r\n  const store = useStoreContext(CONTENT_NAME);\r\n  const open = useStore((state) => state.open);\r\n\r\n  const {\r\n    contentId,\r\n    side,\r\n    getNodes,\r\n    rootRef,\r\n    triggerRef,\r\n    isPointerInsideReactTreeRef,\r\n    hoverCloseTimerRef,\r\n    activationMode,\r\n  } = useSpeedDialContext(CONTENT_NAME);\r\n\r\n  const contentRef = React.useRef<ContentElement | null>(null);\r\n  const composedRef = useComposedRefs(ref, contentRef);\r\n\r\n  const propsRef = useAsRef({\r\n    onMouseEnter: onMouseEnterProp,\r\n    onMouseLeave: onMouseLeaveProp,\r\n    onEscapeKeyDown,\r\n    onInteractOutside,\r\n  });\r\n\r\n  const orientation =\r\n    side === \"top\" || side === \"bottom\" ? \"vertical\" : \"horizontal\";\r\n\r\n  const transformOrigin = React.useMemo(() => getTransformOrigin(side), [side]);\r\n\r\n  const ownerDocument =\r\n    contentRef.current?.ownerDocument ?? globalThis?.document;\r\n\r\n  const mounted = React.useSyncExternalStore(\r\n    () => () => {},\r\n    () => true,\r\n    () => false,\r\n  );\r\n\r\n  const [renderState, setRenderState] = React.useState({\r\n    shouldRender: false,\r\n    animating: false,\r\n  });\r\n  const [position, setPosition] = React.useState<React.CSSProperties>({});\r\n\r\n  const openRafRef = React.useRef<number | null>(null);\r\n  const unmountTimerRef = React.useRef<number | null>(null);\r\n\r\n  React.useEffect(() => {\r\n    if (open) {\r\n      if (unmountTimerRef.current) {\r\n        clearTimeout(unmountTimerRef.current);\r\n        unmountTimerRef.current = null;\r\n      }\r\n\r\n      setRenderState((prev) => ({ ...prev, shouldRender: true }));\r\n\r\n      if (openRafRef.current) cancelAnimationFrame(openRafRef.current);\r\n      openRafRef.current = requestAnimationFrame(() => {\r\n        setRenderState((prev) => ({ ...prev, animating: true }));\r\n        openRafRef.current = null;\r\n      });\r\n\r\n      return () => {\r\n        if (openRafRef.current) {\r\n          cancelAnimationFrame(openRafRef.current);\r\n          openRafRef.current = null;\r\n        }\r\n      };\r\n    } else {\r\n      setRenderState((prev) => ({ ...prev, animating: false }));\r\n\r\n      if (!forceMount) {\r\n        const childCount = React.Children.count(children);\r\n        const animationDuration = DEFAULT_ANIMATION_DURATION;\r\n        const longestDelay = (childCount - 1) * DEFAULT_ITEM_DELAY;\r\n        const totalDuration = longestDelay + animationDuration;\r\n\r\n        unmountTimerRef.current = window.setTimeout(() => {\r\n          setRenderState((prev) => ({ ...prev, shouldRender: false }));\r\n        }, totalDuration);\r\n\r\n        return () => {\r\n          if (unmountTimerRef.current) {\r\n            clearTimeout(unmountTimerRef.current);\r\n            unmountTimerRef.current = null;\r\n          }\r\n        };\r\n      }\r\n    }\r\n  }, [open, forceMount, children]);\r\n\r\n  const updatePosition = React.useCallback(() => {\r\n    if (!triggerRef.current || !open) return;\r\n\r\n    const newPosition: React.CSSProperties = {};\r\n\r\n    switch (side) {\r\n      case \"top\":\r\n        newPosition.bottom = `calc(100% + ${offset}px)`;\r\n        newPosition.right = \"0\";\r\n        break;\r\n      case \"bottom\":\r\n        newPosition.top = `calc(100% + ${offset}px)`;\r\n        newPosition.right = \"0\";\r\n        break;\r\n      case \"left\":\r\n        newPosition.right = `calc(100% + ${offset}px)`;\r\n        newPosition.top = \"0\";\r\n        break;\r\n      case \"right\":\r\n        newPosition.left = `calc(100% + ${offset}px)`;\r\n        newPosition.top = \"0\";\r\n        break;\r\n    }\r\n\r\n    setPosition((prev) => {\r\n      const hasChanged = Object.keys(newPosition).some((key) => {\r\n        const k = key as keyof typeof newPosition;\r\n        return prev[k] !== newPosition[k];\r\n      });\r\n      return hasChanged ? newPosition : prev;\r\n    });\r\n  }, [triggerRef, open, side, offset]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (!open) return;\r\n    updatePosition();\r\n  }, [open, updatePosition]);\r\n\r\n  React.useEffect(() => {\r\n    if (!open) return;\r\n\r\n    const onKeyDown = (event: KeyboardEvent) => {\r\n      if (event.key === \"Escape\") {\r\n        propsRef.current?.onEscapeKeyDown?.(event);\r\n        if (event.defaultPrevented) return;\r\n\r\n        store.setState(\"open\", false);\r\n      }\r\n\r\n      if (event.key === \"Tab\") {\r\n        const focusableElements = getNodes()\r\n          .filter((node) => !node.disabled)\r\n          .map((node) => node.ref.current);\r\n\r\n        if (focusableElements.length === 0) return;\r\n\r\n        const firstElement = focusableElements[0];\r\n        const lastElement = focusableElements[focusableElements.length - 1];\r\n        const activeElement = ownerDocument.activeElement;\r\n\r\n        if (event.shiftKey) {\r\n          if (activeElement === firstElement) {\r\n            store.setState(\"open\", false);\r\n          }\r\n        } else {\r\n          if (activeElement === lastElement) {\r\n            store.setState(\"open\", false);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    ownerDocument.addEventListener(\"keydown\", onKeyDown);\r\n    return () => ownerDocument.removeEventListener(\"keydown\", onKeyDown);\r\n  }, [open, propsRef, ownerDocument, store, getNodes]);\r\n\r\n  const onClickRef = React.useRef<() => void>(() => {});\r\n\r\n  React.useEffect(() => {\r\n    if (!open) return;\r\n\r\n    isPointerInsideReactTreeRef.current = false;\r\n\r\n    const onPointerDown = (event: PointerEvent) => {\r\n      if (event.target && !isPointerInsideReactTreeRef.current) {\r\n        const target = event.target as HTMLElement;\r\n        const isOutside = !rootRef.current?.contains(target);\r\n\r\n        function onDismiss() {\r\n          if (isOutside) {\r\n            const interactEvent = new CustomEvent(INTERACT_OUTSIDE, {\r\n              ...EVENT_OPTIONS,\r\n              detail: { originalEvent: event },\r\n            }) as InteractOutsideEvent;\r\n\r\n            propsRef.current?.onInteractOutside?.(interactEvent);\r\n            if (interactEvent.defaultPrevented) return;\r\n          }\r\n\r\n          store.setState(\"open\", false);\r\n        }\r\n\r\n        if (event.pointerType === \"touch\") {\r\n          ownerDocument.removeEventListener(\"click\", onClickRef.current);\r\n          onClickRef.current = onDismiss;\r\n          ownerDocument.addEventListener(\"click\", onClickRef.current, {\r\n            once: true,\r\n          });\r\n        } else {\r\n          onDismiss();\r\n        }\r\n      } else {\r\n        ownerDocument.removeEventListener(\"click\", onClickRef.current);\r\n      }\r\n      isPointerInsideReactTreeRef.current = false;\r\n    };\r\n\r\n    const timerId = window.setTimeout(() => {\r\n      ownerDocument.addEventListener(\"pointerdown\", onPointerDown);\r\n    }, 0);\r\n\r\n    return () => {\r\n      window.clearTimeout(timerId);\r\n      ownerDocument.removeEventListener(\"pointerdown\", onPointerDown);\r\n      ownerDocument.removeEventListener(\"click\", onClickRef.current);\r\n    };\r\n  }, [\r\n    open,\r\n    rootRef,\r\n    isPointerInsideReactTreeRef,\r\n    propsRef,\r\n    ownerDocument,\r\n    store,\r\n  ]);\r\n\r\n  const onMouseEnter = React.useCallback(\r\n    (event: React.MouseEvent<ContentElement>) => {\r\n      propsRef.current?.onMouseEnter?.(event);\r\n      if (event.defaultPrevented || activationMode !== \"hover\") return;\r\n\r\n      if (hoverCloseTimerRef.current) {\r\n        window.clearTimeout(hoverCloseTimerRef.current);\r\n        hoverCloseTimerRef.current = null;\r\n      }\r\n    },\r\n    [propsRef, hoverCloseTimerRef, activationMode],\r\n  );\r\n\r\n  const onMouseLeave = React.useCallback(\r\n    (event: React.MouseEvent<ContentElement>) => {\r\n      propsRef.current?.onMouseLeave?.(event);\r\n      if (event.defaultPrevented || activationMode !== \"hover\") return;\r\n\r\n      hoverCloseTimerRef.current = window.setTimeout(() => {\r\n        store.setState(\"open\", false);\r\n      }, DEFAULT_HOVER_CLOSE_DELAY);\r\n    },\r\n    [propsRef, hoverCloseTimerRef, store, activationMode],\r\n  );\r\n\r\n  const contentStyle = React.useMemo<React.CSSProperties>(\r\n    () => ({\r\n      \"--speed-dial-gap\": `${gap}px`,\r\n      \"--speed-dial-offset\": `${offset}px`,\r\n      \"--speed-dial-transform-origin\": transformOrigin,\r\n      ...position,\r\n      ...style,\r\n    }),\r\n    [gap, offset, transformOrigin, position, style],\r\n  );\r\n\r\n  const ContentPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  const shouldMount = forceMount || renderState.shouldRender;\r\n\r\n  if (!mounted || !shouldMount) return null;\r\n\r\n  return (\r\n    <ContentPrimitive\r\n      id={contentId}\r\n      role=\"menu\"\r\n      aria-orientation={orientation}\r\n      data-slot=\"speed-dial-content\"\r\n      data-state={getDataState(renderState.animating)}\r\n      data-orientation={orientation}\r\n      data-side={side}\r\n      {...contentProps}\r\n      ref={composedRef}\r\n      className={cn(speedDialContentVariants({ side, className }))}\r\n      style={contentStyle}\r\n      onMouseEnter={onMouseEnter}\r\n      onMouseLeave={onMouseLeave}\r\n    >\r\n      {(() => {\r\n        const totalChildren = React.Children.count(children);\r\n        return React.Children.map(children, (child, index) => {\r\n          if (!React.isValidElement(child)) return child;\r\n\r\n          const delay = renderState.animating\r\n            ? index * DEFAULT_ITEM_DELAY\r\n            : (totalChildren - index - 1) * DEFAULT_ITEM_DELAY;\r\n\r\n          return (\r\n            <SpeedDialItemImpl\r\n              key={child.key ?? index}\r\n              delay={delay}\r\n              open={renderState.animating}\r\n            >\r\n              {child}\r\n            </SpeedDialItemImpl>\r\n          );\r\n        });\r\n      })()}\r\n    </ContentPrimitive>\r\n  );\r\n}\r\n\r\nconst speedDialItemVariants = cva(\r\n  \"flex items-center gap-2 transition-all [transition-delay:var(--speed-dial-delay)] [transition-duration:var(--speed-dial-animation-duration)] data-[state=open]:translate-x-0 data-[state=open]:translate-y-0 data-[state=closed]:opacity-0 data-[state=open]:opacity-100\",\r\n  {\r\n    variants: {\r\n      side: {\r\n        top: \"justify-end\",\r\n        bottom: \"justify-end\",\r\n        left: \"flex-row-reverse justify-start\",\r\n        right: \"justify-start\",\r\n      },\r\n    },\r\n    compoundVariants: [\r\n      {\r\n        side: \"top\",\r\n        className: \"data-[state=closed]:translate-y-2\",\r\n      },\r\n      {\r\n        side: \"bottom\",\r\n        className: \"data-[state=closed]:-translate-y-2\",\r\n      },\r\n      {\r\n        side: \"left\",\r\n        className: \"data-[state=closed]:translate-x-2\",\r\n      },\r\n      {\r\n        side: \"right\",\r\n        className: \"data-[state=closed]:-translate-x-2\",\r\n      },\r\n    ],\r\n    defaultVariants: {\r\n      side: \"top\",\r\n    },\r\n  },\r\n);\r\n\r\ninterface SpeedDialItemContextValue {\r\n  actionId: string;\r\n  labelId: string;\r\n}\r\n\r\nconst SpeedDialItemContext =\r\n  React.createContext<SpeedDialItemContextValue | null>(null);\r\n\r\nfunction useSpeedDialItemContext(consumerName: string) {\r\n  const context = React.useContext(SpeedDialItemContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ITEM_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction SpeedDialItem(props: DivProps) {\r\n  const { asChild, className, style, children, ...itemProps } = props;\r\n\r\n  const { side } = useSpeedDialContext(ITEM_NAME);\r\n  const itemImplContext = useSpeedDialItemImplContext();\r\n  const delay = itemImplContext?.delay ?? 0;\r\n  const open = itemImplContext?.open ?? false;\r\n\r\n  const actionId = React.useId();\r\n  const labelId = React.useId();\r\n\r\n  const contextValue = React.useMemo<SpeedDialItemContextValue>(\r\n    () => ({ actionId, labelId }),\r\n    [actionId, labelId],\r\n  );\r\n\r\n  const itemStyle = React.useMemo<React.CSSProperties>(\r\n    () => ({\r\n      \"--speed-dial-animation-duration\": `${DEFAULT_ANIMATION_DURATION}ms`,\r\n      \"--speed-dial-delay\": `${delay}ms`,\r\n      ...style,\r\n    }),\r\n    [delay, style],\r\n  );\r\n\r\n  const ItemPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <SpeedDialItemContext.Provider value={contextValue}>\r\n      <ItemPrimitive\r\n        role=\"none\"\r\n        data-slot=\"speed-dial-item\"\r\n        data-state={getDataState(open)}\r\n        data-side={side}\r\n        {...itemProps}\r\n        className={cn(speedDialItemVariants({ side, className }))}\r\n        style={itemStyle}\r\n      >\r\n        {children}\r\n      </ItemPrimitive>\r\n    </SpeedDialItemContext.Provider>\r\n  );\r\n}\r\n\r\ninterface SpeedDialActionProps\r\n  extends Omit<React.ComponentProps<typeof Button>, \"onSelect\"> {\r\n  onSelect?: (event: Event) => void;\r\n}\r\n\r\nfunction SpeedDialAction(props: SpeedDialActionProps) {\r\n  const {\r\n    onSelect,\r\n    onClick: onClickProp,\r\n    className,\r\n    disabled,\r\n    id,\r\n    ref,\r\n    ...actionProps\r\n  } = props;\r\n\r\n  const propsRef = useAsRef({\r\n    onClick: onClickProp,\r\n    onSelect,\r\n  });\r\n\r\n  const store = useStoreContext(ACTION_NAME);\r\n\r\n  const { onNodeRegister, onNodeUnregister } = useSpeedDialContext(ACTION_NAME);\r\n  const { actionId: itemActionId, labelId } =\r\n    useSpeedDialItemContext(ACTION_NAME);\r\n\r\n  const actionId = id ?? itemActionId;\r\n\r\n  const actionRef = React.useRef<ActionElement | null>(null);\r\n  const composedRefs = useComposedRefs(ref, actionRef);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    onNodeRegister({\r\n      id: actionId,\r\n      ref: actionRef,\r\n      disabled: !!disabled,\r\n    });\r\n\r\n    return () => {\r\n      onNodeUnregister(actionId);\r\n    };\r\n  }, [onNodeRegister, onNodeUnregister, actionId, disabled]);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<ActionElement>) => {\r\n      propsRef.current?.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const action = actionRef.current;\r\n      if (!action) return;\r\n\r\n      const actionSelectEvent = new CustomEvent(ACTION_SELECT, EVENT_OPTIONS);\r\n\r\n      action.addEventListener(\r\n        ACTION_SELECT,\r\n        (event) => propsRef.current?.onSelect?.(event),\r\n        {\r\n          once: true,\r\n        },\r\n      );\r\n\r\n      action.dispatchEvent(actionSelectEvent);\r\n      if (actionSelectEvent.defaultPrevented) return;\r\n\r\n      store.setState(\"open\", false);\r\n    },\r\n    [propsRef, store],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      role=\"menuitem\"\r\n      id={actionId}\r\n      aria-labelledby={labelId}\r\n      data-slot=\"speed-dial-action\"\r\n      variant=\"outline\"\r\n      size=\"icon\"\r\n      disabled={disabled}\r\n      ref={composedRefs}\r\n      {...actionProps}\r\n      className={cn(\r\n        \"size-11 shrink-0 rounded-full bg-accent shadow-md\",\r\n        className,\r\n      )}\r\n      onClick={onClick}\r\n    />\r\n  );\r\n}\r\n\r\nfunction SpeedDialLabel({ asChild, className, ...props }: DivProps) {\r\n  const { labelId } = useSpeedDialItemContext(LABEL_NAME);\r\n\r\n  const LabelPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <LabelPrimitive\r\n      id={labelId}\r\n      data-slot=\"speed-dial-label\"\r\n      {...props}\r\n      className={cn(\r\n        \"pointer-events-none whitespace-nowrap rounded-md bg-popover px-2 py-1 text-popover-foreground text-sm shadow-md\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  SpeedDial,\r\n  SpeedDialTrigger,\r\n  SpeedDialContent,\r\n  SpeedDialItem,\r\n  SpeedDialAction,\r\n  SpeedDialLabel,\r\n  //\r\n  type SpeedDialProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}