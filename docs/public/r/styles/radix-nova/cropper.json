{
  "name": "cropper",
  "dependencies": [
    "radix-ui"
  ],
  "registryDependencies": [
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/cropper.tsx",
      "content": "\"use client\";\r\n\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\nimport { Slot as SlotPrimitive } from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"Cropper\";\r\nconst ROOT_IMPL_NAME = \"CropperImpl\";\r\nconst IMAGE_NAME = \"CropperImage\";\r\nconst VIDEO_NAME = \"CropperVideo\";\r\nconst AREA_NAME = \"CropperArea\";\r\n\r\ninterface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface GestureEvent extends UIEvent {\r\n  rotation: number;\r\n  scale: number;\r\n  clientX: number;\r\n  clientY: number;\r\n}\r\n\r\ninterface Size {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\ninterface Area {\r\n  width: number;\r\n  height: number;\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface MediaSize {\r\n  width: number;\r\n  height: number;\r\n  naturalWidth: number;\r\n  naturalHeight: number;\r\n}\r\n\r\ntype Shape = \"rectangle\" | \"circle\";\r\ntype ObjectFit = \"contain\" | \"cover\" | \"horizontal-cover\" | \"vertical-cover\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst MAX_CACHE_SIZE = 200;\r\nconst DPR = typeof window !== \"undefined\" ? window.devicePixelRatio || 1 : 1;\r\n\r\nconst rotationSizeCache = new Map<string, Size>();\r\nconst cropSizeCache = new Map<string, Size>();\r\nconst croppedAreaCache = new Map<\r\n  string,\r\n  { croppedAreaPercentages: Area; croppedAreaPixels: Area }\r\n>();\r\nconst onPositionClampCache = new Map<string, Point>();\r\n\r\nfunction clamp(value: number, min: number, max: number): number {\r\n  return Math.min(Math.max(value, min), max);\r\n}\r\n\r\nfunction quantize(n: number, step = 2 / DPR): number {\r\n  return Math.round(n / step) * step;\r\n}\r\n\r\nfunction quantizePosition(n: number, step = 4 / DPR): number {\r\n  return Math.round(n / step) * step;\r\n}\r\n\r\nfunction quantizeZoom(n: number, step = 0.01): number {\r\n  return Math.round(n / step) * step;\r\n}\r\n\r\nfunction quantizeRotation(n: number, step = 1.0): number {\r\n  return Math.round(n / step) * step;\r\n}\r\n\r\nfunction snapToDevicePixel(n: number): number {\r\n  return Math.round(n * DPR) / DPR;\r\n}\r\n\r\nfunction lruGet<K, V>(map: Map<K, V>, key: K): V | undefined {\r\n  const v = map.get(key);\r\n  if (v !== undefined) {\r\n    map.delete(key);\r\n    map.set(key, v);\r\n  }\r\n  return v;\r\n}\r\n\r\nfunction lruSet<K, V>(\r\n  map: Map<K, V>,\r\n  key: K,\r\n  val: V,\r\n  max = MAX_CACHE_SIZE,\r\n): void {\r\n  if (map.has(key)) {\r\n    map.delete(key);\r\n  }\r\n  map.set(key, val);\r\n  if (map.size > max) {\r\n    const firstKey = map.keys().next().value;\r\n    if (firstKey !== undefined) {\r\n      map.delete(firstKey);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getDistanceBetweenPoints(pointA: Point, pointB: Point): number {\r\n  return Math.sqrt((pointA.y - pointB.y) ** 2 + (pointA.x - pointB.x) ** 2);\r\n}\r\n\r\nfunction getCenter(a: Point, b: Point): Point {\r\n  return {\r\n    x: (b.x + a.x) * 0.5,\r\n    y: (b.y + a.y) * 0.5,\r\n  };\r\n}\r\n\r\nfunction getRotationBetweenPoints(pointA: Point, pointB: Point): number {\r\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI;\r\n}\r\n\r\nfunction getRadianAngle(degreeValue: number): number {\r\n  return (degreeValue * Math.PI) / 180;\r\n}\r\n\r\nfunction rotateSize(width: number, height: number, rotation: number): Size {\r\n  const cacheKey = `${quantize(width)}-${quantize(height)}-${quantizeRotation(rotation)}`;\r\n\r\n  const cached = lruGet(rotationSizeCache, cacheKey);\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n  const rotRad = getRadianAngle(rotation);\r\n  const cosRot = Math.cos(rotRad);\r\n  const sinRot = Math.sin(rotRad);\r\n\r\n  const result: Size = {\r\n    width: Math.abs(cosRot * width) + Math.abs(sinRot * height),\r\n    height: Math.abs(sinRot * width) + Math.abs(cosRot * height),\r\n  };\r\n\r\n  lruSet(rotationSizeCache, cacheKey, result, MAX_CACHE_SIZE);\r\n  return result;\r\n}\r\n\r\nfunction getCropSize(\r\n  mediaWidth: number,\r\n  mediaHeight: number,\r\n  contentWidth: number,\r\n  contentHeight: number,\r\n  aspect: number,\r\n  rotation = 0,\r\n): Size {\r\n  const cacheKey = `${quantize(mediaWidth, 8)}-${quantize(mediaHeight, 8)}-${quantize(contentWidth, 8)}-${quantize(contentHeight, 8)}-${quantize(aspect, 0.01)}-${quantizeRotation(rotation)}`;\r\n\r\n  const cached = lruGet(cropSizeCache, cacheKey);\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n  const { width, height } = rotateSize(mediaWidth, mediaHeight, rotation);\r\n  const fittingWidth = Math.min(width, contentWidth);\r\n  const fittingHeight = Math.min(height, contentHeight);\r\n\r\n  const result: Size =\r\n    fittingWidth > fittingHeight * aspect\r\n      ? {\r\n          width: fittingHeight * aspect,\r\n          height: fittingHeight,\r\n        }\r\n      : {\r\n          width: fittingWidth,\r\n          height: fittingWidth / aspect,\r\n        };\r\n\r\n  lruSet(cropSizeCache, cacheKey, result, MAX_CACHE_SIZE);\r\n  return result;\r\n}\r\n\r\nfunction onPositionClamp(\r\n  position: Point,\r\n  mediaSize: Size,\r\n  cropSize: Size,\r\n  zoom: number,\r\n  rotation = 0,\r\n): Point {\r\n  const quantizedX = quantizePosition(position.x);\r\n  const quantizedY = quantizePosition(position.y);\r\n\r\n  const cacheKey = `${quantizedX}-${quantizedY}-${quantize(mediaSize.width)}-${quantize(mediaSize.height)}-${quantize(cropSize.width)}-${quantize(cropSize.height)}-${quantizeZoom(zoom)}-${quantizeRotation(rotation)}`;\r\n\r\n  const cached = lruGet(onPositionClampCache, cacheKey);\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n  const { width, height } = rotateSize(\r\n    mediaSize.width,\r\n    mediaSize.height,\r\n    rotation,\r\n  );\r\n\r\n  const maxPositionX = width * zoom * 0.5 - cropSize.width * 0.5;\r\n  const maxPositionY = height * zoom * 0.5 - cropSize.height * 0.5;\r\n\r\n  const result: Point = {\r\n    x: clamp(position.x, -maxPositionX, maxPositionX),\r\n    y: clamp(position.y, -maxPositionY, maxPositionY),\r\n  };\r\n\r\n  lruSet(onPositionClampCache, cacheKey, result, MAX_CACHE_SIZE);\r\n  return result;\r\n}\r\n\r\nfunction getCroppedArea(\r\n  crop: Point,\r\n  mediaSize: MediaSize,\r\n  cropSize: Size,\r\n  aspect: number,\r\n  zoom: number,\r\n  rotation = 0,\r\n  allowOverflow = false,\r\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\r\n  const cacheKey = `${quantizePosition(crop.x)}-${quantizePosition(crop.y)}-${quantize(mediaSize.width)}-${quantize(mediaSize.height)}-${quantize(mediaSize.naturalWidth)}-${quantize(mediaSize.naturalHeight)}-${quantize(cropSize.width)}-${quantize(cropSize.height)}-${quantize(aspect, 0.01)}-${quantizeZoom(zoom)}-${quantizeRotation(rotation)}-${allowOverflow}`;\r\n\r\n  const cached = lruGet(croppedAreaCache, cacheKey);\r\n\r\n  if (cached) return cached;\r\n\r\n  const onAreaLimit = !allowOverflow\r\n    ? (max: number, value: number) => Math.min(max, Math.max(0, value))\r\n    : (_max: number, value: number) => value;\r\n\r\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);\r\n  const mediaNaturalBBoxSize = rotateSize(\r\n    mediaSize.naturalWidth,\r\n    mediaSize.naturalHeight,\r\n    rotation,\r\n  );\r\n\r\n  const croppedAreaPercentages: Area = {\r\n    x: onAreaLimit(\r\n      100,\r\n      (((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) /\r\n        mediaBBoxSize.width) *\r\n        100,\r\n    ),\r\n    y: onAreaLimit(\r\n      100,\r\n      (((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) /\r\n        mediaBBoxSize.height) *\r\n        100,\r\n    ),\r\n    width: onAreaLimit(\r\n      100,\r\n      ((cropSize.width / mediaBBoxSize.width) * 100) / zoom,\r\n    ),\r\n    height: onAreaLimit(\r\n      100,\r\n      ((cropSize.height / mediaBBoxSize.height) * 100) / zoom,\r\n    ),\r\n  };\r\n\r\n  const widthInPixels = Math.round(\r\n    onAreaLimit(\r\n      mediaNaturalBBoxSize.width,\r\n      (croppedAreaPercentages.width * mediaNaturalBBoxSize.width) / 100,\r\n    ),\r\n  );\r\n  const heightInPixels = Math.round(\r\n    onAreaLimit(\r\n      mediaNaturalBBoxSize.height,\r\n      (croppedAreaPercentages.height * mediaNaturalBBoxSize.height) / 100,\r\n    ),\r\n  );\r\n  const isImageWiderThanHigh =\r\n    mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect;\r\n\r\n  const sizePixels: Size = isImageWiderThanHigh\r\n    ? {\r\n        width: Math.round(heightInPixels * aspect),\r\n        height: heightInPixels,\r\n      }\r\n    : {\r\n        width: widthInPixels,\r\n        height: Math.round(widthInPixels / aspect),\r\n      };\r\n\r\n  const croppedAreaPixels: Area = {\r\n    ...sizePixels,\r\n    x: Math.round(\r\n      onAreaLimit(\r\n        mediaNaturalBBoxSize.width - sizePixels.width,\r\n        (croppedAreaPercentages.x * mediaNaturalBBoxSize.width) / 100,\r\n      ),\r\n    ),\r\n    y: Math.round(\r\n      onAreaLimit(\r\n        mediaNaturalBBoxSize.height - sizePixels.height,\r\n        (croppedAreaPercentages.y * mediaNaturalBBoxSize.height) / 100,\r\n      ),\r\n    ),\r\n  };\r\n\r\n  const result = { croppedAreaPercentages, croppedAreaPixels };\r\n\r\n  lruSet(croppedAreaCache, cacheKey, result, MAX_CACHE_SIZE);\r\n  return result;\r\n}\r\n\r\ninterface StoreState {\r\n  crop: Point;\r\n  zoom: number;\r\n  rotation: number;\r\n  mediaSize: MediaSize | null;\r\n  cropSize: Size | null;\r\n  isDragging: boolean;\r\n  isWheelZooming: boolean;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  notify: () => void;\r\n  batch: (fn: () => void) => void;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: StoreState) => T): T {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof CropperImpl>;\r\n\r\ninterface CropperContextValue {\r\n  aspectRatio: number;\r\n  minZoom: number;\r\n  maxZoom: number;\r\n  zoomSpeed: number;\r\n  keyboardStep: number;\r\n  shape: Shape;\r\n  objectFit: ObjectFit;\r\n  rootRef: React.RefObject<RootElement | null>;\r\n  allowOverflow: boolean;\r\n  preventScrollZoom: boolean;\r\n  withGrid: boolean;\r\n}\r\n\r\nconst CropperContext = React.createContext<CropperContextValue | null>(null);\r\n\r\nfunction useCropperContext(consumerName: string) {\r\n  const context = React.useContext(CropperContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface CropperProps extends DivProps {\r\n  crop?: Point;\r\n  zoom?: number;\r\n  minZoom?: number;\r\n  maxZoom?: number;\r\n  zoomSpeed?: number;\r\n  rotation?: number;\r\n  keyboardStep?: number;\r\n  aspectRatio?: number;\r\n  shape?: Shape;\r\n  objectFit?: ObjectFit;\r\n  allowOverflow?: boolean;\r\n  preventScrollZoom?: boolean;\r\n  withGrid?: boolean;\r\n  onCropChange?: (crop: Point) => void;\r\n  onCropSizeChange?: (cropSize: Size) => void;\r\n  onCropAreaChange?: (croppedArea: Area, croppedAreaPixels: Area) => void;\r\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void;\r\n  onZoomChange?: (zoom: number) => void;\r\n  onRotationChange?: (rotation: number) => void;\r\n  onMediaLoaded?: (mediaSize: MediaSize) => void;\r\n  onInteractionStart?: () => void;\r\n  onInteractionEnd?: () => void;\r\n  onWheelZoom?: (event: WheelEvent) => void;\r\n}\r\n\r\nfunction Cropper(props: CropperProps) {\r\n  const {\r\n    crop = { x: 0, y: 0 },\r\n    zoom = 1,\r\n    minZoom = 1,\r\n    maxZoom = 3,\r\n    zoomSpeed = 1,\r\n    rotation = 0,\r\n    keyboardStep = 1,\r\n    aspectRatio = 4 / 3,\r\n    shape = \"rectangle\",\r\n    objectFit = \"contain\",\r\n    allowOverflow = false,\r\n    preventScrollZoom = false,\r\n    withGrid = false,\r\n    onCropChange,\r\n    onCropSizeChange,\r\n    onCropAreaChange,\r\n    onCropComplete,\r\n    onZoomChange,\r\n    onRotationChange,\r\n    onMediaLoaded,\r\n    onInteractionStart,\r\n    onInteractionEnd,\r\n    className,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    crop,\r\n    zoom,\r\n    rotation,\r\n    mediaSize: null,\r\n    cropSize: null,\r\n    isDragging: false,\r\n    isWheelZooming: false,\r\n  }));\r\n\r\n  const propsRef = useAsRef({\r\n    onCropChange,\r\n    onCropSizeChange,\r\n    onCropAreaChange,\r\n    onCropComplete,\r\n    onZoomChange,\r\n    onRotationChange,\r\n    onMediaLoaded,\r\n    onInteractionStart,\r\n    onInteractionEnd,\r\n  });\r\n\r\n  const rootRef = React.useRef<RootElement | null>(null);\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    let isBatching = false;\r\n    let raf: number | null = null;\r\n\r\n    function notifyCropAreaChange() {\r\n      if (raf != null) return;\r\n      raf = requestAnimationFrame(() => {\r\n        raf = null;\r\n        const s = stateRef.current;\r\n        if (s?.mediaSize && s.cropSize && propsRef.current.onCropAreaChange) {\r\n          const { croppedAreaPercentages, croppedAreaPixels } = getCroppedArea(\r\n            s.crop,\r\n            s.mediaSize,\r\n            s.cropSize,\r\n            aspectRatio,\r\n            s.zoom,\r\n            s.rotation,\r\n          );\r\n          propsRef.current.onCropAreaChange(\r\n            croppedAreaPercentages,\r\n            croppedAreaPixels,\r\n          );\r\n        }\r\n      });\r\n    }\r\n\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n\r\n        stateRef.current[key] = value;\r\n\r\n        if (\r\n          key === \"crop\" &&\r\n          typeof value === \"object\" &&\r\n          value &&\r\n          \"x\" in value\r\n        ) {\r\n          propsRef.current.onCropChange?.(value);\r\n        } else if (key === \"zoom\" && typeof value === \"number\") {\r\n          propsRef.current.onZoomChange?.(value);\r\n        } else if (key === \"rotation\" && typeof value === \"number\") {\r\n          propsRef.current.onRotationChange?.(value);\r\n        } else if (\r\n          key === \"cropSize\" &&\r\n          typeof value === \"object\" &&\r\n          value &&\r\n          \"width\" in value\r\n        ) {\r\n          propsRef.current.onCropSizeChange?.(value);\r\n        } else if (\r\n          key === \"mediaSize\" &&\r\n          typeof value === \"object\" &&\r\n          value &&\r\n          \"naturalWidth\" in value\r\n        ) {\r\n          propsRef.current.onMediaLoaded?.(value);\r\n        } else if (key === \"isDragging\") {\r\n          if (value) {\r\n            propsRef.current.onInteractionStart?.();\r\n          } else {\r\n            propsRef.current.onInteractionEnd?.();\r\n            const currentState = stateRef.current;\r\n            if (\r\n              currentState?.mediaSize &&\r\n              currentState.cropSize &&\r\n              propsRef.current.onCropComplete\r\n            ) {\r\n              const { croppedAreaPercentages, croppedAreaPixels } =\r\n                getCroppedArea(\r\n                  currentState.crop,\r\n                  currentState.mediaSize,\r\n                  currentState.cropSize,\r\n                  aspectRatio,\r\n                  currentState.zoom,\r\n                  currentState.rotation,\r\n                );\r\n              propsRef.current.onCropComplete(\r\n                croppedAreaPercentages,\r\n                croppedAreaPixels,\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        if (\r\n          (key === \"crop\" ||\r\n            key === \"zoom\" ||\r\n            key === \"rotation\" ||\r\n            key === \"mediaSize\" ||\r\n            key === \"cropSize\") &&\r\n          propsRef.current.onCropAreaChange\r\n        ) {\r\n          notifyCropAreaChange();\r\n        }\r\n\r\n        if (!isBatching) {\r\n          store.notify();\r\n        }\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n      batch: (fn: () => void) => {\r\n        if (isBatching) {\r\n          fn();\r\n          return;\r\n        }\r\n        isBatching = true;\r\n        try {\r\n          fn();\r\n        } finally {\r\n          isBatching = false;\r\n          store.notify();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef, aspectRatio]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const updates: Partial<StoreState> = {};\r\n    let hasUpdates = false;\r\n    let shouldRecompute = false;\r\n\r\n    if (crop !== undefined) {\r\n      const currentState = store.getState();\r\n      if (!Object.is(currentState.crop, crop)) {\r\n        updates.crop = crop;\r\n        hasUpdates = true;\r\n      }\r\n    }\r\n\r\n    if (zoom !== undefined) {\r\n      const currentState = store.getState();\r\n      if (currentState.zoom !== zoom) {\r\n        updates.zoom = zoom;\r\n        hasUpdates = true;\r\n        shouldRecompute = true;\r\n      }\r\n    }\r\n\r\n    if (rotation !== undefined) {\r\n      const currentState = store.getState();\r\n      if (currentState.rotation !== rotation) {\r\n        updates.rotation = rotation;\r\n        hasUpdates = true;\r\n        shouldRecompute = true;\r\n      }\r\n    }\r\n\r\n    if (hasUpdates) {\r\n      store.batch(() => {\r\n        Object.entries(updates).forEach(([key, value]) => {\r\n          store.setState(key as keyof StoreState, value);\r\n        });\r\n      });\r\n\r\n      if (shouldRecompute && rootRef.current) {\r\n        requestAnimationFrame(() => {\r\n          const currentState = store.getState();\r\n          if (currentState.cropSize && currentState.mediaSize) {\r\n            const newPosition = !allowOverflow\r\n              ? onPositionClamp(\r\n                  currentState.crop,\r\n                  currentState.mediaSize,\r\n                  currentState.cropSize,\r\n                  currentState.zoom,\r\n                  currentState.rotation,\r\n                )\r\n              : currentState.crop;\r\n\r\n            if (\r\n              Math.abs(newPosition.x - currentState.crop.x) > 0.001 ||\r\n              Math.abs(newPosition.y - currentState.crop.y) > 0.001\r\n            ) {\r\n              store.setState(\"crop\", newPosition);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }, [crop, zoom, rotation, store, allowOverflow]);\r\n\r\n  const contextValue = React.useMemo<CropperContextValue>(\r\n    () => ({\r\n      minZoom,\r\n      maxZoom,\r\n      zoomSpeed,\r\n      keyboardStep,\r\n      aspectRatio,\r\n      shape,\r\n      objectFit,\r\n      preventScrollZoom,\r\n      allowOverflow,\r\n      withGrid,\r\n      rootRef,\r\n    }),\r\n    [\r\n      minZoom,\r\n      maxZoom,\r\n      zoomSpeed,\r\n      keyboardStep,\r\n      aspectRatio,\r\n      shape,\r\n      objectFit,\r\n      preventScrollZoom,\r\n      allowOverflow,\r\n      withGrid,\r\n    ],\r\n  );\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <CropperContext.Provider value={contextValue}>\r\n        <div\r\n          data-slot=\"cropper-wrapper\"\r\n          className={cn(\"relative size-full overflow-hidden\", className)}\r\n        >\r\n          <CropperImpl {...rootProps} />\r\n        </div>\r\n      </CropperContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface CropperImplProps extends CropperProps {\r\n  onWheelZoom?: (event: WheelEvent) => void;\r\n}\r\n\r\nfunction CropperImpl(props: CropperImplProps) {\r\n  const {\r\n    onWheelZoom: onWheelZoomProp,\r\n    onKeyUp: onKeyUpProp,\r\n    onKeyDown: onKeyDownProp,\r\n    onMouseDown: onMouseDownProp,\r\n    onTouchStart: onTouchStartProp,\r\n    asChild,\r\n    className,\r\n    ref,\r\n    ...rootImplProps\r\n  } = props;\r\n\r\n  const context = useCropperContext(ROOT_IMPL_NAME);\r\n  const store = useStoreContext(ROOT_IMPL_NAME);\r\n  const crop = useStore((state) => state.crop);\r\n  const zoom = useStore((state) => state.zoom);\r\n  const rotation = useStore((state) => state.rotation);\r\n  const mediaSize = useStore((state) => state.mediaSize);\r\n  const cropSize = useStore((state) => state.cropSize);\r\n\r\n  const propsRef = useAsRef({\r\n    onWheelZoom: onWheelZoomProp,\r\n    onKeyUp: onKeyUpProp,\r\n    onKeyDown: onKeyDownProp,\r\n    onMouseDown: onMouseDownProp,\r\n    onTouchStart: onTouchStartProp,\r\n  });\r\n\r\n  const composedRef = useComposedRefs(ref, context.rootRef);\r\n  const dragStartPositionRef = React.useRef<Point>({ x: 0, y: 0 });\r\n  const dragStartCropRef = React.useRef<Point>({ x: 0, y: 0 });\r\n  const contentPositionRef = React.useRef<Point>({ x: 0, y: 0 });\r\n  const lastPinchDistanceRef = React.useRef(0);\r\n  const lastPinchRotationRef = React.useRef(0);\r\n  const rafDragTimeoutRef = React.useRef<number | null>(null);\r\n  const rafPinchTimeoutRef = React.useRef<number | null>(null);\r\n  const wheelTimerRef = React.useRef<number | null>(null);\r\n  const isTouchingRef = React.useRef(false);\r\n  const gestureZoomStartRef = React.useRef(0);\r\n  const gestureRotationStartRef = React.useRef(0);\r\n\r\n  const onRefsCleanup = React.useCallback(() => {\r\n    if (rafDragTimeoutRef.current) {\r\n      cancelAnimationFrame(rafDragTimeoutRef.current);\r\n      rafDragTimeoutRef.current = null;\r\n    }\r\n    if (rafPinchTimeoutRef.current) {\r\n      cancelAnimationFrame(rafPinchTimeoutRef.current);\r\n      rafPinchTimeoutRef.current = null;\r\n    }\r\n    if (wheelTimerRef.current) {\r\n      clearTimeout(wheelTimerRef.current);\r\n      wheelTimerRef.current = null;\r\n    }\r\n    isTouchingRef.current = false;\r\n  }, []);\r\n\r\n  const onCacheCleanup = React.useCallback(() => {\r\n    if (onPositionClampCache.size > MAX_CACHE_SIZE * 1.5) {\r\n      onPositionClampCache.clear();\r\n    }\r\n    if (croppedAreaCache.size > MAX_CACHE_SIZE * 1.5) {\r\n      croppedAreaCache.clear();\r\n    }\r\n  }, []);\r\n\r\n  const getMousePoint = React.useCallback(\r\n    (event: MouseEvent | React.MouseEvent) => ({\r\n      x: Number(event.clientX),\r\n      y: Number(event.clientY),\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const getTouchPoint = React.useCallback(\r\n    (touch: Touch | React.Touch) => ({\r\n      x: Number(touch.clientX),\r\n      y: Number(touch.clientY),\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const onContentPositionChange = React.useCallback(() => {\r\n    if (context.rootRef?.current) {\r\n      const bounds = context.rootRef.current.getBoundingClientRect();\r\n      contentPositionRef.current = { x: bounds.left, y: bounds.top };\r\n    }\r\n  }, [context.rootRef]);\r\n\r\n  const getPointOnContent = React.useCallback(\r\n    ({ x, y }: Point, contentTopLeft: Point): Point => {\r\n      if (!context.rootRef?.current) {\r\n        return { x: 0, y: 0 };\r\n      }\r\n      const contentRect = context.rootRef.current.getBoundingClientRect();\r\n      return {\r\n        x: contentRect.width / 2 - (x - contentTopLeft.x),\r\n        y: contentRect.height / 2 - (y - contentTopLeft.y),\r\n      };\r\n    },\r\n    [context.rootRef],\r\n  );\r\n\r\n  const getPointOnMedia = React.useCallback(\r\n    ({ x, y }: Point) => {\r\n      return {\r\n        x: (x + crop.x) / zoom,\r\n        y: (y + crop.y) / zoom,\r\n      };\r\n    },\r\n    [crop, zoom],\r\n  );\r\n\r\n  const recomputeCropPosition = React.useCallback(() => {\r\n    if (!cropSize || !mediaSize) return;\r\n\r\n    const newPosition = !context.allowOverflow\r\n      ? onPositionClamp(crop, mediaSize, cropSize, zoom, rotation)\r\n      : crop;\r\n\r\n    if (\r\n      Math.abs(newPosition.x - crop.x) > 0.001 ||\r\n      Math.abs(newPosition.y - crop.y) > 0.001\r\n    ) {\r\n      store.setState(\"crop\", newPosition);\r\n    }\r\n  }, [cropSize, mediaSize, context.allowOverflow, crop, zoom, rotation, store]);\r\n\r\n  const onZoomChange = React.useCallback(\r\n    (newZoom: number, point: Point, shouldUpdatePosition = true) => {\r\n      if (!cropSize || !mediaSize) return;\r\n\r\n      const clampedZoom = clamp(newZoom, context.minZoom, context.maxZoom);\r\n\r\n      store.batch(() => {\r\n        if (shouldUpdatePosition) {\r\n          const zoomPoint = getPointOnContent(\r\n            point,\r\n            contentPositionRef.current,\r\n          );\r\n          const zoomTarget = getPointOnMedia(zoomPoint);\r\n          const requestedPosition = {\r\n            x: zoomTarget.x * clampedZoom - zoomPoint.x,\r\n            y: zoomTarget.y * clampedZoom - zoomPoint.y,\r\n          };\r\n\r\n          const newPosition = !context.allowOverflow\r\n            ? onPositionClamp(\r\n                requestedPosition,\r\n                mediaSize,\r\n                cropSize,\r\n                clampedZoom,\r\n                rotation,\r\n              )\r\n            : requestedPosition;\r\n\r\n          store.setState(\"crop\", newPosition);\r\n        }\r\n        store.setState(\"zoom\", clampedZoom);\r\n      });\r\n\r\n      requestAnimationFrame(() => {\r\n        recomputeCropPosition();\r\n      });\r\n    },\r\n    [\r\n      cropSize,\r\n      mediaSize,\r\n      context.minZoom,\r\n      context.maxZoom,\r\n      context.allowOverflow,\r\n      getPointOnContent,\r\n      getPointOnMedia,\r\n      rotation,\r\n      store,\r\n      recomputeCropPosition,\r\n    ],\r\n  );\r\n\r\n  const onDragStart = React.useCallback(\r\n    ({ x, y }: Point) => {\r\n      dragStartPositionRef.current = { x, y };\r\n      dragStartCropRef.current = { ...crop };\r\n      store.setState(\"isDragging\", true);\r\n    },\r\n    [crop, store],\r\n  );\r\n\r\n  const onDrag = React.useCallback(\r\n    ({ x, y }: Point) => {\r\n      if (rafDragTimeoutRef.current) {\r\n        cancelAnimationFrame(rafDragTimeoutRef.current);\r\n      }\r\n\r\n      rafDragTimeoutRef.current = requestAnimationFrame(() => {\r\n        if (!cropSize || !mediaSize) return;\r\n        if (x === undefined || y === undefined) return;\r\n\r\n        const offsetX = x - dragStartPositionRef.current.x;\r\n        const offsetY = y - dragStartPositionRef.current.y;\r\n\r\n        if (Math.abs(offsetX) < 2 && Math.abs(offsetY) < 2) {\r\n          return;\r\n        }\r\n\r\n        const requestedPosition = {\r\n          x: dragStartCropRef.current.x + offsetX,\r\n          y: dragStartCropRef.current.y + offsetY,\r\n        };\r\n\r\n        const newPosition = !context.allowOverflow\r\n          ? onPositionClamp(\r\n              requestedPosition,\r\n              mediaSize,\r\n              cropSize,\r\n              zoom,\r\n              rotation,\r\n            )\r\n          : requestedPosition;\r\n\r\n        const currentCrop = store.getState().crop;\r\n        if (\r\n          Math.abs(newPosition.x - currentCrop.x) > 1 ||\r\n          Math.abs(newPosition.y - currentCrop.y) > 1\r\n        ) {\r\n          store.setState(\"crop\", newPosition);\r\n        }\r\n      });\r\n    },\r\n    [cropSize, mediaSize, context.allowOverflow, zoom, rotation, store],\r\n  );\r\n\r\n  const onMouseMove = React.useCallback(\r\n    (event: MouseEvent) => onDrag(getMousePoint(event)),\r\n    [getMousePoint, onDrag],\r\n  );\r\n\r\n  const onTouchMove = React.useCallback(\r\n    (event: TouchEvent) => {\r\n      event.preventDefault();\r\n      if (event.touches.length === 2) {\r\n        const [firstTouch, secondTouch] = event.touches ?? [];\r\n        if (firstTouch && secondTouch) {\r\n          const pointA = getTouchPoint(firstTouch);\r\n          const pointB = getTouchPoint(secondTouch);\r\n          const center = getCenter(pointA, pointB);\r\n          onDrag(center);\r\n\r\n          if (rafPinchTimeoutRef.current) {\r\n            cancelAnimationFrame(rafPinchTimeoutRef.current);\r\n          }\r\n\r\n          rafPinchTimeoutRef.current = requestAnimationFrame(() => {\r\n            const distance = getDistanceBetweenPoints(pointA, pointB);\r\n            const distanceRatio = distance / lastPinchDistanceRef.current;\r\n\r\n            if (Math.abs(distanceRatio - 1) > 0.01) {\r\n              const newZoom = zoom * distanceRatio;\r\n              onZoomChange(newZoom, center, false);\r\n              lastPinchDistanceRef.current = distance;\r\n            }\r\n\r\n            const rotationAngle = getRotationBetweenPoints(pointA, pointB);\r\n            const rotationDiff = rotationAngle - lastPinchRotationRef.current;\r\n\r\n            if (Math.abs(rotationDiff) > 0.5) {\r\n              const newRotation = rotation + rotationDiff;\r\n              store.setState(\"rotation\", newRotation);\r\n              lastPinchRotationRef.current = rotationAngle;\r\n            }\r\n          });\r\n        }\r\n      } else if (event.touches.length === 1) {\r\n        const firstTouch = event.touches[0];\r\n        if (firstTouch) {\r\n          onDrag(getTouchPoint(firstTouch));\r\n        }\r\n      }\r\n    },\r\n    [getTouchPoint, onDrag, zoom, onZoomChange, rotation, store],\r\n  );\r\n\r\n  const onGestureChange = React.useCallback(\r\n    (event: GestureEvent) => {\r\n      event.preventDefault();\r\n      if (isTouchingRef.current) {\r\n        return;\r\n      }\r\n\r\n      const point = { x: Number(event.clientX), y: Number(event.clientY) };\r\n      const newZoom = gestureZoomStartRef.current - 1 + event.scale;\r\n      onZoomChange(newZoom, point, true);\r\n\r\n      const newRotation = gestureRotationStartRef.current + event.rotation;\r\n      store.setState(\"rotation\", newRotation);\r\n    },\r\n    [onZoomChange, store],\r\n  );\r\n\r\n  const onGestureEnd = React.useCallback(() => {\r\n    document.removeEventListener(\r\n      \"gesturechange\",\r\n      onGestureChange as EventListener,\r\n    );\r\n    document.removeEventListener(\"gestureend\", onGestureEnd as EventListener);\r\n  }, [onGestureChange]);\r\n\r\n  const onGestureStart = React.useCallback(\r\n    (event: GestureEvent) => {\r\n      event.preventDefault();\r\n      document.addEventListener(\r\n        \"gesturechange\",\r\n        onGestureChange as EventListener,\r\n      );\r\n      document.addEventListener(\"gestureend\", onGestureEnd as EventListener);\r\n      gestureZoomStartRef.current = zoom;\r\n      gestureRotationStartRef.current = rotation;\r\n    },\r\n    [zoom, rotation, onGestureChange, onGestureEnd],\r\n  );\r\n\r\n  const onSafariZoomPrevent = React.useCallback(\r\n    (event: Event) => event.preventDefault(),\r\n    [],\r\n  );\r\n\r\n  const onEventsCleanup = React.useCallback(() => {\r\n    document.removeEventListener(\"mousemove\", onMouseMove);\r\n    document.removeEventListener(\"touchmove\", onTouchMove);\r\n    document.removeEventListener(\r\n      \"gesturechange\",\r\n      onGestureChange as EventListener,\r\n    );\r\n    document.removeEventListener(\"gestureend\", onGestureEnd as EventListener);\r\n  }, [onMouseMove, onTouchMove, onGestureChange, onGestureEnd]);\r\n\r\n  const onDragStopped = React.useCallback(() => {\r\n    isTouchingRef.current = false;\r\n    store.setState(\"isDragging\", false);\r\n    onRefsCleanup();\r\n    document.removeEventListener(\"mouseup\", onDragStopped);\r\n    document.removeEventListener(\"touchend\", onDragStopped);\r\n    onEventsCleanup();\r\n  }, [store, onEventsCleanup, onRefsCleanup]);\r\n\r\n  const getWheelDelta = React.useCallback((event: WheelEvent) => {\r\n    let deltaX = event.deltaX;\r\n    let deltaY = event.deltaY;\r\n    let deltaZ = event.deltaZ;\r\n\r\n    if (event.deltaMode === 1) {\r\n      deltaX *= 16;\r\n      deltaY *= 16;\r\n      deltaZ *= 16;\r\n    } else if (event.deltaMode === 2) {\r\n      deltaX *= 400;\r\n      deltaY *= 400;\r\n      deltaZ *= 400;\r\n    }\r\n\r\n    return { deltaX, deltaY, deltaZ };\r\n  }, []);\r\n\r\n  const onWheelZoom = React.useCallback(\r\n    (event: WheelEvent) => {\r\n      propsRef.current.onWheelZoom?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      event.preventDefault();\r\n      const point = getMousePoint(event);\r\n      const { deltaY } = getWheelDelta(event);\r\n      const newZoom = zoom - (deltaY * context.zoomSpeed) / 200;\r\n      onZoomChange(newZoom, point, true);\r\n\r\n      store.batch(() => {\r\n        const currentState = store.getState();\r\n        if (!currentState.isWheelZooming) {\r\n          store.setState(\"isWheelZooming\", true);\r\n        }\r\n        if (!currentState.isDragging) {\r\n          store.setState(\"isDragging\", true);\r\n        }\r\n      });\r\n\r\n      if (wheelTimerRef.current) {\r\n        clearTimeout(wheelTimerRef.current);\r\n      }\r\n      wheelTimerRef.current = window.setTimeout(() => {\r\n        store.batch(() => {\r\n          store.setState(\"isWheelZooming\", false);\r\n          store.setState(\"isDragging\", false);\r\n        });\r\n      }, 250);\r\n    },\r\n    [\r\n      propsRef,\r\n      getMousePoint,\r\n      zoom,\r\n      context.zoomSpeed,\r\n      onZoomChange,\r\n      getWheelDelta,\r\n      store,\r\n    ],\r\n  );\r\n\r\n  const onKeyUp = React.useCallback(\r\n    (event: React.KeyboardEvent<RootElement>) => {\r\n      propsRef.current.onKeyUp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const arrowKeys = new Set([\r\n        \"ArrowUp\",\r\n        \"ArrowDown\",\r\n        \"ArrowLeft\",\r\n        \"ArrowRight\",\r\n      ]);\r\n\r\n      if (arrowKeys.has(event.key)) {\r\n        event.preventDefault();\r\n        store.setState(\"isDragging\", false);\r\n      }\r\n    },\r\n    [propsRef, store],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<RootElement>) => {\r\n      propsRef.current.onKeyDown?.(event);\r\n      if (event.defaultPrevented || !cropSize || !mediaSize) return;\r\n\r\n      let step = context.keyboardStep;\r\n      if (event.shiftKey) {\r\n        step *= 0.2;\r\n      }\r\n\r\n      const keyCallbacks: Record<string, () => Point> = {\r\n        ArrowUp: () => ({ ...crop, y: crop.y - step }),\r\n        ArrowDown: () => ({ ...crop, y: crop.y + step }),\r\n        ArrowLeft: () => ({ ...crop, x: crop.x - step }),\r\n        ArrowRight: () => ({ ...crop, x: crop.x + step }),\r\n      } as const;\r\n\r\n      const callback = keyCallbacks[event.key];\r\n      if (!callback) return;\r\n\r\n      event.preventDefault();\r\n\r\n      let newCrop = callback();\r\n\r\n      if (!context.allowOverflow) {\r\n        newCrop = onPositionClamp(newCrop, mediaSize, cropSize, zoom, rotation);\r\n      }\r\n\r\n      if (!event.repeat) {\r\n        store.setState(\"isDragging\", true);\r\n      }\r\n\r\n      store.setState(\"crop\", newCrop);\r\n    },\r\n    [\r\n      propsRef,\r\n      cropSize,\r\n      mediaSize,\r\n      context.keyboardStep,\r\n      context.allowOverflow,\r\n      crop,\r\n      zoom,\r\n      rotation,\r\n      store,\r\n    ],\r\n  );\r\n\r\n  const onMouseDown = React.useCallback(\r\n    (event: React.MouseEvent<RootElement>) => {\r\n      propsRef.current.onMouseDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      event.preventDefault();\r\n      document.addEventListener(\"mousemove\", onMouseMove);\r\n      document.addEventListener(\"mouseup\", onDragStopped);\r\n      onContentPositionChange();\r\n      onDragStart(getMousePoint(event));\r\n    },\r\n    [\r\n      propsRef,\r\n      getMousePoint,\r\n      onDragStart,\r\n      onDragStopped,\r\n      onMouseMove,\r\n      onContentPositionChange,\r\n    ],\r\n  );\r\n\r\n  const onTouchStart = React.useCallback(\r\n    (event: React.TouchEvent<RootElement>) => {\r\n      propsRef.current.onTouchStart?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      isTouchingRef.current = true;\r\n      document.addEventListener(\"touchmove\", onTouchMove, { passive: false });\r\n      document.addEventListener(\"touchend\", onDragStopped);\r\n      onContentPositionChange();\r\n\r\n      if (event.touches.length === 2) {\r\n        const [firstTouch, secondTouch] = event.touches\r\n          ? Array.from(event.touches)\r\n          : [];\r\n        if (firstTouch && secondTouch) {\r\n          const pointA = getTouchPoint(firstTouch);\r\n          const pointB = getTouchPoint(secondTouch);\r\n          lastPinchDistanceRef.current = getDistanceBetweenPoints(\r\n            pointA,\r\n            pointB,\r\n          );\r\n          lastPinchRotationRef.current = getRotationBetweenPoints(\r\n            pointA,\r\n            pointB,\r\n          );\r\n          onDragStart(getCenter(pointA, pointB));\r\n        }\r\n      } else if (event.touches.length === 1) {\r\n        const firstTouch = event.touches[0];\r\n        if (firstTouch) {\r\n          onDragStart(getTouchPoint(firstTouch));\r\n        }\r\n      }\r\n    },\r\n    [\r\n      propsRef,\r\n      onDragStopped,\r\n      onTouchMove,\r\n      onContentPositionChange,\r\n      getTouchPoint,\r\n      onDragStart,\r\n    ],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    const content = context.rootRef?.current;\r\n    if (!content) return;\r\n\r\n    if (!context.preventScrollZoom) {\r\n      content.addEventListener(\"wheel\", onWheelZoom, { passive: false });\r\n    }\r\n\r\n    content.addEventListener(\"gesturestart\", onSafariZoomPrevent);\r\n    content.addEventListener(\"gesturestart\", onGestureStart as EventListener);\r\n\r\n    return () => {\r\n      if (!context.preventScrollZoom) {\r\n        content.removeEventListener(\"wheel\", onWheelZoom);\r\n      }\r\n      content.removeEventListener(\"gesturestart\", onSafariZoomPrevent);\r\n      content.removeEventListener(\r\n        \"gesturestart\",\r\n        onGestureStart as EventListener,\r\n      );\r\n      onRefsCleanup();\r\n    };\r\n  }, [\r\n    context.rootRef,\r\n    context.preventScrollZoom,\r\n    onWheelZoom,\r\n    onRefsCleanup,\r\n    onSafariZoomPrevent,\r\n    onGestureStart,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    return () => {\r\n      onRefsCleanup();\r\n      onCacheCleanup();\r\n    };\r\n  }, [onRefsCleanup, onCacheCleanup]);\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <RootPrimitive\r\n      data-slot=\"cropper\"\r\n      tabIndex={0}\r\n      {...rootImplProps}\r\n      ref={composedRef}\r\n      className={cn(\r\n        \"absolute inset-0 flex cursor-move touch-none select-none items-center justify-center overflow-hidden outline-none\",\r\n        className,\r\n      )}\r\n      onKeyUp={onKeyUp}\r\n      onKeyDown={onKeyDown}\r\n      onMouseDown={onMouseDown}\r\n      onTouchStart={onTouchStart}\r\n    />\r\n  );\r\n}\r\n\r\nconst cropperMediaVariants = cva(\"will-change-transform\", {\r\n  variants: {\r\n    objectFit: {\r\n      contain: \"absolute inset-0 m-auto max-h-full max-w-full\",\r\n      cover: \"h-auto w-full\",\r\n      \"horizontal-cover\": \"h-auto w-full\",\r\n      \"vertical-cover\": \"h-full w-auto\",\r\n    },\r\n  },\r\n  defaultVariants: {\r\n    objectFit: \"contain\",\r\n  },\r\n});\r\n\r\ninterface UseMediaComputationProps<\r\n  T extends HTMLImageElement | HTMLVideoElement,\r\n> {\r\n  mediaRef: React.RefObject<T | null>;\r\n  context: CropperContextValue;\r\n  store: Store;\r\n  rotation: number;\r\n  getNaturalDimensions: (media: T) => Size;\r\n}\r\n\r\nfunction useMediaComputation<T extends HTMLImageElement | HTMLVideoElement>({\r\n  mediaRef,\r\n  context,\r\n  store,\r\n  rotation,\r\n  getNaturalDimensions,\r\n}: UseMediaComputationProps<T>) {\r\n  const computeSizes = React.useCallback(() => {\r\n    const media = mediaRef.current;\r\n    const content = context.rootRef?.current;\r\n    if (!media || !content) return;\r\n\r\n    const contentRect = content.getBoundingClientRect();\r\n    const containerAspect = contentRect.width / contentRect.height;\r\n    const { width: naturalWidth, height: naturalHeight } =\r\n      getNaturalDimensions(media);\r\n    const isScaledDown =\r\n      media.offsetWidth < naturalWidth || media.offsetHeight < naturalHeight;\r\n    const mediaAspect = naturalWidth / naturalHeight;\r\n\r\n    let renderedMediaSize: Size;\r\n\r\n    if (isScaledDown) {\r\n      const objectFitCallbacks = {\r\n        contain: () =>\r\n          containerAspect > mediaAspect\r\n            ? {\r\n                width: contentRect.height * mediaAspect,\r\n                height: contentRect.height,\r\n              }\r\n            : {\r\n                width: contentRect.width,\r\n                height: contentRect.width / mediaAspect,\r\n              },\r\n        \"horizontal-cover\": () => ({\r\n          width: contentRect.width,\r\n          height: contentRect.width / mediaAspect,\r\n        }),\r\n        \"vertical-cover\": () => ({\r\n          width: contentRect.height * mediaAspect,\r\n          height: contentRect.height,\r\n        }),\r\n        cover: () =>\r\n          containerAspect < mediaAspect\r\n            ? {\r\n                width: contentRect.width,\r\n                height: contentRect.width / mediaAspect,\r\n              }\r\n            : {\r\n                width: contentRect.height * mediaAspect,\r\n                height: contentRect.height,\r\n              },\r\n      } as const;\r\n\r\n      const callback = objectFitCallbacks[context.objectFit];\r\n      renderedMediaSize = callback\r\n        ? callback()\r\n        : containerAspect > mediaAspect\r\n          ? {\r\n              width: contentRect.height * mediaAspect,\r\n              height: contentRect.height,\r\n            }\r\n          : {\r\n              width: contentRect.width,\r\n              height: contentRect.width / mediaAspect,\r\n            };\r\n    } else {\r\n      renderedMediaSize = {\r\n        width: media.offsetWidth,\r\n        height: media.offsetHeight,\r\n      };\r\n    }\r\n\r\n    const mediaSize: MediaSize = {\r\n      ...renderedMediaSize,\r\n      naturalWidth,\r\n      naturalHeight,\r\n    };\r\n\r\n    store.setState(\"mediaSize\", mediaSize);\r\n\r\n    const cropSize = getCropSize(\r\n      mediaSize.width,\r\n      mediaSize.height,\r\n      contentRect.width,\r\n      contentRect.height,\r\n      context.aspectRatio,\r\n      rotation,\r\n    );\r\n\r\n    store.setState(\"cropSize\", cropSize);\r\n\r\n    requestAnimationFrame(() => {\r\n      const currentState = store.getState();\r\n      if (currentState.cropSize && currentState.mediaSize) {\r\n        const newPosition = onPositionClamp(\r\n          currentState.crop,\r\n          currentState.mediaSize,\r\n          currentState.cropSize,\r\n          currentState.zoom,\r\n          currentState.rotation,\r\n        );\r\n\r\n        if (\r\n          Math.abs(newPosition.x - currentState.crop.x) > 0.001 ||\r\n          Math.abs(newPosition.y - currentState.crop.y) > 0.001\r\n        ) {\r\n          store.setState(\"crop\", newPosition);\r\n        }\r\n      }\r\n    });\r\n\r\n    return { mediaSize, cropSize };\r\n  }, [\r\n    mediaRef,\r\n    context.aspectRatio,\r\n    context.rootRef,\r\n    context.objectFit,\r\n    store,\r\n    rotation,\r\n    getNaturalDimensions,\r\n  ]);\r\n\r\n  return { computeSizes };\r\n}\r\n\r\ninterface CropperImageProps\r\n  extends React.ComponentProps<\"img\">,\r\n    VariantProps<typeof cropperMediaVariants> {\r\n  asChild?: boolean;\r\n  snapPixels?: boolean;\r\n}\r\n\r\nfunction CropperImage(props: CropperImageProps) {\r\n  const {\r\n    className,\r\n    style,\r\n    asChild,\r\n    ref,\r\n    onLoad,\r\n    objectFit,\r\n    snapPixels = false,\r\n    ...imageProps\r\n  } = props;\r\n\r\n  const context = useCropperContext(IMAGE_NAME);\r\n  const store = useStoreContext(IMAGE_NAME);\r\n  const crop = useStore((state) => state.crop);\r\n  const zoom = useStore((state) => state.zoom);\r\n  const rotation = useStore((state) => state.rotation);\r\n\r\n  const imageRef = React.useRef<HTMLImageElement>(null);\r\n  const composedRef = useComposedRefs(ref, imageRef);\r\n\r\n  const getNaturalDimensions = React.useCallback(\r\n    (image: HTMLImageElement) => ({\r\n      width: image.naturalWidth,\r\n      height: image.naturalHeight,\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const { computeSizes } = useMediaComputation({\r\n    mediaRef: imageRef,\r\n    context,\r\n    store,\r\n    rotation,\r\n    getNaturalDimensions,\r\n  });\r\n\r\n  const onMediaLoad = React.useCallback(() => {\r\n    const image = imageRef.current;\r\n    if (!image) return;\r\n\r\n    computeSizes();\r\n\r\n    onLoad?.(\r\n      new Event(\"load\") as unknown as React.SyntheticEvent<HTMLImageElement>,\r\n    );\r\n  }, [computeSizes, onLoad]);\r\n\r\n  React.useEffect(() => {\r\n    const image = imageRef.current;\r\n    if (image?.complete && image.naturalWidth > 0) {\r\n      onMediaLoad();\r\n    }\r\n  }, [onMediaLoad]);\r\n\r\n  React.useEffect(() => {\r\n    const content = context.rootRef?.current;\r\n    if (!content) return;\r\n\r\n    if (typeof ResizeObserver !== \"undefined\") {\r\n      let isFirstResize = true;\r\n      const resizeObserver = new ResizeObserver(() => {\r\n        if (isFirstResize) {\r\n          isFirstResize = false;\r\n          return;\r\n        }\r\n\r\n        const callback = () => {\r\n          const image = imageRef.current;\r\n          if (image?.complete && image.naturalWidth > 0) {\r\n            computeSizes();\r\n          }\r\n        };\r\n\r\n        if (\"requestIdleCallback\" in window) {\r\n          requestIdleCallback(callback);\r\n        } else {\r\n          setTimeout(callback, 16);\r\n        }\r\n      });\r\n\r\n      resizeObserver.observe(content);\r\n\r\n      return () => {\r\n        resizeObserver.disconnect();\r\n      };\r\n    } else {\r\n      const onWindowResize = () => {\r\n        const image = imageRef.current;\r\n        if (image?.complete && image.naturalWidth > 0) {\r\n          computeSizes();\r\n        }\r\n      };\r\n\r\n      window.addEventListener(\"resize\", onWindowResize);\r\n      return () => {\r\n        window.removeEventListener(\"resize\", onWindowResize);\r\n      };\r\n    }\r\n  }, [context.rootRef, computeSizes]);\r\n\r\n  const ImagePrimitive = asChild ? SlotPrimitive.Slot : \"img\";\r\n\r\n  return (\r\n    <ImagePrimitive\r\n      data-slot=\"cropper-image\"\r\n      {...imageProps}\r\n      ref={composedRef}\r\n      className={cn(\r\n        cropperMediaVariants({\r\n          objectFit: objectFit ?? context.objectFit,\r\n          className,\r\n        }),\r\n      )}\r\n      style={{\r\n        transform: snapPixels\r\n          ? `translate(${snapToDevicePixel(crop.x)}px, ${snapToDevicePixel(crop.y)}px) rotate(${rotation}deg) scale(${zoom})`\r\n          : `translate(${crop.x}px, ${crop.y}px) rotate(${rotation}deg) scale(${zoom})`,\r\n        ...style,\r\n      }}\r\n      onLoad={onMediaLoad}\r\n    />\r\n  );\r\n}\r\n\r\ninterface CropperVideoProps\r\n  extends React.ComponentProps<\"video\">,\r\n    VariantProps<typeof cropperMediaVariants> {\r\n  asChild?: boolean;\r\n  snapPixels?: boolean;\r\n}\r\n\r\nfunction CropperVideo(props: CropperVideoProps) {\r\n  const {\r\n    className,\r\n    style,\r\n    asChild,\r\n    ref,\r\n    onLoadedMetadata,\r\n    objectFit,\r\n    snapPixels = false,\r\n    ...videoProps\r\n  } = props;\r\n\r\n  const context = useCropperContext(VIDEO_NAME);\r\n  const store = useStoreContext(VIDEO_NAME);\r\n  const crop = useStore((state) => state.crop);\r\n  const zoom = useStore((state) => state.zoom);\r\n  const rotation = useStore((state) => state.rotation);\r\n\r\n  const videoRef = React.useRef<HTMLVideoElement>(null);\r\n  const composedRef = useComposedRefs(ref, videoRef);\r\n\r\n  const getNaturalDimensions = React.useCallback(\r\n    (video: HTMLVideoElement) => ({\r\n      width: video.videoWidth,\r\n      height: video.videoHeight,\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const { computeSizes } = useMediaComputation({\r\n    mediaRef: videoRef,\r\n    context,\r\n    store,\r\n    rotation,\r\n    getNaturalDimensions,\r\n  });\r\n\r\n  const onMediaLoad = React.useCallback(() => {\r\n    const video = videoRef.current;\r\n    if (!video) return;\r\n\r\n    computeSizes();\r\n\r\n    onLoadedMetadata?.(\r\n      new Event(\r\n        \"loadedmetadata\",\r\n      ) as unknown as React.SyntheticEvent<HTMLVideoElement>,\r\n    );\r\n  }, [computeSizes, onLoadedMetadata]);\r\n\r\n  React.useEffect(() => {\r\n    const content = context.rootRef?.current;\r\n    if (!content) return;\r\n\r\n    if (typeof ResizeObserver !== \"undefined\") {\r\n      let isFirstResize = true;\r\n      const resizeObserver = new ResizeObserver(() => {\r\n        if (isFirstResize) {\r\n          isFirstResize = false;\r\n          return;\r\n        }\r\n\r\n        const callback = () => {\r\n          const video = videoRef.current;\r\n          if (video && video.videoWidth > 0 && video.videoHeight > 0) {\r\n            computeSizes();\r\n          }\r\n        };\r\n\r\n        if (\"requestIdleCallback\" in window) {\r\n          requestIdleCallback(callback);\r\n        } else {\r\n          setTimeout(callback, 16);\r\n        }\r\n      });\r\n\r\n      resizeObserver.observe(content);\r\n\r\n      return () => {\r\n        resizeObserver.disconnect();\r\n      };\r\n    } else {\r\n      const onWindowResize = () => {\r\n        const video = videoRef.current;\r\n        if (video && video.videoWidth > 0 && video.videoHeight > 0) {\r\n          computeSizes();\r\n        }\r\n      };\r\n\r\n      window.addEventListener(\"resize\", onWindowResize);\r\n      return () => {\r\n        window.removeEventListener(\"resize\", onWindowResize);\r\n      };\r\n    }\r\n  }, [context.rootRef, computeSizes]);\r\n\r\n  const VideoPrimitive = asChild ? SlotPrimitive.Slot : \"video\";\r\n\r\n  return (\r\n    <VideoPrimitive\r\n      data-slot=\"cropper-video\"\r\n      autoPlay\r\n      playsInline\r\n      loop\r\n      muted\r\n      controls={false}\r\n      {...videoProps}\r\n      ref={composedRef}\r\n      className={cn(\r\n        cropperMediaVariants({\r\n          objectFit: objectFit ?? context.objectFit,\r\n          className,\r\n        }),\r\n      )}\r\n      style={{\r\n        transform: snapPixels\r\n          ? `translate(${snapToDevicePixel(crop.x)}px, ${snapToDevicePixel(crop.y)}px) rotate(${rotation}deg) scale(${zoom})`\r\n          : `translate(${crop.x}px, ${crop.y}px) rotate(${rotation}deg) scale(${zoom})`,\r\n        ...style,\r\n      }}\r\n      onLoadedMetadata={onMediaLoad}\r\n    />\r\n  );\r\n}\r\n\r\nconst cropperAreaVariants = cva(\r\n  \"absolute top-1/2 left-1/2 box-border -translate-x-1/2 -translate-y-1/2 overflow-hidden border border-[2.5px] border-white/90 shadow-[0_0_0_9999em_rgba(0,0,0,0.5)]\",\r\n  {\r\n    variants: {\r\n      shape: {\r\n        rectangle: \"\",\r\n        circle: \"rounded-full\",\r\n      },\r\n      withGrid: {\r\n        true: \"before:absolute before:top-0 before:right-1/3 before:bottom-0 before:left-1/3 before:box-border before:border before:border-white/50 before:border-t-0 before:border-b-0 before:content-[''] after:absolute after:top-1/3 after:right-0 after:bottom-1/3 after:left-0 after:box-border after:border after:border-white/50 after:border-r-0 after:border-l-0 after:content-['']\",\r\n        false: \"\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      shape: \"rectangle\",\r\n      withGrid: false,\r\n    },\r\n  },\r\n);\r\n\r\ninterface CropperAreaProps\r\n  extends DivProps,\r\n    VariantProps<typeof cropperAreaVariants> {\r\n  snapPixels?: boolean;\r\n}\r\n\r\nfunction CropperArea(props: CropperAreaProps) {\r\n  const {\r\n    className,\r\n    style,\r\n    asChild,\r\n    ref,\r\n    snapPixels = false,\r\n    shape,\r\n    withGrid,\r\n    ...areaProps\r\n  } = props;\r\n\r\n  const context = useCropperContext(AREA_NAME);\r\n  const cropSize = useStore((state) => state.cropSize);\r\n\r\n  if (!cropSize) return null;\r\n\r\n  const AreaPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <AreaPrimitive\r\n      data-slot=\"cropper-area\"\r\n      {...areaProps}\r\n      ref={ref}\r\n      className={cn(\r\n        cropperAreaVariants({\r\n          shape: shape ?? context.shape,\r\n          withGrid: withGrid ?? context.withGrid,\r\n          className,\r\n        }),\r\n      )}\r\n      style={{\r\n        width: snapPixels ? Math.round(cropSize.width) : cropSize.width,\r\n        height: snapPixels ? Math.round(cropSize.height) : cropSize.height,\r\n        ...style,\r\n      }}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  Cropper,\r\n  CropperImage,\r\n  CropperVideo,\r\n  CropperArea,\r\n  //\r\n  useStore as useCropper,\r\n  //\r\n  type CropperProps,\r\n  type Point as CropperPoint,\r\n  type Size as CropperSize,\r\n  type Area as CropperAreaData,\r\n  type Shape as CropperShape,\r\n  type ObjectFit as CropperObjectFit,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}