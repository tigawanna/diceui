{
  "name": "mask-input",
  "dependencies": [
    "radix-ui"
  ],
  "files": [
    {
      "path": "ui/mask-input.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot as SlotPrimitive } from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst PAST_YEARS_LIMIT = 120;\r\nconst FUTURE_YEARS_LIMIT = 10;\r\nconst DEFAULT_CURRENCY = \"USD\";\r\nconst DEFAULT_LOCALE = \"en-US\";\r\n\r\nconst NUMERIC_MASK_PATTERNS =\r\n  /^(phone|zipCode|zipCodeExtended|ssn|ein|time|date|creditCard|creditCardExpiry)$/;\r\nconst CURRENCY_PERCENTAGE_SYMBOLS = /[€$%]/;\r\n\r\ninterface CurrencySymbols {\r\n  currency: string;\r\n  decimal: string;\r\n  group: string;\r\n}\r\n\r\nconst formattersCache = new Map<string, Intl.NumberFormat>();\r\nconst currencyAtEndCache = new Map<string, boolean>();\r\nconst currencySymbolsCache = new Map<string, CurrencySymbols>();\r\nconst daysInMonthCache = [\r\n  31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,\r\n] as const;\r\n\r\nconst REGEX_CACHE = {\r\n  digitsOnly: /^\\d+$/,\r\n  nonDigits: /\\D/g,\r\n  nonAlphaNumeric: /[^A-Z0-9]/gi,\r\n  nonNumericDot: /[^0-9.]/g,\r\n  nonCurrencyChars: /[^\\d.,]/g,\r\n  hashPattern: /#/g,\r\n  currencyAtEnd: /\\d\\s*[^\\d\\s]+$/,\r\n  percentageChars: /[^\\d.]/g,\r\n  phone: /^\\d{10}$/,\r\n  ssn: /^\\d{9}$/,\r\n  zipCode: /^\\d{5}$/,\r\n  zipCodeExtended: /^\\d{9}$/,\r\n  isbn: /^\\d{13}$/,\r\n  ein: /^\\d{9}$/,\r\n  time: /^\\d{4}$/,\r\n  creditCard: /^\\d{13,19}$/,\r\n  creditCardExpiry: /^\\d{4}$/,\r\n  licensePlate: /^[A-Z0-9]{6}$/,\r\n  macAddress: /^[A-F0-9]{12}$/,\r\n  currencyValidation: /^\\d+(\\.\\d{1,2})?$/,\r\n  ipv4Segment: /^\\d{1,3}$/,\r\n} as const;\r\n\r\nfunction getCachedFormatter(\r\n  locale: string | undefined,\r\n  opts: Intl.NumberFormatOptions,\r\n): Intl.NumberFormat {\r\n  const {\r\n    currency,\r\n    minimumFractionDigits = 0,\r\n    maximumFractionDigits = 2,\r\n  } = opts;\r\n\r\n  const key = `${locale}|${currency}|${minimumFractionDigits}|${maximumFractionDigits}`;\r\n\r\n  if (!formattersCache.has(key)) {\r\n    try {\r\n      formattersCache.set(\r\n        key,\r\n        new Intl.NumberFormat(locale, {\r\n          style: \"currency\",\r\n          currency,\r\n          ...opts,\r\n        }),\r\n      );\r\n    } catch {\r\n      formattersCache.set(\r\n        key,\r\n        new Intl.NumberFormat(DEFAULT_LOCALE, {\r\n          style: \"currency\",\r\n          currency: DEFAULT_CURRENCY,\r\n          ...opts,\r\n        }),\r\n      );\r\n    }\r\n  }\r\n\r\n  const formatter = formattersCache.get(key);\r\n  if (!formatter) {\r\n    throw new Error(`Failed to create formatter for ${key}`);\r\n  }\r\n  return formatter;\r\n}\r\n\r\nfunction getCachedCurrencySymbols(opts: TransformOptions): CurrencySymbols {\r\n  const { locale, currency } = opts;\r\n\r\n  const key = `${locale}|${currency}`;\r\n  const cached = currencySymbolsCache.get(key);\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n\r\n  let currencySymbol = \"$\";\r\n  let decimalSeparator = \".\";\r\n  let groupSeparator = \",\";\r\n\r\n  try {\r\n    const formatter = getCachedFormatter(locale, {\r\n      currency,\r\n      minimumFractionDigits: 0,\r\n      maximumFractionDigits: 2,\r\n    });\r\n    const parts = formatter.formatToParts(1234.5);\r\n    const currencyPart = parts.find((part) => part.type === \"currency\");\r\n    const decimalPart = parts.find((part) => part.type === \"decimal\");\r\n    const groupPart = parts.find((part) => part.type === \"group\");\r\n\r\n    if (currencyPart) currencySymbol = currencyPart.value;\r\n    if (decimalPart) decimalSeparator = decimalPart.value;\r\n    if (groupPart) groupSeparator = groupPart.value;\r\n  } catch {\r\n    // Keep defaults\r\n  }\r\n\r\n  const symbols: CurrencySymbols = {\r\n    currency: currencySymbol,\r\n    decimal: decimalSeparator,\r\n    group: groupSeparator,\r\n  };\r\n  currencySymbolsCache.set(key, symbols);\r\n  return symbols;\r\n}\r\n\r\nfunction isCurrencyAtEnd(opts: TransformOptions): boolean {\r\n  const { locale, currency } = opts;\r\n\r\n  const key = `${locale}|${currency}`;\r\n  const cached = currencyAtEndCache.get(key);\r\n  if (cached !== undefined) {\r\n    return cached;\r\n  }\r\n\r\n  try {\r\n    const formatter = getCachedFormatter(locale, {\r\n      currency,\r\n      minimumFractionDigits: 0,\r\n      maximumFractionDigits: 0,\r\n    });\r\n    const sample = formatter.format(123);\r\n    const result = REGEX_CACHE.currencyAtEnd.test(sample);\r\n    currencyAtEndCache.set(key, result);\r\n    return result;\r\n  } catch {\r\n    currencyAtEndCache.set(key, false);\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction isCurrencyMask(opts: {\r\n  mask: MaskPatternKey | MaskPattern | undefined;\r\n  pattern?: string;\r\n}): boolean {\r\n  const { mask, pattern } = opts;\r\n\r\n  return (\r\n    mask === \"currency\" ||\r\n    Boolean(pattern && (pattern.includes(\"$\") || pattern.includes(\"€\")))\r\n  );\r\n}\r\n\r\ninterface TransformOptions {\r\n  currency?: string;\r\n  locale?: string;\r\n}\r\n\r\ninterface ValidateOptions {\r\n  min?: number;\r\n  max?: number;\r\n}\r\n\r\ninterface MaskPattern {\r\n  pattern: string;\r\n  transform?: (value: string, opts?: TransformOptions) => string;\r\n  validate?: (value: string, opts?: ValidateOptions) => boolean;\r\n}\r\n\r\ntype MaskPatternKey =\r\n  | \"phone\"\r\n  | \"ssn\"\r\n  | \"date\"\r\n  | \"time\"\r\n  | \"creditCard\"\r\n  | \"creditCardExpiry\"\r\n  | \"zipCode\"\r\n  | \"zipCodeExtended\"\r\n  | \"currency\"\r\n  | \"percentage\"\r\n  | \"licensePlate\"\r\n  | \"ipv4\"\r\n  | \"macAddress\"\r\n  | \"isbn\"\r\n  | \"ein\";\r\n\r\nconst MASK_PATTERNS: Record<MaskPatternKey, MaskPattern> = {\r\n  phone: {\r\n    pattern: \"(###) ###-####\",\r\n    transform: (value) => value.replace(REGEX_CACHE.nonDigits, \"\"),\r\n    validate: (value) =>\r\n      REGEX_CACHE.phone.test(value.replace(REGEX_CACHE.nonDigits, \"\")),\r\n  },\r\n  ssn: {\r\n    pattern: \"###-##-####\",\r\n    transform: (value) => value.replace(REGEX_CACHE.nonDigits, \"\"),\r\n    validate: (value) =>\r\n      REGEX_CACHE.ssn.test(value.replace(REGEX_CACHE.nonDigits, \"\")),\r\n  },\r\n  date: {\r\n    pattern: \"##/##/####\",\r\n    transform: (value) => value.replace(REGEX_CACHE.nonDigits, \"\"),\r\n    validate: (value) => {\r\n      const cleaned = value.replace(REGEX_CACHE.nonDigits, \"\");\r\n      if (cleaned.length !== 8) return false;\r\n      const month = parseInt(cleaned.substring(0, 2), 10);\r\n      const day = parseInt(cleaned.substring(2, 4), 10);\r\n      const year = parseInt(cleaned.substring(4, 8), 10);\r\n\r\n      const currentYear = new Date().getFullYear();\r\n      const minYear = currentYear - PAST_YEARS_LIMIT;\r\n      const maxYear = currentYear + FUTURE_YEARS_LIMIT;\r\n      if (\r\n        month < 1 ||\r\n        month > 12 ||\r\n        day < 1 ||\r\n        year < minYear ||\r\n        year > maxYear\r\n      )\r\n        return false;\r\n\r\n      const maxDays =\r\n        month === 2 &&\r\n        ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0)\r\n          ? 29\r\n          : (daysInMonthCache[month - 1] ?? 31);\r\n\r\n      return day <= maxDays;\r\n    },\r\n  },\r\n  time: {\r\n    pattern: \"##:##\",\r\n    transform: (value) => value.replace(REGEX_CACHE.nonDigits, \"\"),\r\n    validate: (value) => {\r\n      const cleaned = value.replace(REGEX_CACHE.nonDigits, \"\");\r\n      if (!REGEX_CACHE.time.test(cleaned)) return false;\r\n      const hours = parseInt(cleaned.substring(0, 2), 10);\r\n      const minutes = parseInt(cleaned.substring(2, 4), 10);\r\n      return hours <= 23 && minutes <= 59;\r\n    },\r\n  },\r\n  creditCard: {\r\n    pattern: \"#### #### #### ####\",\r\n    transform: (value) => value.replace(REGEX_CACHE.nonDigits, \"\"),\r\n    validate: (value) => {\r\n      const cleaned = value.replace(REGEX_CACHE.nonDigits, \"\");\r\n      if (!REGEX_CACHE.creditCard.test(cleaned)) return false;\r\n\r\n      let sum = 0;\r\n      let isEven = false;\r\n      for (let i = cleaned.length - 1; i >= 0; i--) {\r\n        const digitChar = cleaned[i];\r\n        if (!digitChar) continue;\r\n        let digit = parseInt(digitChar, 10);\r\n        if (isEven) {\r\n          digit *= 2;\r\n          if (digit > 9) {\r\n            digit -= 9;\r\n          }\r\n        }\r\n        sum += digit;\r\n        isEven = !isEven;\r\n      }\r\n      return sum % 10 === 0;\r\n    },\r\n  },\r\n  creditCardExpiry: {\r\n    pattern: \"##/##\",\r\n    transform: (value) => value.replace(REGEX_CACHE.nonDigits, \"\"),\r\n    validate: (value) => {\r\n      const cleaned = value.replace(REGEX_CACHE.nonDigits, \"\");\r\n      if (!REGEX_CACHE.creditCardExpiry.test(cleaned)) return false;\r\n\r\n      const month = parseInt(cleaned.substring(0, 2), 10);\r\n      const year = parseInt(cleaned.substring(2, 4), 10);\r\n\r\n      if (month < 1 || month > 12) return false;\r\n\r\n      const now = new Date();\r\n      const currentYear = now.getFullYear();\r\n      const currentMonth = now.getMonth() + 1;\r\n\r\n      const fullYear = year <= 75 ? 2000 + year : 1900 + year;\r\n\r\n      if (\r\n        fullYear < currentYear ||\r\n        (fullYear === currentYear && month < currentMonth)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      const maxYear = currentYear + 50;\r\n      if (fullYear > maxYear) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    },\r\n  },\r\n  zipCode: {\r\n    pattern: \"#####\",\r\n    transform: (value) => value.replace(REGEX_CACHE.nonDigits, \"\"),\r\n    validate: (value) =>\r\n      REGEX_CACHE.zipCode.test(value.replace(REGEX_CACHE.nonDigits, \"\")),\r\n  },\r\n  zipCodeExtended: {\r\n    pattern: \"#####-####\",\r\n    transform: (value) => value.replace(REGEX_CACHE.nonDigits, \"\"),\r\n    validate: (value) =>\r\n      REGEX_CACHE.zipCodeExtended.test(\r\n        value.replace(REGEX_CACHE.nonDigits, \"\"),\r\n      ),\r\n  },\r\n  currency: {\r\n    pattern: \"$###,###.##\",\r\n    transform: (\r\n      value,\r\n      { currency = DEFAULT_CURRENCY, locale = DEFAULT_LOCALE } = {},\r\n    ) => {\r\n      let localeDecimalSeparator = \".\";\r\n\r\n      try {\r\n        const formatter = getCachedFormatter(locale, {\r\n          currency,\r\n          minimumFractionDigits: 0,\r\n          maximumFractionDigits: 2,\r\n        });\r\n        const parts = formatter.formatToParts(1234.5);\r\n        const decimalPart = parts.find((part) => part.type === \"decimal\");\r\n\r\n        if (decimalPart) localeDecimalSeparator = decimalPart.value;\r\n      } catch {\r\n        // Keep defaults\r\n      }\r\n\r\n      const cleaned = value.replace(REGEX_CACHE.nonCurrencyChars, \"\");\r\n\r\n      const dotIndex = cleaned.indexOf(\".\");\r\n      const commaIndex = cleaned.indexOf(\",\");\r\n\r\n      let hasDecimalSeparator = false;\r\n      let decimalIndex = -1;\r\n\r\n      if (localeDecimalSeparator === \",\") {\r\n        const lastCommaIndex = cleaned.lastIndexOf(\",\");\r\n        if (lastCommaIndex !== -1) {\r\n          const afterComma = cleaned.substring(lastCommaIndex + 1);\r\n          if (afterComma.length <= 2 && /^\\d*$/.test(afterComma)) {\r\n            hasDecimalSeparator = true;\r\n            decimalIndex = lastCommaIndex;\r\n          }\r\n        }\r\n\r\n        if (!hasDecimalSeparator && dotIndex !== -1) {\r\n          const afterDot = cleaned.substring(dotIndex + 1);\r\n          if (afterDot.length <= 2 && /^\\d*$/.test(afterDot)) {\r\n            hasDecimalSeparator = true;\r\n            decimalIndex = dotIndex;\r\n          }\r\n        }\r\n\r\n        if (!hasDecimalSeparator && cleaned.length >= 4) {\r\n          const match = cleaned.match(/^(\\d+)\\.(\\d{3})(\\d{1,2})$/);\r\n          if (match) {\r\n            const [, beforeDot, thousandsPart, decimalPart] = match;\r\n            const integerPart = (beforeDot ?? \"\") + (thousandsPart ?? \"\");\r\n            const result = `${integerPart}.${decimalPart}`;\r\n            return result;\r\n          }\r\n        }\r\n      } else {\r\n        const lastDotIndex = cleaned.lastIndexOf(\".\");\r\n        if (lastDotIndex !== -1) {\r\n          const afterDot = cleaned.substring(lastDotIndex + 1);\r\n          if (afterDot.length <= 2 && /^\\d*$/.test(afterDot)) {\r\n            hasDecimalSeparator = true;\r\n            decimalIndex = lastDotIndex;\r\n          }\r\n        }\r\n\r\n        if (!hasDecimalSeparator && commaIndex !== -1) {\r\n          const afterComma = cleaned.substring(commaIndex + 1);\r\n          const looksLikeThousands = commaIndex <= 3 && afterComma.length >= 3;\r\n          if (\r\n            !looksLikeThousands &&\r\n            afterComma.length <= 2 &&\r\n            /^\\d*$/.test(afterComma)\r\n          ) {\r\n            hasDecimalSeparator = true;\r\n            decimalIndex = commaIndex;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (hasDecimalSeparator && decimalIndex !== -1) {\r\n        const beforeDecimal = cleaned\r\n          .substring(0, decimalIndex)\r\n          .replace(/[.,]/g, \"\");\r\n        const afterDecimal = cleaned\r\n          .substring(decimalIndex + 1)\r\n          .replace(/[.,]/g, \"\");\r\n\r\n        if (afterDecimal === \"\") {\r\n          const result = `${beforeDecimal}.`;\r\n          return result;\r\n        }\r\n\r\n        const result = `${beforeDecimal}.${afterDecimal.substring(0, 2)}`;\r\n        return result;\r\n      }\r\n\r\n      const digitsOnly = cleaned.replace(/[.,]/g, \"\");\r\n      return digitsOnly;\r\n    },\r\n    validate: (value) => {\r\n      if (!REGEX_CACHE.currencyValidation.test(value)) return false;\r\n      const num = parseFloat(value);\r\n      return !Number.isNaN(num) && num >= 0;\r\n    },\r\n  },\r\n  percentage: {\r\n    pattern: \"##.##%\",\r\n    transform: (value) => {\r\n      const cleaned = value.replace(REGEX_CACHE.percentageChars, \"\");\r\n      const parts = cleaned.split(\".\");\r\n      if (parts.length > 2) {\r\n        return `${parts[0]}.${parts.slice(1).join(\"\")}`;\r\n      }\r\n      if (parts[1] && parts[1].length > 2) {\r\n        return `${parts[0]}.${parts[1].substring(0, 2)}`;\r\n      }\r\n      return cleaned;\r\n    },\r\n    validate: (value, opts = {}) => {\r\n      const num = parseFloat(value);\r\n      const min = opts.min ?? 0;\r\n      const max = opts.max ?? 100;\r\n      return !Number.isNaN(num) && num >= min && num <= max;\r\n    },\r\n  },\r\n  licensePlate: {\r\n    pattern: \"###-###\",\r\n    transform: (value) =>\r\n      value.replace(REGEX_CACHE.nonAlphaNumeric, \"\").toUpperCase(),\r\n    validate: (value) => REGEX_CACHE.licensePlate.test(value),\r\n  },\r\n  ipv4: {\r\n    pattern: \"###.###.###.###\",\r\n    transform: (value) => value.replace(REGEX_CACHE.nonNumericDot, \"\"),\r\n    validate: (value) => {\r\n      if (value.includes(\".\")) {\r\n        const segments = value.split(\".\");\r\n        if (segments.length > 4) return false;\r\n\r\n        return segments.every((segment) => {\r\n          if (segment === \"\") return true;\r\n          if (!REGEX_CACHE.ipv4Segment.test(segment)) return false;\r\n          const num = parseInt(segment, 10);\r\n          return num <= 255;\r\n        });\r\n      } else {\r\n        if (!REGEX_CACHE.digitsOnly.test(value)) return false;\r\n        if (value.length > 12) return false;\r\n\r\n        const chunks = [];\r\n        for (let i = 0; i < value.length; i += 3) {\r\n          chunks.push(value.substring(i, i + 3));\r\n        }\r\n\r\n        if (chunks.length > 4) return false;\r\n\r\n        return chunks.every((chunk) => {\r\n          const num = parseInt(chunk, 10);\r\n          return num >= 0 && num <= 255;\r\n        });\r\n      }\r\n    },\r\n  },\r\n  macAddress: {\r\n    pattern: \"##:##:##:##:##:##\",\r\n    transform: (value) =>\r\n      value.replace(REGEX_CACHE.nonAlphaNumeric, \"\").toUpperCase(),\r\n    validate: (value) => REGEX_CACHE.macAddress.test(value),\r\n  },\r\n  isbn: {\r\n    pattern: \"###-#-###-#####-#\",\r\n    transform: (value) => value.replace(REGEX_CACHE.nonDigits, \"\"),\r\n    validate: (value) =>\r\n      REGEX_CACHE.isbn.test(value.replace(REGEX_CACHE.nonDigits, \"\")),\r\n  },\r\n  ein: {\r\n    pattern: \"##-#######\",\r\n    transform: (value) => value.replace(REGEX_CACHE.nonDigits, \"\"),\r\n    validate: (value) =>\r\n      REGEX_CACHE.ein.test(value.replace(REGEX_CACHE.nonDigits, \"\")),\r\n  },\r\n};\r\n\r\nfunction applyMask(opts: {\r\n  value: string;\r\n  pattern: string;\r\n  currency?: string;\r\n  locale?: string;\r\n  mask?: MaskPatternKey | MaskPattern;\r\n}): string {\r\n  const { value, pattern, currency, locale, mask } = opts;\r\n\r\n  const cleanValue = value;\r\n\r\n  if (pattern.includes(\"$\") || pattern.includes(\"€\") || mask === \"currency\") {\r\n    return applyCurrencyMask({\r\n      value: cleanValue,\r\n      currency: currency ?? DEFAULT_CURRENCY,\r\n      locale: locale ?? DEFAULT_LOCALE,\r\n    });\r\n  }\r\n\r\n  if (pattern.includes(\"%\")) {\r\n    return applyPercentageMask(cleanValue);\r\n  }\r\n\r\n  if (mask === \"ipv4\") {\r\n    return cleanValue;\r\n  }\r\n\r\n  const maskedChars: string[] = [];\r\n  let valueIndex = 0;\r\n\r\n  for (let i = 0; i < pattern.length && valueIndex < cleanValue.length; i++) {\r\n    const patternChar = pattern[i];\r\n    const valueChar = cleanValue[valueIndex];\r\n\r\n    if (patternChar === \"#\" && valueChar) {\r\n      maskedChars.push(valueChar);\r\n      valueIndex++;\r\n    } else if (patternChar) {\r\n      maskedChars.push(patternChar);\r\n    }\r\n  }\r\n\r\n  return maskedChars.join(\"\");\r\n}\r\n\r\nfunction applyCurrencyMask(opts: {\r\n  value: string;\r\n  currency?: string;\r\n  locale?: string;\r\n}): string {\r\n  const { value, currency = DEFAULT_CURRENCY, locale = DEFAULT_LOCALE } = opts;\r\n\r\n  if (!value) return \"\";\r\n\r\n  const {\r\n    currency: currencySymbol,\r\n    decimal: decimalSeparator,\r\n    group: groupSeparator,\r\n  } = getCachedCurrencySymbols({ locale, currency });\r\n\r\n  const normalizedValue = value\r\n    .replace(\r\n      new RegExp(\r\n        `\\\\${groupSeparator.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\")}`,\r\n        \"g\",\r\n      ),\r\n      \"\",\r\n    )\r\n    .replace(decimalSeparator, \".\");\r\n\r\n  const parts = normalizedValue.split(\".\");\r\n  const integerPart = parts[0] ?? \"\";\r\n  const fractionalPart = parts[1] ?? \"\";\r\n\r\n  if (!integerPart && !fractionalPart) return \"\";\r\n\r\n  const intValue = integerPart ?? \"0\";\r\n  const fracValue = fractionalPart.slice(0, 2);\r\n\r\n  const num = Number(`${intValue}.${fracValue ?? \"\"}`);\r\n\r\n  if (Number.isNaN(num)) {\r\n    const cleanedDigits = value.replace(/[^\\d]/g, \"\");\r\n    if (!cleanedDigits) return \"\";\r\n    return `${currencySymbol}${cleanedDigits}`;\r\n  }\r\n\r\n  const hasExplicitDecimal =\r\n    value.includes(\".\") || value.includes(decimalSeparator);\r\n\r\n  try {\r\n    const formatter = getCachedFormatter(locale, {\r\n      currency,\r\n      minimumFractionDigits: fracValue ? fracValue.length : 0,\r\n      maximumFractionDigits: 2,\r\n    });\r\n    const result = formatter.format(num);\r\n\r\n    if (hasExplicitDecimal && !fracValue) {\r\n      if (result.match(/^[^\\d\\s]+/)) {\r\n        const finalResult = result.replace(/(\\d)$/, `$1${decimalSeparator}`);\r\n        return finalResult;\r\n      } else {\r\n        const finalResult = result.replace(\r\n          /(\\d)(\\s*)([^\\d\\s]+)$/,\r\n          `$1${decimalSeparator}$2$3`,\r\n        );\r\n        return finalResult;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  } catch {\r\n    const formattedInt = intValue.replace(\r\n      /\\B(?=(\\d{3})+(?!\\d))/g,\r\n      groupSeparator,\r\n    );\r\n    let result = `${currencySymbol}${formattedInt}`;\r\n    if (hasExplicitDecimal) {\r\n      result += `${decimalSeparator}${fracValue}`;\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nfunction applyPercentageMask(value: string): string {\r\n  if (!value) return \"\";\r\n\r\n  const parts = value.split(\".\");\r\n  let result = parts[0] ?? \"0\";\r\n\r\n  if (value.includes(\".\")) {\r\n    result += `.${(parts[1] ?? \"\").substring(0, 2)}`;\r\n  }\r\n\r\n  return `${result}%`;\r\n}\r\n\r\nfunction getUnmaskedValue(opts: {\r\n  value: string;\r\n  currency?: string;\r\n  locale?: string;\r\n  transform?: (value: string, opts?: TransformOptions) => string;\r\n}): string {\r\n  const { value, transform, currency, locale } = opts;\r\n\r\n  return transform\r\n    ? transform(value, { currency, locale })\r\n    : value.replace(REGEX_CACHE.nonDigits, \"\");\r\n}\r\n\r\nfunction toUnmaskedIndex(opts: {\r\n  masked: string;\r\n  pattern: string;\r\n  caret: number;\r\n}): number {\r\n  const { masked, pattern, caret } = opts;\r\n\r\n  let idx = 0;\r\n  for (let i = 0; i < caret && i < masked.length && i < pattern.length; i++) {\r\n    if (pattern[i] === \"#\") {\r\n      idx++;\r\n    }\r\n  }\r\n\r\n  return idx;\r\n}\r\n\r\nfunction fromUnmaskedIndex(opts: {\r\n  masked: string;\r\n  pattern: string;\r\n  unmaskedIndex: number;\r\n}): number {\r\n  const { masked, pattern, unmaskedIndex } = opts;\r\n\r\n  let seen = 0;\r\n  for (let i = 0; i < masked.length && i < pattern.length; i++) {\r\n    if (pattern[i] === \"#\") {\r\n      seen++;\r\n      if (seen === unmaskedIndex) {\r\n        return i + 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return masked.length;\r\n}\r\n\r\nfunction getCurrencyCaretPosition(opts: {\r\n  newValue: string;\r\n  mask: MaskPatternKey | MaskPattern | undefined;\r\n  transformOpts: TransformOptions;\r\n  oldCursorPosition?: number;\r\n  oldValue?: string;\r\n  previousUnmasked?: string;\r\n}): number {\r\n  const {\r\n    newValue,\r\n    mask,\r\n    transformOpts,\r\n    oldCursorPosition,\r\n    oldValue,\r\n    previousUnmasked,\r\n  } = opts;\r\n\r\n  if (\r\n    oldCursorPosition !== undefined &&\r\n    oldValue &&\r\n    previousUnmasked !== undefined\r\n  ) {\r\n    if (oldCursorPosition < oldValue.length) {\r\n      const digitsBeforeCursor = oldValue\r\n        .substring(0, oldCursorPosition)\r\n        .replace(/\\D/g, \"\").length;\r\n\r\n      let digitCount = 0;\r\n      for (let i = 0; i < newValue.length; i++) {\r\n        if (/\\d/.test(newValue[i] ?? \"\")) {\r\n          digitCount++;\r\n          if (digitCount === digitsBeforeCursor) {\r\n            return i + 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (mask === \"currency\") {\r\n    const currencyAtEnd = isCurrencyAtEnd(transformOpts);\r\n    if (currencyAtEnd) {\r\n      const match = newValue.match(/(\\d)\\s*([^\\d\\s]+)$/);\r\n      if (match?.[1]) {\r\n        return newValue.lastIndexOf(match[1]) + 1;\r\n      } else {\r\n        return newValue.length;\r\n      }\r\n    } else {\r\n      return newValue.length;\r\n    }\r\n  } else {\r\n    return newValue.length;\r\n  }\r\n}\r\n\r\nfunction getPatternCaretPosition(opts: {\r\n  newValue: string;\r\n  maskPattern: MaskPattern;\r\n  currentUnmasked: string;\r\n  oldCursorPosition?: number;\r\n  oldValue?: string;\r\n  previousUnmasked?: string;\r\n}): number {\r\n  const {\r\n    newValue,\r\n    maskPattern,\r\n    currentUnmasked,\r\n    oldCursorPosition,\r\n    oldValue,\r\n    previousUnmasked,\r\n  } = opts;\r\n  let position = 0;\r\n  let unmaskedCount = 0;\r\n\r\n  if (\r\n    oldCursorPosition !== undefined &&\r\n    oldValue &&\r\n    previousUnmasked !== undefined\r\n  ) {\r\n    const oldUnmaskedIndex = toUnmaskedIndex({\r\n      masked: oldValue,\r\n      pattern: maskPattern.pattern,\r\n      caret: oldCursorPosition,\r\n    });\r\n\r\n    if (oldCursorPosition < oldValue.length) {\r\n      const targetUnmaskedIndex = Math.min(\r\n        oldUnmaskedIndex,\r\n        currentUnmasked.length,\r\n      );\r\n\r\n      for (\r\n        let i = 0;\r\n        i < maskPattern.pattern.length && i < newValue.length;\r\n        i++\r\n      ) {\r\n        if (maskPattern.pattern[i] === \"#\") {\r\n          unmaskedCount++;\r\n          if (unmaskedCount <= targetUnmaskedIndex) {\r\n            position = i + 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      return position;\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < maskPattern.pattern.length && i < newValue.length; i++) {\r\n    if (maskPattern.pattern[i] === \"#\") {\r\n      unmaskedCount++;\r\n      if (unmaskedCount <= currentUnmasked.length) {\r\n        position = i + 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return position;\r\n}\r\n\r\ntype InputElement = React.ComponentRef<\"input\">;\r\n\r\ninterface MaskInputProps extends React.ComponentProps<\"input\"> {\r\n  value?: string;\r\n  defaultValue?: string;\r\n  onValueChange?: (maskedValue: string, unmaskedValue: string) => void;\r\n  onValidate?: (isValid: boolean, unmaskedValue: string) => void;\r\n  validationMode?: \"onChange\" | \"onBlur\" | \"onSubmit\" | \"onTouched\" | \"all\";\r\n  mask?: MaskPatternKey | MaskPattern;\r\n  maskPlaceholder?: string;\r\n  currency?: string;\r\n  locale?: string;\r\n  asChild?: boolean;\r\n  invalid?: boolean;\r\n  withoutMask?: boolean;\r\n}\r\n\r\nfunction MaskInput(props: MaskInputProps) {\r\n  const {\r\n    value: valueProp,\r\n    defaultValue,\r\n    onValueChange: onValueChangeProp,\r\n    onValidate,\r\n    onBlur: onBlurProp,\r\n    onFocus: onFocusProp,\r\n    onKeyDown: onKeyDownProp,\r\n    onPaste: onPasteProp,\r\n    onCompositionStart: onCompositionStartProp,\r\n    onCompositionEnd: onCompositionEndProp,\r\n    validationMode = \"onChange\",\r\n    mask,\r\n    maskPlaceholder,\r\n    currency = DEFAULT_CURRENCY,\r\n    locale = DEFAULT_LOCALE,\r\n    placeholder,\r\n    inputMode,\r\n    min,\r\n    max,\r\n    maxLength,\r\n    asChild = false,\r\n    disabled = false,\r\n    invalid = false,\r\n    readOnly = false,\r\n    required = false,\r\n    withoutMask = false,\r\n    className,\r\n    ref,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const [internalValue, setInternalValue] = React.useState(defaultValue ?? \"\");\r\n  const [focused, setFocused] = React.useState(false);\r\n  const [composing, setComposing] = React.useState(false);\r\n  const [touched, setTouched] = React.useState(false);\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n  const composedRef = useComposedRefs(ref, inputRef);\r\n\r\n  const isControlled = valueProp !== undefined;\r\n  const value = isControlled ? valueProp : internalValue;\r\n\r\n  const maskPattern = React.useMemo(() => {\r\n    if (typeof mask === \"string\") {\r\n      return MASK_PATTERNS[mask];\r\n    }\r\n    return mask;\r\n  }, [mask]);\r\n\r\n  const transformOpts = React.useMemo(\r\n    () => ({\r\n      currency,\r\n      locale,\r\n    }),\r\n    [currency, locale],\r\n  );\r\n\r\n  const placeholderValue = React.useMemo(() => {\r\n    if (withoutMask) return placeholder;\r\n\r\n    if (placeholder && maskPlaceholder) {\r\n      return focused ? maskPlaceholder : placeholder;\r\n    }\r\n\r\n    if (maskPlaceholder) {\r\n      return focused ? maskPlaceholder : undefined;\r\n    }\r\n\r\n    return placeholder;\r\n  }, [placeholder, maskPlaceholder, focused, withoutMask]);\r\n\r\n  const displayValue = React.useMemo(() => {\r\n    if (withoutMask || !maskPattern || !value) return value ?? \"\";\r\n    const unmasked = getUnmaskedValue({\r\n      value,\r\n      transform: maskPattern.transform,\r\n      ...transformOpts,\r\n    });\r\n    return applyMask({\r\n      value: unmasked,\r\n      pattern: maskPattern.pattern,\r\n      ...transformOpts,\r\n      mask,\r\n    });\r\n  }, [value, maskPattern, withoutMask, transformOpts, mask]);\r\n\r\n  const tokenCount = React.useMemo(() => {\r\n    if (!maskPattern || CURRENCY_PERCENTAGE_SYMBOLS.test(maskPattern.pattern))\r\n      return undefined;\r\n    return maskPattern.pattern.match(REGEX_CACHE.hashPattern)?.length ?? 0;\r\n  }, [maskPattern]);\r\n\r\n  const calculatedMaxLength = tokenCount\r\n    ? maskPattern?.pattern.length\r\n    : maxLength;\r\n\r\n  const calculatedInputMode = React.useMemo(() => {\r\n    if (inputMode) return inputMode;\r\n    if (!maskPattern) return undefined;\r\n\r\n    if (mask === \"currency\" || mask === \"percentage\" || mask === \"ipv4\") {\r\n      return \"decimal\";\r\n    }\r\n\r\n    if (typeof mask === \"string\" && NUMERIC_MASK_PATTERNS.test(mask)) {\r\n      return \"numeric\";\r\n    }\r\n    return undefined;\r\n  }, [maskPattern, mask, inputMode]);\r\n\r\n  const shouldValidate = React.useCallback(\r\n    (trigger: \"change\" | \"blur\") => {\r\n      if (!onValidate || !maskPattern?.validate) return false;\r\n\r\n      switch (validationMode) {\r\n        case \"onChange\":\r\n          return trigger === \"change\";\r\n        case \"onBlur\":\r\n          return trigger === \"blur\";\r\n        case \"onSubmit\":\r\n          return false;\r\n        case \"onTouched\":\r\n          return touched ? trigger === \"change\" : trigger === \"blur\";\r\n        case \"all\":\r\n          return true;\r\n        default:\r\n          return trigger === \"change\";\r\n      }\r\n    },\r\n    [onValidate, maskPattern, validationMode, touched],\r\n  );\r\n\r\n  const validationOpts = React.useMemo(\r\n    () => ({\r\n      min: typeof min === \"string\" ? parseFloat(min) : min,\r\n      max: typeof max === \"string\" ? parseFloat(max) : max,\r\n    }),\r\n    [min, max],\r\n  );\r\n\r\n  const onInputValidate = React.useCallback(\r\n    (unmaskedValue: string) => {\r\n      if (onValidate && maskPattern?.validate) {\r\n        const isValid = maskPattern.validate(unmaskedValue, validationOpts);\r\n        onValidate(isValid, unmaskedValue);\r\n      }\r\n    },\r\n    [onValidate, maskPattern?.validate, validationOpts],\r\n  );\r\n\r\n  const onValueChange = React.useCallback(\r\n    (event: React.ChangeEvent<InputElement>) => {\r\n      const inputValue = event.target.value;\r\n      let newValue = inputValue;\r\n      let unmaskedValue = inputValue;\r\n\r\n      if (composing) {\r\n        if (!isControlled) setInternalValue(inputValue);\r\n        return;\r\n      }\r\n\r\n      if (withoutMask || !maskPattern) {\r\n        if (!isControlled) setInternalValue(inputValue);\r\n        if (shouldValidate(\"change\")) onValidate?.(true, inputValue);\r\n        onValueChangeProp?.(inputValue, inputValue);\r\n        return;\r\n      }\r\n\r\n      if (maskPattern) {\r\n        unmaskedValue = getUnmaskedValue({\r\n          value: inputValue,\r\n          transform: maskPattern.transform,\r\n          ...transformOpts,\r\n        });\r\n        newValue = applyMask({\r\n          value: unmaskedValue,\r\n          pattern: maskPattern.pattern,\r\n          ...transformOpts,\r\n          mask,\r\n        });\r\n\r\n        if (inputRef.current && newValue !== inputValue) {\r\n          const inputElement = inputRef.current;\r\n          if (!(inputElement instanceof HTMLInputElement)) return;\r\n\r\n          const oldCursorPosition = inputElement.selectionStart ?? 0;\r\n\r\n          inputElement.value = newValue;\r\n\r\n          const currentUnmasked = getUnmaskedValue({\r\n            value: newValue,\r\n            transform: maskPattern.transform,\r\n            ...transformOpts,\r\n          });\r\n\r\n          let newCursorPosition: number;\r\n\r\n          const previousUnmasked = getUnmaskedValue({\r\n            value,\r\n            transform: maskPattern.transform,\r\n            ...transformOpts,\r\n          });\r\n\r\n          if (CURRENCY_PERCENTAGE_SYMBOLS.test(maskPattern.pattern)) {\r\n            newCursorPosition = getCurrencyCaretPosition({\r\n              newValue,\r\n              mask,\r\n              transformOpts,\r\n              oldCursorPosition,\r\n              oldValue: inputValue,\r\n              previousUnmasked,\r\n            });\r\n          } else {\r\n            newCursorPosition = getPatternCaretPosition({\r\n              newValue,\r\n              maskPattern,\r\n              currentUnmasked,\r\n              oldCursorPosition,\r\n              oldValue: inputValue,\r\n              previousUnmasked,\r\n            });\r\n          }\r\n\r\n          if (isCurrencyMask({ mask, pattern: maskPattern.pattern })) {\r\n            if (mask === \"currency\") {\r\n              const currencyAtEnd = isCurrencyAtEnd(transformOpts);\r\n              if (!currencyAtEnd) {\r\n                newCursorPosition = Math.max(1, newCursorPosition);\r\n              }\r\n            } else {\r\n              newCursorPosition = Math.max(1, newCursorPosition);\r\n            }\r\n          } else if (maskPattern.pattern.includes(\"%\")) {\r\n            newCursorPosition = Math.min(\r\n              newValue.length - 1,\r\n              newCursorPosition,\r\n            );\r\n          }\r\n\r\n          newCursorPosition = Math.min(newCursorPosition, newValue.length);\r\n\r\n          inputElement.setSelectionRange(newCursorPosition, newCursorPosition);\r\n        }\r\n      }\r\n\r\n      if (!isControlled) {\r\n        setInternalValue(newValue);\r\n      }\r\n\r\n      if (shouldValidate(\"change\")) {\r\n        onInputValidate(unmaskedValue);\r\n      }\r\n\r\n      onValueChangeProp?.(newValue, unmaskedValue);\r\n    },\r\n    [\r\n      maskPattern,\r\n      isControlled,\r\n      onValueChangeProp,\r\n      onValidate,\r\n      onInputValidate,\r\n      composing,\r\n      shouldValidate,\r\n      withoutMask,\r\n      transformOpts,\r\n      mask,\r\n      value,\r\n    ],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<InputElement>) => {\r\n      onFocusProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      setFocused(true);\r\n    },\r\n    [onFocusProp],\r\n  );\r\n\r\n  const onBlur = React.useCallback(\r\n    (event: React.FocusEvent<InputElement>) => {\r\n      onBlurProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      setFocused(false);\r\n\r\n      if (!touched) {\r\n        setTouched(true);\r\n      }\r\n\r\n      if (shouldValidate(\"blur\")) {\r\n        const currentValue = event.target.value;\r\n        const unmaskedValue = maskPattern\r\n          ? getUnmaskedValue({\r\n              value: currentValue,\r\n              transform: maskPattern.transform,\r\n              ...transformOpts,\r\n            })\r\n          : currentValue;\r\n        onInputValidate(unmaskedValue);\r\n      }\r\n    },\r\n    [\r\n      onBlurProp,\r\n      touched,\r\n      shouldValidate,\r\n      onInputValidate,\r\n      maskPattern,\r\n      transformOpts,\r\n    ],\r\n  );\r\n\r\n  const onCompositionStart = React.useCallback(\r\n    (event: React.CompositionEvent<InputElement>) => {\r\n      onCompositionStartProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      setComposing(true);\r\n    },\r\n    [onCompositionStartProp],\r\n  );\r\n\r\n  const onCompositionEnd = React.useCallback(\r\n    (event: React.CompositionEvent<InputElement>) => {\r\n      onCompositionEndProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      setComposing(false);\r\n\r\n      const inputElement = inputRef.current;\r\n      if (!inputElement) return;\r\n      if (!(inputElement instanceof HTMLInputElement)) return;\r\n      const inputValue = inputElement.value;\r\n\r\n      if (!maskPattern || withoutMask) {\r\n        if (!isControlled) setInternalValue(inputValue);\r\n        if (shouldValidate(\"change\")) onValidate?.(true, inputValue);\r\n        onValueChangeProp?.(inputValue, inputValue);\r\n        return;\r\n      }\r\n\r\n      const unmasked = getUnmaskedValue({\r\n        value: inputValue,\r\n        transform: maskPattern.transform,\r\n        ...transformOpts,\r\n      });\r\n      const masked = applyMask({\r\n        value: unmasked,\r\n        pattern: maskPattern.pattern,\r\n        ...transformOpts,\r\n        mask,\r\n      });\r\n\r\n      if (!isControlled) setInternalValue(masked);\r\n      if (shouldValidate(\"change\")) onInputValidate(unmasked);\r\n      onValueChangeProp?.(masked, unmasked);\r\n    },\r\n    [\r\n      onCompositionEndProp,\r\n      maskPattern,\r\n      withoutMask,\r\n      isControlled,\r\n      shouldValidate,\r\n      onValidate,\r\n      onValueChangeProp,\r\n      transformOpts,\r\n      mask,\r\n      onInputValidate,\r\n    ],\r\n  );\r\n\r\n  const onPaste = React.useCallback(\r\n    (event: React.ClipboardEvent<InputElement>) => {\r\n      onPasteProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (withoutMask || !maskPattern) return;\r\n\r\n      if (mask === \"ipv4\") return;\r\n\r\n      const target = event.target as InputElement;\r\n      if (!(target instanceof HTMLInputElement)) return;\r\n\r\n      const pastedData = event.clipboardData.getData(\"text\");\r\n      if (!pastedData) return;\r\n\r\n      event.preventDefault();\r\n\r\n      const currentValue = target.value;\r\n      const selectionStart = target.selectionStart ?? 0;\r\n      const selectionEnd = target.selectionEnd ?? 0;\r\n\r\n      const beforeSelection = currentValue.slice(0, selectionStart);\r\n      const afterSelection = currentValue.slice(selectionEnd);\r\n      const newInputValue = beforeSelection + pastedData + afterSelection;\r\n\r\n      const unmasked = getUnmaskedValue({\r\n        value: newInputValue,\r\n        transform: maskPattern.transform,\r\n        ...transformOpts,\r\n      });\r\n      const newMaskedValue = applyMask({\r\n        value: unmasked,\r\n        pattern: maskPattern.pattern,\r\n        ...transformOpts,\r\n        mask,\r\n      });\r\n\r\n      target.value = newMaskedValue;\r\n\r\n      if (isCurrencyMask({ mask, pattern: maskPattern.pattern })) {\r\n        const currencyAtEnd = isCurrencyAtEnd(transformOpts);\r\n        const caret = currencyAtEnd\r\n          ? newMaskedValue.search(/\\s*[^\\d\\s]+$/)\r\n          : newMaskedValue.length;\r\n        target.setSelectionRange(caret, caret);\r\n        return;\r\n      }\r\n\r\n      if (maskPattern.pattern.includes(\"%\")) {\r\n        target.setSelectionRange(\r\n          newMaskedValue.length - 1,\r\n          newMaskedValue.length - 1,\r\n        );\r\n        return;\r\n      }\r\n\r\n      let newCursorPosition = newMaskedValue.length;\r\n      try {\r\n        const unmaskedCount = unmasked.length;\r\n        let position = 0;\r\n        let count = 0;\r\n\r\n        for (\r\n          let i = 0;\r\n          i < maskPattern.pattern.length && i < newMaskedValue.length;\r\n          i++\r\n        ) {\r\n          if (maskPattern.pattern[i] === \"#\") {\r\n            count++;\r\n            if (count <= unmaskedCount) {\r\n              position = i + 1;\r\n            }\r\n          }\r\n        }\r\n        newCursorPosition = position;\r\n      } catch {\r\n        // fallback to end\r\n      }\r\n\r\n      target.setSelectionRange(newCursorPosition, newCursorPosition);\r\n\r\n      if (!isControlled) setInternalValue(newMaskedValue);\r\n      if (shouldValidate(\"change\")) onInputValidate(unmasked);\r\n      onValueChangeProp?.(newMaskedValue, unmasked);\r\n    },\r\n    [\r\n      onPasteProp,\r\n      withoutMask,\r\n      maskPattern,\r\n      mask,\r\n      transformOpts,\r\n      isControlled,\r\n      shouldValidate,\r\n      onInputValidate,\r\n      onValueChangeProp,\r\n    ],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<InputElement>) => {\r\n      onKeyDownProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (withoutMask || !maskPattern) return;\r\n\r\n      if (mask === \"ipv4\") return;\r\n\r\n      if (event.key === \"Backspace\") {\r\n        const target = event.target as InputElement;\r\n        if (!(target instanceof HTMLInputElement)) return;\r\n        const cursorPosition = target.selectionStart ?? 0;\r\n        const selectionEnd = target.selectionEnd ?? 0;\r\n        const currentValue = target.value;\r\n\r\n        if (\r\n          mask === \"currency\" ||\r\n          mask === \"percentage\" ||\r\n          maskPattern.pattern.includes(\"$\") ||\r\n          maskPattern.pattern.includes(\"€\") ||\r\n          maskPattern.pattern.includes(\"%\")\r\n        ) {\r\n          return;\r\n        }\r\n\r\n        if (cursorPosition !== selectionEnd) {\r\n          return;\r\n        }\r\n\r\n        if (cursorPosition > 0) {\r\n          const charBeforeCursor = currentValue[cursorPosition - 1];\r\n\r\n          if (charBeforeCursor) {\r\n            event.preventDefault();\r\n\r\n            const unmaskedIndex = toUnmaskedIndex({\r\n              masked: currentValue,\r\n              pattern: maskPattern.pattern,\r\n              caret: cursorPosition,\r\n            });\r\n\r\n            if (unmaskedIndex > 0) {\r\n              const currentUnmasked = getUnmaskedValue({\r\n                value: currentValue,\r\n                transform: maskPattern.transform,\r\n                ...transformOpts,\r\n              });\r\n              const nextUnmasked =\r\n                currentUnmasked.slice(0, unmaskedIndex - 1) +\r\n                currentUnmasked.slice(unmaskedIndex);\r\n              const nextMasked = applyMask({\r\n                value: nextUnmasked,\r\n                pattern: maskPattern.pattern,\r\n                ...transformOpts,\r\n                mask,\r\n              });\r\n\r\n              target.value = nextMasked;\r\n              const nextCaret = fromUnmaskedIndex({\r\n                masked: nextMasked,\r\n                pattern: maskPattern.pattern,\r\n                unmaskedIndex: unmaskedIndex - 1,\r\n              });\r\n\r\n              target.setSelectionRange(nextCaret, nextCaret);\r\n\r\n              onValueChangeProp?.(nextMasked, nextUnmasked);\r\n            }\r\n            return;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (event.key === \"Delete\") {\r\n        const target = event.target as InputElement;\r\n        if (!(target instanceof HTMLInputElement)) return;\r\n        const cursorPosition = target.selectionStart ?? 0;\r\n        const selectionEnd = target.selectionEnd ?? 0;\r\n        const currentValue = target.value;\r\n\r\n        if (\r\n          mask === \"currency\" ||\r\n          mask === \"percentage\" ||\r\n          maskPattern.pattern.includes(\"$\") ||\r\n          maskPattern.pattern.includes(\"€\") ||\r\n          maskPattern.pattern.includes(\"%\")\r\n        ) {\r\n          return;\r\n        }\r\n\r\n        if (cursorPosition !== selectionEnd) {\r\n          return;\r\n        }\r\n\r\n        if (cursorPosition < currentValue.length) {\r\n          const charAtCursor = currentValue[cursorPosition];\r\n\r\n          if (charAtCursor) {\r\n            event.preventDefault();\r\n\r\n            const unmaskedIndex = toUnmaskedIndex({\r\n              masked: currentValue,\r\n              pattern: maskPattern.pattern,\r\n              caret: cursorPosition,\r\n            });\r\n\r\n            const currentUnmasked = getUnmaskedValue({\r\n              value: currentValue,\r\n              transform: maskPattern.transform,\r\n              ...transformOpts,\r\n            });\r\n\r\n            if (unmaskedIndex < currentUnmasked.length) {\r\n              const nextUnmasked =\r\n                currentUnmasked.slice(0, unmaskedIndex) +\r\n                currentUnmasked.slice(unmaskedIndex + 1);\r\n              const nextMasked = applyMask({\r\n                value: nextUnmasked,\r\n                pattern: maskPattern.pattern,\r\n                ...transformOpts,\r\n                mask,\r\n              });\r\n\r\n              target.value = nextMasked;\r\n              const nextCaret = fromUnmaskedIndex({\r\n                masked: nextMasked,\r\n                pattern: maskPattern.pattern,\r\n                unmaskedIndex: unmaskedIndex,\r\n              });\r\n\r\n              target.setSelectionRange(nextCaret, nextCaret);\r\n\r\n              onValueChangeProp?.(nextMasked, nextUnmasked);\r\n            }\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    },\r\n    [\r\n      maskPattern,\r\n      onKeyDownProp,\r\n      onValueChangeProp,\r\n      transformOpts,\r\n      mask,\r\n      withoutMask,\r\n    ],\r\n  );\r\n\r\n  const InputPrimitive = asChild ? SlotPrimitive.Slot : \"input\";\r\n\r\n  return (\r\n    <InputPrimitive\r\n      aria-invalid={invalid}\r\n      data-disabled={disabled ? \"\" : undefined}\r\n      data-invalid={invalid ? \"\" : undefined}\r\n      data-readonly={readOnly ? \"\" : undefined}\r\n      data-required={required ? \"\" : undefined}\r\n      data-slot=\"mask-input\"\r\n      {...inputProps}\r\n      className={cn(\r\n        \"flex h-9 w-full min-w-0 rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-xs outline-none transition-[color,box-shadow] selection:bg-primary selection:text-primary-foreground file:inline-flex file:h-7 file:border-0 file:bg-transparent file:font-medium file:text-foreground file:text-sm placeholder:text-muted-foreground disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-input/30\",\r\n        \"focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50\",\r\n        \"aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40\",\r\n        className,\r\n      )}\r\n      placeholder={placeholderValue}\r\n      ref={composedRef}\r\n      value={displayValue}\r\n      disabled={disabled}\r\n      maxLength={calculatedMaxLength}\r\n      readOnly={readOnly}\r\n      required={required}\r\n      inputMode={calculatedInputMode}\r\n      min={min}\r\n      max={max}\r\n      onFocus={onFocus}\r\n      onBlur={onBlur}\r\n      onKeyDown={onKeyDown}\r\n      onPaste={onPaste}\r\n      onChange={onValueChange}\r\n      onCompositionStart={onCompositionStart}\r\n      onCompositionEnd={onCompositionEnd}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  MaskInput,\r\n  //\r\n  MASK_PATTERNS,\r\n  //\r\n  applyMask,\r\n  applyCurrencyMask,\r\n  applyPercentageMask,\r\n  getUnmaskedValue,\r\n  toUnmaskedIndex,\r\n  fromUnmaskedIndex,\r\n  //\r\n  type MaskPattern,\r\n  type MaskInputProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}