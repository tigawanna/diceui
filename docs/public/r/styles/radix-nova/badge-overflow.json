{
  "name": "badge-overflow",
  "dependencies": [
    "radix-ui"
  ],
  "files": [
    {
      "path": "ui/badge-overflow.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot as SlotPrimitive } from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ninterface GetBadgeLabel<T> {\r\n  /**\r\n   * Callback that returns a label string for each badge item.\r\n   * Optional for primitive arrays (strings, numbers), required for object arrays.\r\n   * @example getBadgeLabel={(item) => item.name}\r\n   */\r\n  getBadgeLabel: (item: T) => string;\r\n}\r\n\r\ntype BadgeOverflowElement = React.ComponentRef<typeof BadgeOverflow>;\r\n\r\ntype BadgeOverflowProps<T = string> = React.ComponentProps<\"div\"> &\r\n  (T extends object ? GetBadgeLabel<T> : Partial<GetBadgeLabel<T>>) & {\r\n    items: T[];\r\n    lineCount?: number;\r\n    renderBadge: (item: T, label: string) => React.ReactNode;\r\n    renderOverflow?: (count: number) => React.ReactNode;\r\n    asChild?: boolean;\r\n  };\r\n\r\nfunction BadgeOverflow<T = string>(props: BadgeOverflowProps<T>) {\r\n  const {\r\n    items,\r\n    getBadgeLabel: getBadgeLabelProp,\r\n    lineCount = 1,\r\n    renderBadge,\r\n    renderOverflow,\r\n    asChild,\r\n    className,\r\n    style,\r\n    ref,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const getBadgeLabel = React.useCallback(\r\n    (item: T): string => {\r\n      if (typeof item === \"object\" && !getBadgeLabelProp) {\r\n        throw new Error(\r\n          \"`getBadgeLabel` is required when using array of objects\",\r\n        );\r\n      }\r\n      return getBadgeLabelProp ? getBadgeLabelProp(item) : (item as string);\r\n    },\r\n    [getBadgeLabelProp],\r\n  );\r\n\r\n  const rootRef = React.useRef<BadgeOverflowElement | null>(null);\r\n  const composedRef = useComposedRefs(ref, rootRef);\r\n  const measureRef = React.useRef<HTMLDivElement | null>(null);\r\n  const [containerWidth, setContainerWidth] = React.useState(0);\r\n  const [badgeGap, setBadgeGap] = React.useState(4);\r\n  const [badgeHeight, setBadgeHeight] = React.useState(20);\r\n  const [overflowBadgeWidth, setOverflowBadgeWidth] = React.useState(40);\r\n  const [isMeasured, setIsMeasured] = React.useState(false);\r\n  const [badgeWidths, setBadgeWidths] = React.useState<Map<string, number>>(\r\n    new Map(),\r\n  );\r\n\r\n  React.useLayoutEffect(() => {\r\n    if (!rootRef.current || !measureRef.current) return;\r\n\r\n    function measureContainer() {\r\n      if (!rootRef.current || !measureRef.current) return;\r\n\r\n      const computedStyle = getComputedStyle(rootRef.current);\r\n\r\n      const gapValue = computedStyle.gap;\r\n      const gap = gapValue ? parseFloat(gapValue) : 4;\r\n      setBadgeGap(gap);\r\n\r\n      const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;\r\n      const paddingRight = parseFloat(computedStyle.paddingRight) || 0;\r\n      const totalPadding = paddingLeft + paddingRight;\r\n\r\n      const widthMap = new Map<string, number>();\r\n      const measureChildren = measureRef.current.children;\r\n\r\n      for (let i = 0; i < items.length; i++) {\r\n        const child = measureChildren[i] as HTMLElement | undefined;\r\n        if (child) {\r\n          const label = getBadgeLabel(items[i] as T);\r\n          widthMap.set(label, child.offsetWidth);\r\n        }\r\n      }\r\n      setBadgeWidths(widthMap);\r\n\r\n      const firstBadge = measureChildren[0] as HTMLElement | undefined;\r\n      if (firstBadge) {\r\n        setBadgeHeight(firstBadge.offsetHeight || 20);\r\n      }\r\n\r\n      const overflowChild = measureChildren[items.length] as\r\n        | HTMLElement\r\n        | undefined;\r\n\r\n      if (overflowChild) {\r\n        setOverflowBadgeWidth(overflowChild.offsetWidth || 40);\r\n      }\r\n\r\n      const width = rootRef.current.clientWidth - totalPadding;\r\n      setContainerWidth(width);\r\n      setIsMeasured(true);\r\n    }\r\n\r\n    measureContainer();\r\n\r\n    const resizeObserver = new ResizeObserver(measureContainer);\r\n    resizeObserver.observe(rootRef.current);\r\n\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [items, getBadgeLabel]);\r\n\r\n  const placeholderHeight = React.useMemo(\r\n    () => badgeHeight * lineCount + badgeGap * (lineCount - 1),\r\n    [badgeHeight, badgeGap, lineCount],\r\n  );\r\n\r\n  const { visibleItems, hiddenCount } = React.useMemo(() => {\r\n    if (!containerWidth || items.length === 0 || badgeWidths.size === 0) {\r\n      return { visibleItems: items, hiddenCount: 0 };\r\n    }\r\n\r\n    let currentLineWidth = 0;\r\n    let currentLine = 1;\r\n    const visible: T[] = [];\r\n\r\n    for (let i = 0; i < items.length; i++) {\r\n      const item = items[i];\r\n      if (!item) continue;\r\n\r\n      const label = getBadgeLabel(item);\r\n      const badgeWidth = badgeWidths.get(label);\r\n\r\n      if (!badgeWidth) {\r\n        // Skip items that haven't been measured yet\r\n        continue;\r\n      }\r\n\r\n      const widthWithGap = badgeWidth + badgeGap;\r\n      const isLastLine = currentLine === lineCount;\r\n      const hasMoreItems = i < items.length - 1;\r\n\r\n      const availableWidth =\r\n        isLastLine && hasMoreItems\r\n          ? containerWidth - overflowBadgeWidth - badgeGap\r\n          : containerWidth;\r\n\r\n      if (currentLineWidth + widthWithGap <= availableWidth) {\r\n        currentLineWidth += widthWithGap;\r\n        visible.push(item);\r\n      } else if (currentLine < lineCount) {\r\n        currentLine++;\r\n        currentLineWidth = widthWithGap;\r\n        visible.push(item);\r\n      } else {\r\n        // We're on the last line and this badge doesn't fit\r\n        break;\r\n      }\r\n    }\r\n\r\n    return {\r\n      visibleItems: visible,\r\n      hiddenCount: Math.max(0, items.length - visible.length),\r\n    };\r\n  }, [\r\n    items,\r\n    getBadgeLabel,\r\n    containerWidth,\r\n    lineCount,\r\n    badgeGap,\r\n    overflowBadgeWidth,\r\n    badgeWidths,\r\n  ]);\r\n\r\n  const Comp = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <>\r\n      <div\r\n        ref={measureRef}\r\n        className=\"pointer-events-none invisible absolute flex flex-wrap\"\r\n        style={{ gap: badgeGap }}\r\n      >\r\n        {items.map((item, index) => (\r\n          <React.Fragment key={index}>\r\n            {renderBadge(item, getBadgeLabel(item))}\r\n          </React.Fragment>\r\n        ))}\r\n        {renderOverflow ? (\r\n          renderOverflow(99)\r\n        ) : (\r\n          <div className=\"inline-flex h-5 shrink-0 items-center rounded-md border px-1.5 font-semibold text-xs\">\r\n            +99\r\n          </div>\r\n        )}\r\n      </div>\r\n      {isMeasured ? (\r\n        <Comp\r\n          data-slot=\"badge-overflow\"\r\n          {...rootProps}\r\n          ref={composedRef}\r\n          className={cn(\"flex flex-wrap\", className)}\r\n          style={{\r\n            gap: badgeGap,\r\n            ...style,\r\n          }}\r\n        >\r\n          {visibleItems.map((item, index) => (\r\n            <React.Fragment key={index}>\r\n              {renderBadge(item, getBadgeLabel(item))}\r\n            </React.Fragment>\r\n          ))}\r\n          {hiddenCount > 0 &&\r\n            (renderOverflow ? (\r\n              renderOverflow(hiddenCount)\r\n            ) : (\r\n              <div className=\"inline-flex h-5 shrink-0 items-center rounded-md border px-1.5 font-semibold text-xs\">\r\n                +{hiddenCount}\r\n              </div>\r\n            ))}\r\n        </Comp>\r\n      ) : (\r\n        <Comp\r\n          data-slot=\"badge-overflow\"\r\n          {...rootProps}\r\n          ref={composedRef}\r\n          className={cn(\"flex flex-wrap\", className)}\r\n          style={{\r\n            gap: badgeGap,\r\n            minHeight: placeholderHeight,\r\n            ...style,\r\n          }}\r\n        >\r\n          {items\r\n            .slice(\r\n              0,\r\n              Math.min(items.length, lineCount * 3 - (lineCount > 1 ? 1 : 0)),\r\n            )\r\n            .map((item, index) => (\r\n              <React.Fragment key={index}>\r\n                {renderBadge(item, getBadgeLabel(item))}\r\n              </React.Fragment>\r\n            ))}\r\n        </Comp>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n\r\nexport { BadgeOverflow };\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}