{
  "name": "rating",
  "dependencies": [
    "radix-ui"
  ],
  "registryDependencies": [
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/rating.tsx",
      "content": "\"use client\";\r\n\r\nimport { Star } from \"lucide-react\";\r\nimport {\r\n  Direction as DirectionPrimitive,\r\n  Slot as SlotPrimitive,\r\n} from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { VisuallyHiddenInput } from \"@/registry/bases/radix/components/visually-hidden-input\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\ntype Orientation = \"horizontal\" | \"vertical\";\r\ntype ActivationMode = \"automatic\" | \"manual\";\r\ntype Size = \"default\" | \"sm\" | \"lg\";\r\ntype Step = 0.5 | 1;\r\ntype DataState = \"full\" | \"partial\" | \"empty\";\r\ntype FocusIntent = \"first\" | \"last\" | \"prev\" | \"next\";\r\n\r\ntype RootElement = React.ComponentRef<typeof Rating>;\r\ntype ItemElement = React.ComponentRef<typeof RatingItem>;\r\n\r\nconst ROOT_NAME = \"Rating\";\r\nconst ITEM_NAME = \"RatingItem\";\r\n\r\nconst ENTRY_FOCUS = \"ratingFocusGroup.onEntryFocus\";\r\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\r\n\r\nfunction getItemId(id: string, value: number) {\r\n  return `${id}-item-${value}`;\r\n}\r\n\r\nfunction getPartialFillGradientId(id: string, step: Step) {\r\n  return `partial-fill-gradient-${id}-${step}`;\r\n}\r\n\r\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\r\n  ArrowLeft: \"prev\",\r\n  ArrowUp: \"prev\",\r\n  ArrowRight: \"next\",\r\n  ArrowDown: \"next\",\r\n  Home: \"first\",\r\n  End: \"last\",\r\n};\r\n\r\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\r\n  if (dir !== \"rtl\") return key;\r\n  return key === \"ArrowLeft\"\r\n    ? \"ArrowRight\"\r\n    : key === \"ArrowRight\"\r\n      ? \"ArrowLeft\"\r\n      : key;\r\n}\r\n\r\nfunction getFocusIntent(\r\n  event: React.KeyboardEvent<ItemElement>,\r\n  dir?: Direction,\r\n  orientation?: Orientation,\r\n) {\r\n  const key = getDirectionAwareKey(event.key, dir);\r\n  if (orientation === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(key))\r\n    return undefined;\r\n  if (orientation === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(key))\r\n    return undefined;\r\n  return MAP_KEY_TO_FOCUS_INTENT[key];\r\n}\r\n\r\nfunction focusFirst(\r\n  candidates: React.RefObject<ItemElement | null>[],\r\n  preventScroll = false,\r\n) {\r\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\r\n  for (const candidateRef of candidates) {\r\n    const candidate = candidateRef.current;\r\n    if (!candidate) continue;\r\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\r\n    candidate.focus({ preventScroll });\r\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\r\n  }\r\n}\r\n\r\ninterface StoreState {\r\n  value: number;\r\n  hoveredValue: number | null;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  notify: () => void;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(\r\n  selector: (state: StoreState) => T,\r\n  ogStore?: Store | null,\r\n): T {\r\n  const contextStore = React.useContext(StoreContext);\r\n\r\n  const store = ogStore ?? contextStore;\r\n\r\n  if (!store) {\r\n    throw new Error(`\\`useStore\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface ItemData {\r\n  id: string;\r\n  ref: React.RefObject<ItemElement | null>;\r\n  value: number;\r\n  disabled: boolean;\r\n}\r\n\r\ninterface RatingContextValue {\r\n  rootId: string;\r\n  dir: Direction;\r\n  orientation: Orientation;\r\n  activationMode: ActivationMode;\r\n  size: Size;\r\n  max: number;\r\n  step: Step;\r\n  clearable: boolean;\r\n  disabled: boolean;\r\n  readOnly: boolean;\r\n  getAutoIndex: (instanceId: string) => number;\r\n}\r\n\r\nconst RatingContext = React.createContext<RatingContextValue | null>(null);\r\n\r\nfunction useRatingContext(consumerName: string) {\r\n  const context = React.useContext(RatingContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface FocusContextValue {\r\n  tabStopId: string | null;\r\n  onItemFocus: (tabStopId: string) => void;\r\n  onItemShiftTab: () => void;\r\n  onFocusableItemAdd: () => void;\r\n  onFocusableItemRemove: () => void;\r\n  onItemRegister: (item: ItemData) => void;\r\n  onItemUnregister: (id: string) => void;\r\n  getItems: () => ItemData[];\r\n}\r\n\r\nconst FocusContext = React.createContext<FocusContextValue | null>(null);\r\n\r\nfunction useFocusContext(consumerName: string) {\r\n  const context = React.useContext(FocusContext);\r\n  if (!context) {\r\n    throw new Error(\r\n      `\\`${consumerName}\\` must be used within \\`FocusProvider\\``,\r\n    );\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface RatingProps extends React.ComponentProps<\"div\"> {\r\n  value?: number;\r\n  defaultValue?: number;\r\n  onValueChange?: (value: number) => void;\r\n  onHover?: (value: number | null) => void;\r\n  max?: number;\r\n  activationMode?: ActivationMode;\r\n  dir?: Direction;\r\n  orientation?: Orientation;\r\n  size?: Size;\r\n  asChild?: boolean;\r\n  step?: Step;\r\n  clearable?: boolean;\r\n  disabled?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  name?: string;\r\n}\r\n\r\nfunction Rating(props: RatingProps) {\r\n  const {\r\n    value: valueProp,\r\n    defaultValue = 0,\r\n    onValueChange,\r\n    onHover,\r\n    onFocus: onFocusProp,\r\n    onMouseDown: onMouseDownProp,\r\n    dir: dirProp,\r\n    orientation = \"horizontal\",\r\n    activationMode = \"automatic\",\r\n    size = \"default\",\r\n    max = 5,\r\n    step = 1,\r\n    clearable = false,\r\n    asChild,\r\n    disabled = false,\r\n    readOnly = false,\r\n    required = false,\r\n    className,\r\n    id,\r\n    name,\r\n    ref,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const dir = DirectionPrimitive.useDirection(dirProp);\r\n  const instanceId = React.useId();\r\n  const rootId = id ?? instanceId;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    value: valueProp ?? defaultValue,\r\n    hoveredValue: null,\r\n  }));\r\n\r\n  const propsRef = useAsRef({\r\n    onValueChange,\r\n    onHover,\r\n    onFocus: onFocusProp,\r\n    onMouseDown: onMouseDownProp,\r\n    step,\r\n  });\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n\r\n        if (key === \"value\" && typeof value === \"number\") {\r\n          stateRef.current.value = value;\r\n          propsRef.current.onValueChange?.(value);\r\n        } else if (key === \"hoveredValue\") {\r\n          stateRef.current.hoveredValue = value as number | null;\r\n          propsRef.current.onHover?.(value as number | null);\r\n        } else {\r\n          stateRef.current[key] = value;\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (valueProp !== undefined) {\r\n      store.setState(\"value\", valueProp);\r\n    }\r\n  }, [valueProp]);\r\n\r\n  const value = useStore((state) => state.value, store);\r\n\r\n  const [formTrigger, setFormTrigger] = React.useState<RootElement | null>(\r\n    null,\r\n  );\r\n  const composedRef = useComposedRefs(ref, (node) => setFormTrigger(node));\r\n  const isFormControl = formTrigger ? !!formTrigger.closest(\"form\") : true;\r\n\r\n  const [tabStopId, setTabStopId] = React.useState<string | null>(null);\r\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\r\n  const [focusableItemCount, setFocusableItemCount] = React.useState(0);\r\n  const isClickFocusRef = React.useRef(false);\r\n  const itemsRef = React.useRef<Map<string, ItemData>>(new Map());\r\n\r\n  const autoIndexMapRef = React.useRef(new Map<string, number>());\r\n  const nextAutoIndexRef = React.useRef(0);\r\n\r\n  const getAutoIndex = React.useCallback((instanceId: string) => {\r\n    const existingIndex = autoIndexMapRef.current.get(instanceId);\r\n    if (existingIndex !== undefined) {\r\n      return existingIndex;\r\n    }\r\n\r\n    const newIndex = nextAutoIndexRef.current++;\r\n    autoIndexMapRef.current.set(instanceId, newIndex);\r\n    return newIndex;\r\n  }, []);\r\n\r\n  const onItemFocus = React.useCallback((tabStopId: string) => {\r\n    setTabStopId(tabStopId);\r\n  }, []);\r\n\r\n  const onItemShiftTab = React.useCallback(() => {\r\n    setIsTabbingBackOut(true);\r\n  }, []);\r\n\r\n  const onFocusableItemAdd = React.useCallback(() => {\r\n    setFocusableItemCount((prevCount) => prevCount + 1);\r\n  }, []);\r\n\r\n  const onFocusableItemRemove = React.useCallback(() => {\r\n    setFocusableItemCount((prevCount) => prevCount - 1);\r\n  }, []);\r\n\r\n  const onItemRegister = React.useCallback((item: ItemData) => {\r\n    itemsRef.current.set(item.id, item);\r\n  }, []);\r\n\r\n  const onItemUnregister = React.useCallback((id: string) => {\r\n    itemsRef.current.delete(id);\r\n  }, []);\r\n\r\n  const getItems = React.useCallback(() => {\r\n    return Array.from(itemsRef.current.values())\r\n      .filter((item) => item.ref.current)\r\n      .sort((a, b) => {\r\n        const elementA = a.ref.current;\r\n        const elementB = b.ref.current;\r\n        if (!elementA || !elementB) return 0;\r\n        const position = elementA.compareDocumentPosition(elementB);\r\n        if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\r\n          return -1;\r\n        }\r\n        if (position & Node.DOCUMENT_POSITION_PRECEDING) {\r\n          return 1;\r\n        }\r\n        return 0;\r\n      });\r\n  }, []);\r\n\r\n  const onBlur = React.useCallback(\r\n    (event: React.FocusEvent<HTMLDivElement>) => {\r\n      rootProps.onBlur?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      setIsTabbingBackOut(false);\r\n    },\r\n    [rootProps.onBlur],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<HTMLDivElement>) => {\r\n      propsRef.current.onFocus?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const isKeyboardFocus = !isClickFocusRef.current;\r\n      if (\r\n        event.target === event.currentTarget &&\r\n        isKeyboardFocus &&\r\n        !isTabbingBackOut\r\n      ) {\r\n        const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\r\n        event.currentTarget.dispatchEvent(entryFocusEvent);\r\n\r\n        if (!entryFocusEvent.defaultPrevented) {\r\n          const items = Array.from(itemsRef.current.values()).filter(\r\n            (item) => !item.disabled,\r\n          );\r\n          // For half-step ratings, find the item that represents the selected value\r\n          // by looking for the ceiling value (e.g., 3.5 â†’ find item with value 4)\r\n          const selectedItem =\r\n            propsRef.current.step < 1\r\n              ? items.find((item) => item.value === Math.ceil(value))\r\n              : items.find((item) => item.value === value);\r\n          const currentItem = items.find((item) => item.id === tabStopId);\r\n\r\n          const candidateItems = [selectedItem, currentItem, ...items].filter(\r\n            Boolean,\r\n          ) as ItemData[];\r\n          const candidateRefs = candidateItems.map((item) => item.ref);\r\n          focusFirst(candidateRefs, false);\r\n        }\r\n      }\r\n      isClickFocusRef.current = false;\r\n    },\r\n    [propsRef, isTabbingBackOut, value, tabStopId],\r\n  );\r\n\r\n  const onMouseDown = React.useCallback(\r\n    (event: React.MouseEvent<HTMLDivElement>) => {\r\n      propsRef.current.onMouseDown?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      isClickFocusRef.current = true;\r\n    },\r\n    [propsRef],\r\n  );\r\n\r\n  const contextValue = React.useMemo<RatingContextValue>(\r\n    () => ({\r\n      rootId,\r\n      dir,\r\n      orientation,\r\n      activationMode,\r\n      disabled,\r\n      readOnly,\r\n      size,\r\n      max,\r\n      step,\r\n      clearable,\r\n      getAutoIndex,\r\n    }),\r\n    [\r\n      rootId,\r\n      dir,\r\n      orientation,\r\n      activationMode,\r\n      disabled,\r\n      readOnly,\r\n      size,\r\n      max,\r\n      step,\r\n      clearable,\r\n      getAutoIndex,\r\n    ],\r\n  );\r\n\r\n  const focusContextValue = React.useMemo<FocusContextValue>(\r\n    () => ({\r\n      tabStopId,\r\n      onItemFocus,\r\n      onItemShiftTab,\r\n      onFocusableItemAdd,\r\n      onFocusableItemRemove,\r\n      onItemRegister,\r\n      onItemUnregister,\r\n      getItems,\r\n    }),\r\n    [\r\n      tabStopId,\r\n      onItemFocus,\r\n      onItemShiftTab,\r\n      onFocusableItemAdd,\r\n      onFocusableItemRemove,\r\n      onItemRegister,\r\n      onItemUnregister,\r\n      getItems,\r\n    ],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <RatingContext.Provider value={contextValue}>\r\n        <FocusContext.Provider value={focusContextValue}>\r\n          <RootPrimitive\r\n            id={rootId}\r\n            role=\"radiogroup\"\r\n            aria-orientation={orientation}\r\n            data-disabled={disabled ? \"\" : undefined}\r\n            data-readonly={readOnly ? \"\" : undefined}\r\n            data-orientation={orientation}\r\n            data-slot=\"rating\"\r\n            dir={dir}\r\n            tabIndex={isTabbingBackOut || focusableItemCount === 0 ? -1 : 0}\r\n            {...rootProps}\r\n            ref={composedRef}\r\n            className={cn(\r\n              \"flex gap-1 text-primary outline-none\",\r\n              orientation === \"horizontal\"\r\n                ? \"flex-row items-center\"\r\n                : \"flex-col items-start\",\r\n              className,\r\n            )}\r\n            onBlur={onBlur}\r\n            onFocus={onFocus}\r\n            onMouseDown={onMouseDown}\r\n          />\r\n          <svg width=\"0\" height=\"0\" style={{ position: \"absolute\" }}>\r\n            <defs>\r\n              <linearGradient id={getPartialFillGradientId(rootId, step)}>\r\n                {dir === \"rtl\" ? (\r\n                  <>\r\n                    <stop offset=\"50%\" stopColor=\"transparent\" />\r\n                    <stop offset=\"50%\" stopColor=\"currentColor\" />\r\n                  </>\r\n                ) : (\r\n                  <>\r\n                    <stop offset=\"50%\" stopColor=\"currentColor\" />\r\n                    <stop offset=\"50%\" stopColor=\"transparent\" />\r\n                  </>\r\n                )}\r\n              </linearGradient>\r\n            </defs>\r\n          </svg>\r\n          {isFormControl && (\r\n            <VisuallyHiddenInput\r\n              type=\"hidden\"\r\n              control={formTrigger}\r\n              name={name}\r\n              value={value}\r\n              disabled={disabled}\r\n              readOnly={readOnly}\r\n              required={required}\r\n            />\r\n          )}\r\n        </FocusContext.Provider>\r\n      </RatingContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface RatingItemProps\r\n  extends Omit<React.ComponentProps<\"button\">, \"children\"> {\r\n  index?: number;\r\n  asChild?: boolean;\r\n  children?: React.ReactNode | ((dataState: DataState) => React.ReactNode);\r\n}\r\n\r\nfunction RatingItem(props: RatingItemProps) {\r\n  const {\r\n    index,\r\n    asChild,\r\n    onClick: onClickProp,\r\n    onFocus: onFocusProp,\r\n    onKeyDown: onKeyDownProp,\r\n    onMouseDown: onMouseDownProp,\r\n    onMouseEnter: onMouseEnterProp,\r\n    onMouseMove: onMouseMoveProp,\r\n    onMouseLeave: onMouseLeaveProp,\r\n    disabled,\r\n    className,\r\n    children,\r\n    ref,\r\n    ...itemProps\r\n  } = props;\r\n\r\n  const itemRef = React.useRef<ItemElement>(null);\r\n  const composedRef = useComposedRefs(ref, itemRef);\r\n\r\n  const context = useRatingContext(ITEM_NAME);\r\n\r\n  const instanceId = React.useId();\r\n\r\n  const actualIndex = React.useMemo(() => {\r\n    if (index !== undefined) {\r\n      return index;\r\n    }\r\n\r\n    return context.getAutoIndex(instanceId);\r\n  }, [index, context, instanceId]);\r\n\r\n  const itemValue = actualIndex + 1;\r\n  const store = useStoreContext(ITEM_NAME);\r\n  const focusContext = useFocusContext(ITEM_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const hoveredValue = useStore((state) => state.hoveredValue);\r\n  const clearable = context.clearable;\r\n  const step = context.step;\r\n  const activationMode = context.activationMode;\r\n\r\n  const itemId = getItemId(context.rootId, itemValue);\r\n  const isDisabled = context.disabled || disabled;\r\n  const isReadOnly = context.readOnly;\r\n  const isTabStop = focusContext.tabStopId === itemId;\r\n\r\n  const displayValue = hoveredValue ?? value;\r\n  const isFilled = displayValue >= itemValue;\r\n  const isPartiallyFilled =\r\n    step < 1 && displayValue >= itemValue - step && displayValue < itemValue;\r\n  const isHovered = hoveredValue !== null && hoveredValue < itemValue;\r\n\r\n  const isMouseClickRef = React.useRef(false);\r\n\r\n  const propsRef = useAsRef({\r\n    onClick: onClickProp,\r\n    onFocus: onFocusProp,\r\n    onKeyDown: onKeyDownProp,\r\n    onMouseDown: onMouseDownProp,\r\n    onMouseEnter: onMouseEnterProp,\r\n    onMouseMove: onMouseMoveProp,\r\n    onMouseLeave: onMouseLeaveProp,\r\n  });\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    focusContext.onItemRegister({\r\n      id: itemId,\r\n      ref: itemRef,\r\n      value: itemValue,\r\n      disabled: !!isDisabled,\r\n    });\r\n\r\n    if (!isDisabled) {\r\n      focusContext.onFocusableItemAdd();\r\n    }\r\n\r\n    return () => {\r\n      focusContext.onItemUnregister(itemId);\r\n      if (!isDisabled) {\r\n        focusContext.onFocusableItemRemove();\r\n      }\r\n    };\r\n  }, [focusContext, itemId, itemValue, isDisabled]);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<ItemElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (!isDisabled && !isReadOnly) {\r\n        let newValue = itemValue;\r\n\r\n        if (step < 1) {\r\n          const rect = event.currentTarget.getBoundingClientRect();\r\n          const clickX = event.clientX - rect.left;\r\n          const isLeftHalf = clickX < rect.width / 2;\r\n\r\n          if (context.dir === \"rtl\") {\r\n            if (!isLeftHalf) {\r\n              newValue = itemValue - step;\r\n            }\r\n          } else {\r\n            if (isLeftHalf) {\r\n              newValue = itemValue - step;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (clearable && value === newValue) {\r\n          newValue = 0;\r\n        }\r\n\r\n        store.setState(\"value\", newValue);\r\n      }\r\n    },\r\n    [\r\n      isDisabled,\r\n      isReadOnly,\r\n      clearable,\r\n      step,\r\n      value,\r\n      itemValue,\r\n      store,\r\n      context.dir,\r\n      propsRef,\r\n    ],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<ItemElement>) => {\r\n      propsRef.current.onFocus?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      focusContext.onItemFocus(itemId);\r\n\r\n      const isKeyboardFocus = !isMouseClickRef.current;\r\n\r\n      if (\r\n        !isDisabled &&\r\n        !isReadOnly &&\r\n        activationMode !== \"manual\" &&\r\n        isKeyboardFocus\r\n      ) {\r\n        // For half-step mode, check if the current value is a half-step that belongs to this item\r\n        // e.g., if value is 3.5 and itemValue is 4, don't change it\r\n        const isHalfStepValue = step < 1 && value === itemValue - step;\r\n\r\n        if (!isHalfStepValue) {\r\n          const newValue = clearable && value === itemValue ? 0 : itemValue;\r\n          store.setState(\"value\", newValue);\r\n        }\r\n      }\r\n\r\n      isMouseClickRef.current = false;\r\n    },\r\n    [\r\n      focusContext,\r\n      itemId,\r\n      activationMode,\r\n      isDisabled,\r\n      isReadOnly,\r\n      clearable,\r\n      value,\r\n      itemValue,\r\n      step,\r\n      store,\r\n      propsRef,\r\n    ],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<ItemElement>) => {\r\n      propsRef.current.onKeyDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (\r\n        (event.key === \"Enter\" || event.key === \" \") &&\r\n        activationMode === \"manual\"\r\n      ) {\r\n        event.preventDefault();\r\n        if (!isDisabled && !isReadOnly && itemRef.current) {\r\n          itemRef.current.click();\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (event.key === \"Tab\" && event.shiftKey) {\r\n        focusContext.onItemShiftTab();\r\n        return;\r\n      }\r\n\r\n      if (event.target !== event.currentTarget) return;\r\n\r\n      const focusIntent = getFocusIntent(\r\n        event,\r\n        context.dir,\r\n        context.orientation,\r\n      );\r\n\r\n      if (focusIntent !== undefined) {\r\n        if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)\r\n          return;\r\n        event.preventDefault();\r\n\r\n        // For half-step mode, increment/decrement by step value instead of jumping to next item\r\n        if (step < 1 && (focusIntent === \"prev\" || focusIntent === \"next\")) {\r\n          if (!isDisabled && !isReadOnly) {\r\n            let newValue = value;\r\n\r\n            if (focusIntent === \"next\") {\r\n              newValue = Math.min(value + step, context.max);\r\n            } else {\r\n              newValue = Math.max(value - step, 0);\r\n            }\r\n\r\n            store.setState(\"value\", newValue);\r\n\r\n            // Find and focus the item that represents this value\r\n            const items = focusContext\r\n              .getItems()\r\n              .filter((item) => !item.disabled);\r\n            const targetItem = items.find(\r\n              (item) => item.value === Math.ceil(newValue),\r\n            );\r\n            if (targetItem?.ref.current) {\r\n              queueMicrotask(() => targetItem.ref.current?.focus());\r\n            }\r\n          }\r\n          return;\r\n        }\r\n\r\n        // For full-step mode or Home/End keys, use the original navigation\r\n        const items = focusContext.getItems().filter((item) => !item.disabled);\r\n        let candidateRefs = items.map((item) => item.ref);\r\n\r\n        if (focusIntent === \"last\") {\r\n          candidateRefs.reverse();\r\n        } else if (focusIntent === \"prev\" || focusIntent === \"next\") {\r\n          if (focusIntent === \"prev\") candidateRefs.reverse();\r\n          const currentIndex = candidateRefs.findIndex(\r\n            (ref) => ref.current === event.currentTarget,\r\n          );\r\n          candidateRefs = candidateRefs.slice(currentIndex + 1);\r\n        }\r\n\r\n        queueMicrotask(() => focusFirst(candidateRefs));\r\n      }\r\n    },\r\n    [\r\n      focusContext,\r\n      context.dir,\r\n      context.orientation,\r\n      activationMode,\r\n      isDisabled,\r\n      isReadOnly,\r\n      step,\r\n      value,\r\n      context.max,\r\n      store,\r\n      propsRef,\r\n    ],\r\n  );\r\n\r\n  const onMouseDown = React.useCallback(\r\n    (event: React.MouseEvent<ItemElement>) => {\r\n      propsRef.current.onMouseDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      isMouseClickRef.current = true;\r\n\r\n      if (isDisabled) {\r\n        event.preventDefault();\r\n      } else {\r\n        focusContext.onItemFocus(itemId);\r\n      }\r\n    },\r\n    [focusContext, itemId, isDisabled, propsRef],\r\n  );\r\n\r\n  const onMouseEnter = React.useCallback(\r\n    (event: React.MouseEvent<ItemElement>) => {\r\n      propsRef.current.onMouseEnter?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (!isDisabled && !isReadOnly) {\r\n        let hoverValue = itemValue;\r\n\r\n        if (step < 1) {\r\n          const rect = event.currentTarget.getBoundingClientRect();\r\n          const mouseX = event.clientX - rect.left;\r\n          const isLeftHalf = mouseX < rect.width / 2;\r\n\r\n          if (context.dir === \"rtl\") {\r\n            if (!isLeftHalf) {\r\n              hoverValue = itemValue - step;\r\n            }\r\n          } else {\r\n            if (isLeftHalf) {\r\n              hoverValue = itemValue - step;\r\n            }\r\n          }\r\n        }\r\n\r\n        store.setState(\"hoveredValue\", hoverValue);\r\n      }\r\n    },\r\n    [isDisabled, isReadOnly, step, itemValue, store, context.dir, propsRef],\r\n  );\r\n\r\n  const onMouseLeave = React.useCallback(\r\n    (event: React.MouseEvent<ItemElement>) => {\r\n      propsRef.current.onMouseLeave?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (!isDisabled && !isReadOnly) {\r\n        store.setState(\"hoveredValue\", null);\r\n      }\r\n    },\r\n    [isDisabled, isReadOnly, store, propsRef],\r\n  );\r\n\r\n  const onMouseMove = React.useCallback(\r\n    (event: React.MouseEvent<ItemElement>) => {\r\n      propsRef.current.onMouseMove?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (!isDisabled && !isReadOnly && step < 1) {\r\n        const rect = event.currentTarget.getBoundingClientRect();\r\n        const mouseX = event.clientX - rect.left;\r\n        const isLeftHalf = mouseX < rect.width / 2;\r\n\r\n        let hoverValue = itemValue;\r\n        if (context.dir === \"rtl\") {\r\n          hoverValue = !isLeftHalf ? itemValue - step : itemValue;\r\n        } else {\r\n          hoverValue = isLeftHalf ? itemValue - step : itemValue;\r\n        }\r\n\r\n        store.setState(\"hoveredValue\", hoverValue);\r\n      }\r\n    },\r\n    [isDisabled, isReadOnly, step, itemValue, store, context.dir, propsRef],\r\n  );\r\n\r\n  const dataState: DataState = isFilled\r\n    ? \"full\"\r\n    : isPartiallyFilled\r\n      ? \"partial\"\r\n      : \"empty\";\r\n\r\n  const ItemPrimitive = asChild ? SlotPrimitive.Slot : \"button\";\r\n\r\n  return (\r\n    <ItemPrimitive\r\n      role=\"radio\"\r\n      type=\"button\"\r\n      id={itemId}\r\n      aria-checked={isFilled}\r\n      aria-posinset={itemValue}\r\n      aria-setsize={context.max}\r\n      data-disabled={isDisabled ? \"\" : undefined}\r\n      data-readonly={isReadOnly ? \"\" : undefined}\r\n      data-state={isFilled ? \"full\" : isPartiallyFilled ? \"partial\" : \"empty\"}\r\n      data-hovered={isHovered ? \"\" : undefined}\r\n      data-slot=\"rating-item\"\r\n      disabled={isDisabled}\r\n      tabIndex={isTabStop ? 0 : -1}\r\n      {...itemProps}\r\n      ref={composedRef}\r\n      style={{\r\n        ...itemProps.style,\r\n        ...(isPartiallyFilled && {\r\n          \"--partial-fill\": `url(#${getPartialFillGradientId(context.rootId, step)})`,\r\n        }),\r\n      }}\r\n      className={cn(\r\n        \"inline-flex items-center justify-center rounded transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-ring/50 disabled:pointer-events-none disabled:opacity-50\",\r\n        \"[&_svg:not([class*='size-'])]:size-full [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg]:transition-colors [&_svg]:duration-200 data-[state=empty]:[&_svg]:fill-transparent data-[state=full]:[&_svg]:fill-current data-[state=partial]:[&_svg]:fill-(--partial-fill)\",\r\n        context.size === \"sm\"\r\n          ? \"size-4\"\r\n          : context.size === \"lg\"\r\n            ? \"size-6\"\r\n            : \"size-5\",\r\n        className,\r\n      )}\r\n      onClick={onClick}\r\n      onFocus={onFocus}\r\n      onKeyDown={onKeyDown}\r\n      onMouseDown={onMouseDown}\r\n      onMouseEnter={onMouseEnter}\r\n      onMouseMove={onMouseMove}\r\n      onMouseLeave={onMouseLeave}\r\n    >\r\n      {typeof children === \"function\"\r\n        ? children(dataState)\r\n        : (children ?? <Star />)}\r\n    </ItemPrimitive>\r\n  );\r\n}\r\n\r\nexport {\r\n  Rating,\r\n  RatingItem,\r\n  //\r\n  useStore as useRating,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\n\r\ntype InputValue = string[] | string;\r\n\r\ninterface VisuallyHiddenInputProps<T = InputValue>\r\n  extends Omit<\r\n    React.InputHTMLAttributes<HTMLInputElement>,\r\n    \"value\" | \"checked\" | \"onReset\"\r\n  > {\r\n  value?: T;\r\n  checked?: boolean;\r\n  control: HTMLElement | null;\r\n  bubbles?: boolean;\r\n}\r\n\r\nfunction VisuallyHiddenInput<T = InputValue>(\r\n  props: VisuallyHiddenInputProps<T>,\r\n) {\r\n  const {\r\n    control,\r\n    value,\r\n    checked,\r\n    bubbles = true,\r\n    type = \"hidden\",\r\n    style,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const isCheckInput = React.useMemo(\r\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\r\n    [type],\r\n  );\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  const prevValueRef = React.useRef<{\r\n    value: T | boolean | undefined;\r\n    previous: T | boolean | undefined;\r\n  }>({\r\n    value: isCheckInput ? checked : value,\r\n    previous: isCheckInput ? checked : value,\r\n  });\r\n\r\n  const prevValue = React.useMemo(() => {\r\n    const currentValue = isCheckInput ? checked : value;\r\n    if (prevValueRef.current.value !== currentValue) {\r\n      prevValueRef.current.previous = prevValueRef.current.value;\r\n      prevValueRef.current.value = currentValue;\r\n    }\r\n    return prevValueRef.current.previous;\r\n  }, [isCheckInput, value, checked]);\r\n\r\n  const [controlSize, setControlSize] = React.useState<{\r\n    width?: number;\r\n    height?: number;\r\n  }>({});\r\n\r\n  React.useLayoutEffect(() => {\r\n    if (!control) {\r\n      setControlSize({});\r\n      return;\r\n    }\r\n\r\n    setControlSize({\r\n      width: control.offsetWidth,\r\n      height: control.offsetHeight,\r\n    });\r\n\r\n    if (typeof window === \"undefined\") return;\r\n\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      if (!Array.isArray(entries) || !entries.length) return;\r\n\r\n      const entry = entries[0];\r\n      if (!entry) return;\r\n\r\n      let width: number;\r\n      let height: number;\r\n\r\n      if (\"borderBoxSize\" in entry) {\r\n        const borderSizeEntry = entry.borderBoxSize;\r\n        const borderSize = Array.isArray(borderSizeEntry)\r\n          ? borderSizeEntry[0]\r\n          : borderSizeEntry;\r\n        width = borderSize.inlineSize;\r\n        height = borderSize.blockSize;\r\n      } else {\r\n        width = control.offsetWidth;\r\n        height = control.offsetHeight;\r\n      }\r\n\r\n      setControlSize({ width, height });\r\n    });\r\n\r\n    resizeObserver.observe(control, { box: \"border-box\" });\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [control]);\r\n\r\n  React.useEffect(() => {\r\n    const input = inputRef.current;\r\n    if (!input) return;\r\n\r\n    const inputProto = window.HTMLInputElement.prototype;\r\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\r\n    const eventType = isCheckInput ? \"click\" : \"input\";\r\n    const currentValue = isCheckInput ? checked : value;\r\n\r\n    const serializedCurrentValue = isCheckInput\r\n      ? checked\r\n      : typeof value === \"object\" && value !== null\r\n        ? JSON.stringify(value)\r\n        : value;\r\n\r\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\r\n\r\n    const setter = descriptor?.set;\r\n\r\n    if (prevValue !== currentValue && setter) {\r\n      const event = new Event(eventType, { bubbles });\r\n      setter.call(input, serializedCurrentValue);\r\n      input.dispatchEvent(event);\r\n    }\r\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\r\n\r\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\r\n    return {\r\n      ...style,\r\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\r\n        ? controlSize\r\n        : {}),\r\n      border: 0,\r\n      clip: \"rect(0 0 0 0)\",\r\n      clipPath: \"inset(50%)\",\r\n      height: \"1px\",\r\n      margin: \"-1px\",\r\n      overflow: \"hidden\",\r\n      padding: 0,\r\n      position: \"absolute\",\r\n      whiteSpace: \"nowrap\",\r\n      width: \"1px\",\r\n    };\r\n  }, [style, controlSize]);\r\n\r\n  return (\r\n    <input\r\n      type={type}\r\n      {...inputProps}\r\n      ref={inputRef}\r\n      aria-hidden={isCheckInput}\r\n      tabIndex={-1}\r\n      defaultChecked={isCheckInput ? checked : undefined}\r\n      style={composedStyle}\r\n    />\r\n  );\r\n}\r\n\r\nexport { VisuallyHiddenInput };\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}