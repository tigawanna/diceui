{
  "name": "media-player",
  "dependencies": [
    "radix-ui",
    "media-chrome"
  ],
  "registryDependencies": [
    "badge",
    "button",
    "select",
    "slider",
    "tooltip",
    "dropdown-menu",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/media-player.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  AlertTriangleIcon,\r\n  CaptionsOffIcon,\r\n  CheckIcon,\r\n  DownloadIcon,\r\n  FastForwardIcon,\r\n  Loader2Icon,\r\n  Maximize2Icon,\r\n  Minimize2Icon,\r\n  PauseIcon,\r\n  PictureInPicture2Icon,\r\n  PictureInPictureIcon,\r\n  PlayIcon,\r\n  RefreshCcwIcon,\r\n  RepeatIcon,\r\n  RewindIcon,\r\n  RotateCcwIcon,\r\n  SettingsIcon,\r\n  SubtitlesIcon,\r\n  Volume1Icon,\r\n  Volume2Icon,\r\n  VolumeXIcon,\r\n} from \"lucide-react\";\r\nimport {\r\n  MediaActionTypes,\r\n  MediaProvider,\r\n  timeUtils,\r\n  useMediaDispatch,\r\n  useMediaFullscreenRef,\r\n  useMediaRef,\r\n  useMediaSelector,\r\n} from \"media-chrome/react/media-store\";\r\nimport {\r\n  Direction as DirectionPrimitive,\r\n  Slider as SliderPrimitive,\r\n  Slot as SlotPrimitive,\r\n} from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { Badge } from \"@/components/ui/badge\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport {\r\n  DropdownMenu,\r\n  DropdownMenuContent,\r\n  DropdownMenuItem,\r\n  DropdownMenuLabel,\r\n  DropdownMenuSub,\r\n  DropdownMenuSubContent,\r\n  DropdownMenuSubTrigger,\r\n  DropdownMenuTrigger,\r\n} from \"@/components/ui/dropdown-menu\";\r\nimport {\r\n  Tooltip,\r\n  TooltipContent,\r\n  TooltipTrigger,\r\n} from \"@/components/ui/tooltip\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"MediaPlayer\";\r\nconst SEEK_NAME = \"MediaPlayerSeek\";\r\nconst SETTINGS_NAME = \"MediaPlayerSettings\";\r\nconst VOLUME_NAME = \"MediaPlayerVolume\";\r\nconst PLAYBACK_SPEED_NAME = \"MediaPlayerPlaybackSpeed\";\r\n\r\nconst FLOATING_MENU_SIDE_OFFSET = 10;\r\nconst SPEEDS = [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];\r\n\r\nconst SEEK_STEP_SHORT = 5;\r\nconst SEEK_STEP_LONG = 10;\r\nconst SEEK_COLLISION_PADDING = 10;\r\nconst SEEK_TOOLTIP_WIDTH_FALLBACK = 240;\r\n\r\nconst SEEK_HOVER_PERCENT = \"--seek-hover-percent\";\r\nconst SEEK_TOOLTIP_X = \"--seek-tooltip-x\";\r\nconst SEEK_TOOLTIP_Y = \"--seek-tooltip-y\";\r\n\r\nconst SPRITE_CONTAINER_WIDTH = 224;\r\nconst SPRITE_CONTAINER_HEIGHT = 128;\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof MediaPlayer>;\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\ninterface StoreState {\r\n  controlsVisible: boolean;\r\n  dragging: boolean;\r\n  menuOpen: boolean;\r\n  volumeIndicatorVisible: boolean;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (cb: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: (\r\n    key: keyof StoreState,\r\n    value: StoreState[keyof StoreState],\r\n  ) => void;\r\n  notify: () => void;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: StoreState) => T): T {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface MediaPlayerContextValue {\r\n  mediaId: string;\r\n  labelId: string;\r\n  descriptionId: string;\r\n  dir: Direction;\r\n  rootRef: React.RefObject<RootElement | null>;\r\n  mediaRef: React.RefObject<HTMLVideoElement | HTMLAudioElement | null>;\r\n  portalContainer: Element | DocumentFragment | null;\r\n  tooltipDelayDuration: number;\r\n  tooltipSideOffset: number;\r\n  disabled: boolean;\r\n  isVideo: boolean;\r\n  withoutTooltip: boolean;\r\n}\r\n\r\nconst MediaPlayerContext = React.createContext<MediaPlayerContextValue | null>(\r\n  null,\r\n);\r\n\r\nfunction useMediaPlayerContext(consumerName: string) {\r\n  const context = React.useContext(MediaPlayerContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface MediaPlayerProps\r\n  extends Omit<DivProps, \"onTimeUpdate\" | \"onVolumeChange\"> {\r\n  onPlay?: () => void;\r\n  onPause?: () => void;\r\n  onEnded?: () => void;\r\n  onTimeUpdate?: (time: number) => void;\r\n  onVolumeChange?: (volume: number) => void;\r\n  onMuted?: (muted: boolean) => void;\r\n  onMediaError?: (error: MediaError | null) => void;\r\n  onPipError?: (error: unknown, state: \"enter\" | \"exit\") => void;\r\n  onFullscreenChange?: (fullscreen: boolean) => void;\r\n  dir?: Direction;\r\n  label?: string;\r\n  tooltipDelayDuration?: number;\r\n  tooltipSideOffset?: number;\r\n  autoHide?: boolean;\r\n  disabled?: boolean;\r\n  withoutTooltip?: boolean;\r\n}\r\n\r\nfunction MediaPlayer(props: MediaPlayerProps) {\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    controlsVisible: true,\r\n    dragging: false,\r\n    menuOpen: false,\r\n    volumeIndicatorVisible: false,\r\n  }));\r\n\r\n  const store: Store = React.useMemo(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n        stateRef.current[key] = value;\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef]);\r\n\r\n  return (\r\n    <MediaProvider>\r\n      <StoreContext.Provider value={store}>\r\n        <MediaPlayerImpl {...props} />\r\n      </StoreContext.Provider>\r\n    </MediaProvider>\r\n  );\r\n}\r\n\r\nfunction MediaPlayerImpl(props: MediaPlayerProps) {\r\n  const {\r\n    onPlay,\r\n    onPause,\r\n    onEnded,\r\n    onTimeUpdate,\r\n    onFullscreenChange,\r\n    onVolumeChange,\r\n    onMuted,\r\n    onMediaError,\r\n    onPipError,\r\n    dir: dirProp,\r\n    label,\r\n    tooltipDelayDuration = 600,\r\n    tooltipSideOffset = FLOATING_MENU_SIDE_OFFSET,\r\n    asChild,\r\n    autoHide = false,\r\n    disabled = false,\r\n    withoutTooltip = false,\r\n    children,\r\n    className,\r\n    ref,\r\n    ...rootImplProps\r\n  } = props;\r\n\r\n  const mediaId = React.useId();\r\n  const labelId = React.useId();\r\n  const descriptionId = React.useId();\r\n\r\n  const rootRef = React.useRef<RootElement | null>(null);\r\n  const fullscreenRef = useMediaFullscreenRef();\r\n  const composedRef = useComposedRefs(ref, rootRef, fullscreenRef);\r\n\r\n  const dir = DirectionPrimitive.useDirection(dirProp);\r\n  const dispatch = useMediaDispatch();\r\n  const mediaRef = React.useRef<HTMLVideoElement | HTMLAudioElement | null>(\r\n    null,\r\n  );\r\n\r\n  const store = useStoreContext(ROOT_NAME);\r\n\r\n  const controlsVisible = useStore((state) => state.controlsVisible);\r\n  const dragging = useStore((state) => state.dragging);\r\n  const menuOpen = useStore((state) => state.menuOpen);\r\n\r\n  const hideControlsTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);\r\n  const lastMouseMoveRef = React.useRef<number>(Date.now());\r\n  const volumeIndicatorTimeoutRef = React.useRef<NodeJS.Timeout | null>(null);\r\n\r\n  const mediaPaused = useMediaSelector((state) => state.mediaPaused ?? true);\r\n  const isFullscreen = useMediaSelector(\r\n    (state) => state.mediaIsFullscreen ?? false,\r\n  );\r\n\r\n  const [mounted, setMounted] = React.useState(false);\r\n  React.useLayoutEffect(() => {\r\n    setMounted(true);\r\n  }, []);\r\n\r\n  const portalContainer = mounted\r\n    ? isFullscreen\r\n      ? rootRef.current\r\n      : globalThis.document.body\r\n    : null;\r\n\r\n  const isVideo =\r\n    (typeof HTMLVideoElement !== \"undefined\" &&\r\n      mediaRef.current instanceof HTMLVideoElement) ||\r\n    mediaRef.current?.tagName?.toLowerCase() === \"mux-player\";\r\n\r\n  const onControlsShow = React.useCallback(() => {\r\n    store.setState(\"controlsVisible\", true);\r\n    lastMouseMoveRef.current = Date.now();\r\n\r\n    if (hideControlsTimeoutRef.current) {\r\n      clearTimeout(hideControlsTimeoutRef.current);\r\n    }\r\n\r\n    if (autoHide && !mediaPaused && !menuOpen && !dragging) {\r\n      hideControlsTimeoutRef.current = setTimeout(() => {\r\n        store.setState(\"controlsVisible\", false);\r\n      }, 3000);\r\n    }\r\n  }, [store.setState, autoHide, mediaPaused, menuOpen, dragging]);\r\n\r\n  const onVolumeIndicatorTrigger = React.useCallback(() => {\r\n    if (menuOpen) return;\r\n\r\n    store.setState(\"volumeIndicatorVisible\", true);\r\n\r\n    if (volumeIndicatorTimeoutRef.current) {\r\n      clearTimeout(volumeIndicatorTimeoutRef.current);\r\n    }\r\n\r\n    volumeIndicatorTimeoutRef.current = setTimeout(() => {\r\n      store.setState(\"volumeIndicatorVisible\", false);\r\n    }, 2000);\r\n\r\n    if (autoHide) {\r\n      onControlsShow();\r\n    }\r\n  }, [store.setState, menuOpen, autoHide, onControlsShow]);\r\n\r\n  const onMouseLeave = React.useCallback(\r\n    (event: React.MouseEvent<RootElement>) => {\r\n      rootImplProps.onMouseLeave?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (autoHide && !mediaPaused && !menuOpen && !dragging) {\r\n        store.setState(\"controlsVisible\", false);\r\n      }\r\n    },\r\n    [\r\n      store.setState,\r\n      rootImplProps.onMouseLeave,\r\n      autoHide,\r\n      mediaPaused,\r\n      menuOpen,\r\n      dragging,\r\n    ],\r\n  );\r\n\r\n  const onMouseMove = React.useCallback(\r\n    (event: React.MouseEvent<RootElement>) => {\r\n      rootImplProps.onMouseMove?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (autoHide) {\r\n        onControlsShow();\r\n      }\r\n    },\r\n    [autoHide, rootImplProps.onMouseMove, onControlsShow],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (mediaPaused || menuOpen || dragging) {\r\n      store.setState(\"controlsVisible\", true);\r\n      if (hideControlsTimeoutRef.current) {\r\n        clearTimeout(hideControlsTimeoutRef.current);\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (autoHide) {\r\n      onControlsShow();\r\n    }\r\n  }, [\r\n    store.setState,\r\n    onControlsShow,\r\n    autoHide,\r\n    menuOpen,\r\n    mediaPaused,\r\n    dragging,\r\n  ]);\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<RootElement>) => {\r\n      if (disabled) return;\r\n\r\n      rootImplProps.onKeyDown?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      const mediaElement = mediaRef.current;\r\n      if (!mediaElement) return;\r\n\r\n      const isMediaFocused = document.activeElement === mediaElement;\r\n      const isPlayerFocused =\r\n        document.activeElement?.closest('[data-slot=\"media-player\"]') !== null;\r\n\r\n      if (!isMediaFocused && !isPlayerFocused) return;\r\n\r\n      if (autoHide) onControlsShow();\r\n\r\n      switch (event.key.toLowerCase()) {\r\n        case \" \":\r\n        case \"k\":\r\n          event.preventDefault();\r\n          dispatch({\r\n            type: mediaElement.paused\r\n              ? MediaActionTypes.MEDIA_PLAY_REQUEST\r\n              : MediaActionTypes.MEDIA_PAUSE_REQUEST,\r\n          });\r\n          break;\r\n\r\n        case \"f\":\r\n          event.preventDefault();\r\n          dispatch({\r\n            type: document.fullscreenElement\r\n              ? MediaActionTypes.MEDIA_EXIT_FULLSCREEN_REQUEST\r\n              : MediaActionTypes.MEDIA_ENTER_FULLSCREEN_REQUEST,\r\n          });\r\n          break;\r\n\r\n        case \"m\": {\r\n          event.preventDefault();\r\n          if (isVideo) {\r\n            onVolumeIndicatorTrigger();\r\n          }\r\n          dispatch({\r\n            type: mediaElement.muted\r\n              ? MediaActionTypes.MEDIA_UNMUTE_REQUEST\r\n              : MediaActionTypes.MEDIA_MUTE_REQUEST,\r\n          });\r\n          break;\r\n        }\r\n\r\n        case \"arrowright\":\r\n          event.preventDefault();\r\n          if (\r\n            isVideo ||\r\n            (mediaElement instanceof HTMLAudioElement && event.shiftKey)\r\n          ) {\r\n            dispatch({\r\n              type: MediaActionTypes.MEDIA_SEEK_REQUEST,\r\n              detail: Math.min(\r\n                mediaElement.duration,\r\n                mediaElement.currentTime + SEEK_STEP_SHORT,\r\n              ),\r\n            });\r\n          }\r\n          break;\r\n\r\n        case \"arrowleft\":\r\n          event.preventDefault();\r\n          if (\r\n            isVideo ||\r\n            (mediaElement instanceof HTMLAudioElement && event.shiftKey)\r\n          ) {\r\n            dispatch({\r\n              type: MediaActionTypes.MEDIA_SEEK_REQUEST,\r\n              detail: Math.max(0, mediaElement.currentTime - SEEK_STEP_SHORT),\r\n            });\r\n          }\r\n          break;\r\n\r\n        case \"arrowup\":\r\n          event.preventDefault();\r\n          if (isVideo) {\r\n            onVolumeIndicatorTrigger();\r\n            dispatch({\r\n              type: MediaActionTypes.MEDIA_VOLUME_REQUEST,\r\n              detail: Math.min(1, mediaElement.volume + 0.1),\r\n            });\r\n          }\r\n          break;\r\n\r\n        case \"arrowdown\":\r\n          event.preventDefault();\r\n          if (isVideo) {\r\n            onVolumeIndicatorTrigger();\r\n            dispatch({\r\n              type: MediaActionTypes.MEDIA_VOLUME_REQUEST,\r\n              detail: Math.max(0, mediaElement.volume - 0.1),\r\n            });\r\n          }\r\n          break;\r\n\r\n        case \"<\": {\r\n          event.preventDefault();\r\n          const currentRate = mediaElement.playbackRate;\r\n          const currentIndex = SPEEDS.indexOf(currentRate);\r\n          const newIndex = Math.max(0, currentIndex - 1);\r\n          const newRate = SPEEDS[newIndex] ?? 1;\r\n          dispatch({\r\n            type: MediaActionTypes.MEDIA_PLAYBACK_RATE_REQUEST,\r\n            detail: newRate,\r\n          });\r\n          break;\r\n        }\r\n\r\n        case \">\": {\r\n          event.preventDefault();\r\n          const currentRate = mediaElement.playbackRate;\r\n          const currentIndex = SPEEDS.indexOf(currentRate);\r\n          const newIndex = Math.min(SPEEDS.length - 1, currentIndex + 1);\r\n          const newRate = SPEEDS[newIndex] ?? 1;\r\n          dispatch({\r\n            type: MediaActionTypes.MEDIA_PLAYBACK_RATE_REQUEST,\r\n            detail: newRate,\r\n          });\r\n          break;\r\n        }\r\n\r\n        case \"c\":\r\n          event.preventDefault();\r\n          if (isVideo && mediaElement.textTracks.length > 0) {\r\n            dispatch({\r\n              type: MediaActionTypes.MEDIA_TOGGLE_SUBTITLES_REQUEST,\r\n            });\r\n          }\r\n          break;\r\n\r\n        case \"d\": {\r\n          const hasDownload = mediaElement.querySelector(\r\n            '[data-slot=\"media-player-download\"]',\r\n          );\r\n\r\n          if (!hasDownload) break;\r\n\r\n          event.preventDefault();\r\n          if (mediaElement.currentSrc) {\r\n            const link = document.createElement(\"a\");\r\n            link.href = mediaElement.currentSrc;\r\n            link.download = \"\";\r\n            document.body.appendChild(link);\r\n            link.click();\r\n            document.body.removeChild(link);\r\n          }\r\n          break;\r\n        }\r\n\r\n        case \"p\": {\r\n          event.preventDefault();\r\n          if (isVideo && \"requestPictureInPicture\" in mediaElement) {\r\n            const isPip = document.pictureInPictureElement === mediaElement;\r\n            dispatch({\r\n              type: isPip\r\n                ? MediaActionTypes.MEDIA_EXIT_PIP_REQUEST\r\n                : MediaActionTypes.MEDIA_ENTER_PIP_REQUEST,\r\n            });\r\n            if (isPip) {\r\n              document.exitPictureInPicture().catch((error) => {\r\n                onPipError?.(error, \"exit\");\r\n              });\r\n            } else {\r\n              mediaElement.requestPictureInPicture().catch((error) => {\r\n                onPipError?.(error, \"enter\");\r\n              });\r\n            }\r\n          }\r\n          break;\r\n        }\r\n\r\n        case \"r\": {\r\n          event.preventDefault();\r\n          mediaElement.loop = !mediaElement.loop;\r\n          break;\r\n        }\r\n\r\n        case \"j\": {\r\n          event.preventDefault();\r\n          dispatch({\r\n            type: MediaActionTypes.MEDIA_SEEK_REQUEST,\r\n            detail: Math.max(0, mediaElement.currentTime - SEEK_STEP_LONG),\r\n          });\r\n          break;\r\n        }\r\n\r\n        case \"l\": {\r\n          event.preventDefault();\r\n          dispatch({\r\n            type: MediaActionTypes.MEDIA_SEEK_REQUEST,\r\n            detail: Math.min(\r\n              mediaElement.duration,\r\n              mediaElement.currentTime + SEEK_STEP_LONG,\r\n            ),\r\n          });\r\n          break;\r\n        }\r\n\r\n        case \"0\":\r\n        case \"1\":\r\n        case \"2\":\r\n        case \"3\":\r\n        case \"4\":\r\n        case \"5\":\r\n        case \"6\":\r\n        case \"7\":\r\n        case \"8\":\r\n        case \"9\": {\r\n          event.preventDefault();\r\n          const percent = Number.parseInt(event.key, 10) / 10;\r\n          const seekTime = mediaElement.duration * percent;\r\n          dispatch({\r\n            type: MediaActionTypes.MEDIA_SEEK_REQUEST,\r\n            detail: seekTime,\r\n          });\r\n          break;\r\n        }\r\n\r\n        case \"home\": {\r\n          event.preventDefault();\r\n          dispatch({\r\n            type: MediaActionTypes.MEDIA_SEEK_REQUEST,\r\n            detail: 0,\r\n          });\r\n          break;\r\n        }\r\n\r\n        case \"end\": {\r\n          event.preventDefault();\r\n          dispatch({\r\n            type: MediaActionTypes.MEDIA_SEEK_REQUEST,\r\n            detail: mediaElement.duration,\r\n          });\r\n          break;\r\n        }\r\n      }\r\n    },\r\n    [\r\n      dispatch,\r\n      rootImplProps.onKeyDown,\r\n      onVolumeIndicatorTrigger,\r\n      onPipError,\r\n      disabled,\r\n      isVideo,\r\n      onControlsShow,\r\n      autoHide,\r\n    ],\r\n  );\r\n\r\n  const onKeyUp = React.useCallback(\r\n    (event: React.KeyboardEvent<RootElement>) => {\r\n      rootImplProps.onKeyUp?.(event);\r\n\r\n      const key = event.key.toLowerCase();\r\n      if (key === \"arrowup\" || key === \"arrowdown\" || key === \"m\") {\r\n        onVolumeIndicatorTrigger();\r\n      }\r\n    },\r\n    [rootImplProps.onKeyUp, onVolumeIndicatorTrigger],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    const mediaElement = mediaRef.current;\r\n    if (!mediaElement) return;\r\n\r\n    if (onPlay) mediaElement.addEventListener(\"play\", onPlay);\r\n    if (onPause) mediaElement.addEventListener(\"pause\", onPause);\r\n    if (onEnded) mediaElement.addEventListener(\"ended\", onEnded);\r\n    if (onTimeUpdate)\r\n      mediaElement.addEventListener(\"timeupdate\", () =>\r\n        onTimeUpdate?.(mediaElement.currentTime),\r\n      );\r\n    if (onVolumeChange)\r\n      mediaElement.addEventListener(\"volumechange\", () => {\r\n        onVolumeChange?.(mediaElement.volume);\r\n        onMuted?.(mediaElement.muted);\r\n      });\r\n    if (onMediaError)\r\n      mediaElement.addEventListener(\"error\", () =>\r\n        onMediaError?.(mediaElement.error),\r\n      );\r\n    if (onFullscreenChange) {\r\n      document.addEventListener(\"fullscreenchange\", () =>\r\n        onFullscreenChange?.(!!document.fullscreenElement),\r\n      );\r\n    }\r\n\r\n    return () => {\r\n      if (onPlay) mediaElement.removeEventListener(\"play\", onPlay);\r\n      if (onPause) mediaElement.removeEventListener(\"pause\", onPause);\r\n      if (onEnded) mediaElement.removeEventListener(\"ended\", onEnded);\r\n      if (onTimeUpdate)\r\n        mediaElement.removeEventListener(\"timeupdate\", () =>\r\n          onTimeUpdate?.(mediaElement.currentTime),\r\n        );\r\n      if (onVolumeChange)\r\n        mediaElement.removeEventListener(\"volumechange\", () => {\r\n          onVolumeChange?.(mediaElement.volume);\r\n          onMuted?.(mediaElement.muted);\r\n        });\r\n      if (onMediaError)\r\n        mediaElement.removeEventListener(\"error\", () =>\r\n          onMediaError?.(mediaElement.error),\r\n        );\r\n      if (onFullscreenChange) {\r\n        document.removeEventListener(\"fullscreenchange\", () =>\r\n          onFullscreenChange?.(!!document.fullscreenElement),\r\n        );\r\n      }\r\n      if (volumeIndicatorTimeoutRef.current) {\r\n        clearTimeout(volumeIndicatorTimeoutRef.current);\r\n      }\r\n      if (hideControlsTimeoutRef.current) {\r\n        clearTimeout(hideControlsTimeoutRef.current);\r\n      }\r\n    };\r\n  }, [\r\n    onPlay,\r\n    onPause,\r\n    onEnded,\r\n    onTimeUpdate,\r\n    onVolumeChange,\r\n    onMuted,\r\n    onMediaError,\r\n    onFullscreenChange,\r\n  ]);\r\n\r\n  const contextValue = React.useMemo<MediaPlayerContextValue>(\r\n    () => ({\r\n      mediaId,\r\n      labelId,\r\n      descriptionId,\r\n      dir,\r\n      rootRef,\r\n      mediaRef,\r\n      portalContainer,\r\n      tooltipDelayDuration,\r\n      tooltipSideOffset,\r\n      disabled,\r\n      isVideo,\r\n      withoutTooltip,\r\n    }),\r\n    [\r\n      mediaId,\r\n      labelId,\r\n      descriptionId,\r\n      dir,\r\n      portalContainer,\r\n      tooltipDelayDuration,\r\n      tooltipSideOffset,\r\n      disabled,\r\n      isVideo,\r\n      withoutTooltip,\r\n    ],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <MediaPlayerContext.Provider value={contextValue}>\r\n      <RootPrimitive\r\n        aria-labelledby={labelId}\r\n        aria-describedby={descriptionId}\r\n        aria-disabled={disabled}\r\n        data-disabled={disabled ? \"\" : undefined}\r\n        data-controls-visible={controlsVisible ? \"\" : undefined}\r\n        data-slot=\"media-player\"\r\n        data-state={isFullscreen ? \"fullscreen\" : \"windowed\"}\r\n        dir={dir}\r\n        tabIndex={disabled ? undefined : 0}\r\n        {...rootImplProps}\r\n        ref={composedRef}\r\n        onMouseLeave={onMouseLeave}\r\n        onMouseMove={onMouseMove}\r\n        onKeyDown={onKeyDown}\r\n        onKeyUp={onKeyUp}\r\n        className={cn(\r\n          \"dark relative isolate flex flex-col overflow-hidden rounded-lg bg-background outline-none focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 data-disabled:pointer-events-none data-disabled:opacity-50 [&_video]:relative [&_video]:object-contain\",\r\n          \"in-[:fullscreen]:flex in-[:fullscreen]:h-full in-[:fullscreen]:max-h-screen in-[:fullscreen]:flex-col in-[:fullscreen]:justify-between data-[state=fullscreen]:[&_video]:size-full\",\r\n          \"**:data-slider:relative [&_[data-slider]::before]:absolute [&_[data-slider]::before]:inset-x-0 [&_[data-slider]::before]:-top-4 [&_[data-slider]::before]:-bottom-2 [&_[data-slider]::before]:z-10 [&_[data-slider]::before]:h-8 [&_[data-slider]::before]:cursor-pointer [&_[data-slider]::before]:content-[''] [&_[data-slot='media-player-seek']:not([data-hovering])::before]:cursor-default\",\r\n          \"[&_video::-webkit-media-text-track-display]:top-auto! [&_video::-webkit-media-text-track-display]:bottom-[4%]! [&_video::-webkit-media-text-track-display]:mb-0! data-[state=fullscreen]:data-controls-visible:[&_video::-webkit-media-text-track-display]:bottom-[9%]! data-[state=fullscreen]:[&_video::-webkit-media-text-track-display]:bottom-[7%]! data-controls-visible:[&_video::-webkit-media-text-track-display]:bottom-[13%]!\",\r\n          className,\r\n        )}\r\n      >\r\n        <span id={labelId} className=\"sr-only\">\r\n          {label ?? \"Media player\"}\r\n        </span>\r\n        <span id={descriptionId} className=\"sr-only\">\r\n          {isVideo\r\n            ? \"Video player with custom controls for playback, volume, seeking, and more. Use space bar to play/pause, arrow keys (←/→) to seek, and arrow keys (↑/↓) to adjust volume.\"\r\n            : \"Audio player with custom controls for playback, volume, seeking, and more. Use space bar to play/pause, Shift + arrow keys (←/→) to seek, and arrow keys (↑/↓) to adjust volume.\"}\r\n        </span>\r\n        {children}\r\n        <MediaPlayerVolumeIndicator />\r\n      </RootPrimitive>\r\n    </MediaPlayerContext.Provider>\r\n  );\r\n}\r\n\r\ninterface MediaPlayerVideoProps extends React.ComponentProps<\"video\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction MediaPlayerVideo(props: MediaPlayerVideoProps) {\r\n  const { asChild, ref, ...videoProps } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerVideo\");\r\n  const dispatch = useMediaDispatch();\r\n  const mediaRefCallback = useMediaRef();\r\n  const composedRef = useComposedRefs(ref, context.mediaRef, mediaRefCallback);\r\n\r\n  const onPlayToggle = React.useCallback(\r\n    (event: React.MouseEvent<HTMLVideoElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      const mediaElement = event.currentTarget;\r\n      if (!mediaElement) return;\r\n\r\n      dispatch({\r\n        type: mediaElement.paused\r\n          ? MediaActionTypes.MEDIA_PLAY_REQUEST\r\n          : MediaActionTypes.MEDIA_PAUSE_REQUEST,\r\n      });\r\n    },\r\n    [dispatch, props.onClick],\r\n  );\r\n\r\n  const VideoPrimitive = asChild ? SlotPrimitive.Slot : \"video\";\r\n\r\n  return (\r\n    <VideoPrimitive\r\n      aria-describedby={context.descriptionId}\r\n      aria-labelledby={context.labelId}\r\n      data-slot=\"media-player-video\"\r\n      {...videoProps}\r\n      id={context.mediaId}\r\n      ref={composedRef}\r\n      onClick={onPlayToggle}\r\n    />\r\n  );\r\n}\r\n\r\ninterface MediaPlayerAudioProps extends React.ComponentProps<\"audio\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction MediaPlayerAudio(props: MediaPlayerAudioProps) {\r\n  const { asChild, ref, ...audioProps } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerAudio\");\r\n  const mediaRefCallback = useMediaRef();\r\n  const composedRef = useComposedRefs(ref, context.mediaRef, mediaRefCallback);\r\n\r\n  const AudioPrimitive = asChild ? SlotPrimitive.Slot : \"audio\";\r\n\r\n  return (\r\n    <AudioPrimitive\r\n      aria-describedby={context.descriptionId}\r\n      aria-labelledby={context.labelId}\r\n      data-slot=\"media-player-audio\"\r\n      {...audioProps}\r\n      id={context.mediaId}\r\n      ref={composedRef}\r\n    />\r\n  );\r\n}\r\n\r\nfunction MediaPlayerControls(props: DivProps) {\r\n  const { asChild, className, ...controlsProps } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerControls\");\r\n  const isFullscreen = useMediaSelector(\r\n    (state) => state.mediaIsFullscreen ?? false,\r\n  );\r\n  const controlsVisible = useStore((state) => state.controlsVisible);\r\n\r\n  const ControlsPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <ControlsPrimitive\r\n      data-disabled={context.disabled ? \"\" : undefined}\r\n      data-slot=\"media-player-controls\"\r\n      data-state={isFullscreen ? \"fullscreen\" : \"windowed\"}\r\n      data-visible={controlsVisible ? \"\" : undefined}\r\n      dir={context.dir}\r\n      className={cn(\r\n        \"dark pointer-events-none absolute right-0 bottom-0 left-0 z-50 flex items-center gap-2 in-[:fullscreen]:px-6 px-4 in-[:fullscreen]:py-4 py-3 opacity-0 transition-opacity duration-200 data-visible:pointer-events-auto data-visible:opacity-100\",\r\n        className,\r\n      )}\r\n      {...controlsProps}\r\n    />\r\n  );\r\n}\r\n\r\ninterface MediaPlayerLoadingProps extends DivProps {\r\n  delayMs?: number;\r\n}\r\n\r\nfunction MediaPlayerLoading(props: MediaPlayerLoadingProps) {\r\n  const {\r\n    delayMs = 500,\r\n    asChild,\r\n    className,\r\n    children,\r\n    ...loadingProps\r\n  } = props;\r\n\r\n  const isLoading = useMediaSelector((state) => state.mediaLoading ?? false);\r\n  const isPaused = useMediaSelector((state) => state.mediaPaused ?? true);\r\n  const hasPlayed = useMediaSelector((state) => state.mediaHasPlayed ?? false);\r\n\r\n  const shouldShowLoading = isLoading && !isPaused;\r\n  const shouldUseDelay = hasPlayed && shouldShowLoading;\r\n  const loadingDelayMs = shouldUseDelay ? delayMs : 0;\r\n\r\n  const [shouldRender, setShouldRender] = React.useState(false);\r\n  const timeoutRef = React.useRef<NodeJS.Timeout | null>(null);\r\n\r\n  React.useEffect(() => {\r\n    if (timeoutRef.current) {\r\n      clearTimeout(timeoutRef.current);\r\n      timeoutRef.current = null;\r\n    }\r\n\r\n    if (shouldShowLoading) {\r\n      if (loadingDelayMs > 0) {\r\n        timeoutRef.current = setTimeout(() => {\r\n          setShouldRender(true);\r\n          timeoutRef.current = null;\r\n        }, loadingDelayMs);\r\n      } else {\r\n        setShouldRender(true);\r\n      }\r\n    } else {\r\n      setShouldRender(false);\r\n    }\r\n\r\n    return () => {\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n        timeoutRef.current = null;\r\n      }\r\n    };\r\n  }, [shouldShowLoading, loadingDelayMs]);\r\n\r\n  if (!shouldRender) return null;\r\n\r\n  const LoadingPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <LoadingPrimitive\r\n      role=\"status\"\r\n      aria-live=\"polite\"\r\n      data-slot=\"media-player-loading\"\r\n      {...loadingProps}\r\n      className={cn(\r\n        \"fade-in-0 zoom-in-95 pointer-events-none absolute inset-0 z-50 flex animate-in items-center justify-center duration-200\",\r\n        className,\r\n      )}\r\n    >\r\n      {children ?? (\r\n        <Loader2Icon className=\"size-20 animate-spin stroke-[.0938rem] text-primary\" />\r\n      )}\r\n    </LoadingPrimitive>\r\n  );\r\n}\r\n\r\ninterface MediaPlayerErrorProps extends DivProps {\r\n  error?: MediaError | null;\r\n  label?: string;\r\n  description?: string;\r\n  onRetry?: () => void;\r\n  onReload?: () => void;\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction MediaPlayerError(props: MediaPlayerErrorProps) {\r\n  const {\r\n    error: errorProp,\r\n    label,\r\n    description,\r\n    onRetry: onRetryProp,\r\n    onReload: onReloadProp,\r\n    asChild,\r\n    className,\r\n    children,\r\n    ...errorProps\r\n  } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerError\");\r\n  const isFullscreen = useMediaSelector(\r\n    (state) => state.mediaIsFullscreen ?? false,\r\n  );\r\n  const mediaError = useMediaSelector((state) => state.mediaError);\r\n\r\n  const error = errorProp ?? mediaError;\r\n\r\n  const labelId = React.useId();\r\n  const descriptionId = React.useId();\r\n\r\n  const [actionState, setActionState] = React.useState<{\r\n    retryPending: boolean;\r\n    reloadPending: boolean;\r\n  }>({\r\n    retryPending: false,\r\n    reloadPending: false,\r\n  });\r\n\r\n  const onRetry = React.useCallback(() => {\r\n    setActionState((prev) => ({ ...prev, retryPending: true }));\r\n\r\n    requestAnimationFrame(() => {\r\n      const mediaElement = context.mediaRef.current;\r\n      if (!mediaElement) {\r\n        setActionState((prev) => ({ ...prev, retryPending: false }));\r\n        return;\r\n      }\r\n\r\n      if (onRetryProp) {\r\n        onRetryProp();\r\n      } else {\r\n        const currentSrc = mediaElement.currentSrc ?? mediaElement.src;\r\n        if (currentSrc) {\r\n          mediaElement.load();\r\n        }\r\n      }\r\n\r\n      setActionState((prev) => ({ ...prev, retryPending: false }));\r\n    });\r\n  }, [context.mediaRef, onRetryProp]);\r\n\r\n  const onReload = React.useCallback(() => {\r\n    setActionState((prev) => ({ ...prev, reloadPending: true }));\r\n\r\n    requestAnimationFrame(() => {\r\n      if (onReloadProp) {\r\n        onReloadProp();\r\n      } else {\r\n        window.location.reload();\r\n      }\r\n    });\r\n  }, [onReloadProp]);\r\n\r\n  const errorLabel = React.useMemo(() => {\r\n    if (label) return label;\r\n\r\n    if (!error) return \"Playback Error\";\r\n\r\n    const labelMap: Record<number, string> = {\r\n      [MediaError.MEDIA_ERR_ABORTED]: \"Playback Interrupted\",\r\n      [MediaError.MEDIA_ERR_NETWORK]: \"Connection Problem\",\r\n      [MediaError.MEDIA_ERR_DECODE]: \"Media Error\",\r\n      [MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED]: \"Unsupported Format\",\r\n    };\r\n\r\n    return labelMap[error.code] ?? \"Playback Error\";\r\n  }, [label, error]);\r\n\r\n  const errorDescription = React.useMemo(() => {\r\n    if (description) return description;\r\n\r\n    if (!error) return \"An unknown error occurred\";\r\n\r\n    const descriptionMap: Record<number, string> = {\r\n      [MediaError.MEDIA_ERR_ABORTED]: \"Media playback was aborted\",\r\n      [MediaError.MEDIA_ERR_NETWORK]:\r\n        \"A network error occurred while loading the media\",\r\n      [MediaError.MEDIA_ERR_DECODE]:\r\n        \"An error occurred while decoding the media\",\r\n      [MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED]:\r\n        \"The media format is not supported\",\r\n    };\r\n\r\n    return descriptionMap[error.code] ?? \"An unknown error occurred\";\r\n  }, [description, error]);\r\n\r\n  if (!error) return null;\r\n\r\n  const ErrorPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <ErrorPrimitive\r\n      role=\"alert\"\r\n      aria-describedby={descriptionId}\r\n      aria-labelledby={labelId}\r\n      aria-live=\"assertive\"\r\n      data-slot=\"media-player-error\"\r\n      data-state={isFullscreen ? \"fullscreen\" : \"windowed\"}\r\n      {...errorProps}\r\n      className={cn(\r\n        \"pointer-events-auto absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/80 text-white backdrop-blur-sm\",\r\n        className,\r\n      )}\r\n    >\r\n      {children ?? (\r\n        <div className=\"flex max-w-md flex-col items-center gap-4 px-6 py-8 text-center\">\r\n          <AlertTriangleIcon className=\"size-12 text-destructive\" />\r\n          <div className=\"flex flex-col gap-px text-center\">\r\n            <h3 className=\"font-semibold text-xl tracking-tight\">\r\n              {errorLabel}\r\n            </h3>\r\n            <p className=\"text-balance text-muted-foreground text-sm leading-relaxed\">\r\n              {errorDescription}\r\n            </p>\r\n          </div>\r\n          <div className=\"flex items-center gap-2\">\r\n            <Button\r\n              variant=\"secondary\"\r\n              size=\"sm\"\r\n              onClick={onRetry}\r\n              disabled={actionState.retryPending}\r\n            >\r\n              {actionState.retryPending ? (\r\n                <Loader2Icon className=\"animate-spin\" />\r\n              ) : (\r\n                <RefreshCcwIcon />\r\n              )}\r\n              Try again\r\n            </Button>\r\n            <Button\r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              onClick={onReload}\r\n              disabled={actionState.reloadPending}\r\n            >\r\n              {actionState.reloadPending ? (\r\n                <Loader2Icon className=\"animate-spin\" />\r\n              ) : (\r\n                <RotateCcwIcon />\r\n              )}\r\n              Reload page\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </ErrorPrimitive>\r\n  );\r\n}\r\n\r\nfunction MediaPlayerVolumeIndicator(props: DivProps) {\r\n  const { asChild, className, ...indicatorProps } = props;\r\n\r\n  const mediaVolume = useMediaSelector((state) => state.mediaVolume ?? 1);\r\n  const mediaMuted = useMediaSelector((state) => state.mediaMuted ?? false);\r\n  const mediaVolumeLevel = useMediaSelector(\r\n    (state) => state.mediaVolumeLevel ?? \"high\",\r\n  );\r\n  const volumeIndicatorVisible = useStore(\r\n    (state) => state.volumeIndicatorVisible,\r\n  );\r\n\r\n  if (!volumeIndicatorVisible) return null;\r\n\r\n  const effectiveVolume = mediaMuted ? 0 : mediaVolume;\r\n  const volumePercentage = Math.round(effectiveVolume * 100);\r\n  const barCount = 10;\r\n  const activeBarCount = Math.ceil(effectiveVolume * barCount);\r\n\r\n  const VolumeIndicatorPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <VolumeIndicatorPrimitive\r\n      role=\"status\"\r\n      aria-live=\"polite\"\r\n      aria-label={`Volume ${mediaMuted ? \"muted\" : `${volumePercentage}%`}`}\r\n      data-slot=\"media-player-volume-indicator\"\r\n      {...indicatorProps}\r\n      className={cn(\r\n        \"pointer-events-none absolute inset-0 z-50 flex items-center justify-center\",\r\n        className,\r\n      )}\r\n    >\r\n      <div className=\"fade-in-0 zoom-in-95 flex animate-in flex-col items-center gap-3 rounded-lg bg-black/30 px-6 py-4 text-white backdrop-blur-xs duration-200\">\r\n        <div className=\"flex items-center gap-2\">\r\n          {mediaVolumeLevel === \"off\" || mediaMuted ? (\r\n            <VolumeXIcon className=\"size-6\" />\r\n          ) : mediaVolumeLevel === \"high\" ? (\r\n            <Volume2Icon className=\"size-6\" />\r\n          ) : (\r\n            <Volume1Icon className=\"size-6\" />\r\n          )}\r\n          <span className=\"font-medium text-sm tabular-nums\">\r\n            {mediaMuted ? \"Muted\" : `${volumePercentage}%`}\r\n          </span>\r\n        </div>\r\n        <div className=\"flex items-center gap-1\">\r\n          {Array.from({ length: barCount }, (_, index) => (\r\n            <div\r\n              key={index}\r\n              className={cn(\r\n                \"w-1.5 rounded-full transition-all duration-150\",\r\n                index < activeBarCount && !mediaMuted\r\n                  ? \"scale-100 bg-white\"\r\n                  : \"scale-90 bg-white/30\",\r\n              )}\r\n              style={{\r\n                height: `${12 + index * 2}px`,\r\n                animationDelay: `${index * 50}ms`,\r\n              }}\r\n            />\r\n          ))}\r\n        </div>\r\n      </div>\r\n    </VolumeIndicatorPrimitive>\r\n  );\r\n}\r\n\r\nfunction MediaPlayerControlsOverlay(props: DivProps) {\r\n  const { asChild, className, ...overlayProps } = props;\r\n\r\n  const isFullscreen = useMediaSelector(\r\n    (state) => state.mediaIsFullscreen ?? false,\r\n  );\r\n  const controlsVisible = useStore((state) => state.controlsVisible);\r\n\r\n  const OverlayPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <OverlayPrimitive\r\n      data-slot=\"media-player-controls-overlay\"\r\n      data-state={isFullscreen ? \"fullscreen\" : \"windowed\"}\r\n      data-visible={controlsVisible ? \"\" : undefined}\r\n      {...overlayProps}\r\n      className={cn(\r\n        \"pointer-events-none absolute inset-0 -z-10 bg-linear-to-t from-black/80 to-transparent opacity-0 transition-opacity duration-200 data-visible:opacity-100\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nfunction MediaPlayerPlay(props: React.ComponentProps<typeof Button>) {\r\n  const { children, className, disabled, ...playButtonProps } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerPlay\");\r\n  const dispatch = useMediaDispatch();\r\n  const mediaPaused = useMediaSelector((state) => state.mediaPaused ?? true);\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onPlayToggle = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      dispatch({\r\n        type: mediaPaused\r\n          ? MediaActionTypes.MEDIA_PLAY_REQUEST\r\n          : MediaActionTypes.MEDIA_PAUSE_REQUEST,\r\n      });\r\n    },\r\n    [dispatch, props.onClick, mediaPaused],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip\r\n      tooltip={mediaPaused ? \"Play\" : \"Pause\"}\r\n      shortcut=\"Space\"\r\n    >\r\n      <Button\r\n        type=\"button\"\r\n        aria-controls={context.mediaId}\r\n        aria-label={mediaPaused ? \"Play\" : \"Pause\"}\r\n        aria-pressed={!mediaPaused}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-play-button\"\r\n        data-state={mediaPaused ? \"off\" : \"on\"}\r\n        disabled={isDisabled}\r\n        {...playButtonProps}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\r\n          \"size-8 [&_svg:not([class*='fill-'])]:fill-current\",\r\n          className,\r\n        )}\r\n        onClick={onPlayToggle}\r\n      >\r\n        {children ?? (mediaPaused ? <PlayIcon /> : <PauseIcon />)}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n}\r\n\r\ninterface MediaPlayerSeekBackwardProps\r\n  extends React.ComponentProps<typeof Button> {\r\n  seconds?: number;\r\n}\r\n\r\nfunction MediaPlayerSeekBackward(props: MediaPlayerSeekBackwardProps) {\r\n  const {\r\n    seconds = SEEK_STEP_SHORT,\r\n    children,\r\n    className,\r\n    disabled,\r\n    ...seekBackwardProps\r\n  } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerSeekBackward\");\r\n  const dispatch = useMediaDispatch();\r\n  const mediaCurrentTime = useMediaSelector(\r\n    (state) => state.mediaCurrentTime ?? 0,\r\n  );\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onSeekBackward = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_SEEK_REQUEST,\r\n        detail: Math.max(0, mediaCurrentTime - seconds),\r\n      });\r\n    },\r\n    [dispatch, props.onClick, mediaCurrentTime, seconds],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip\r\n      tooltip={`Back ${seconds}s`}\r\n      shortcut={context.isVideo ? [\"←\"] : [\"Shift ←\"]}\r\n    >\r\n      <Button\r\n        type=\"button\"\r\n        aria-controls={context.mediaId}\r\n        aria-label={`Back ${seconds} seconds`}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-seek-backward\"\r\n        disabled={isDisabled}\r\n        {...seekBackwardProps}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onSeekBackward}\r\n      >\r\n        {children ?? <RewindIcon />}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n}\r\n\r\ninterface MediaPlayerSeekForwardProps\r\n  extends React.ComponentProps<typeof Button> {\r\n  seconds?: number;\r\n}\r\n\r\nfunction MediaPlayerSeekForward(props: MediaPlayerSeekForwardProps) {\r\n  const {\r\n    seconds = SEEK_STEP_LONG,\r\n    children,\r\n    className,\r\n    disabled,\r\n    ...seekForwardProps\r\n  } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerSeekForward\");\r\n  const dispatch = useMediaDispatch();\r\n  const mediaCurrentTime = useMediaSelector(\r\n    (state) => state.mediaCurrentTime ?? 0,\r\n  );\r\n  const [, seekableEnd] = useMediaSelector(\r\n    (state) => state.mediaSeekable ?? [0, 0],\r\n  );\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onSeekForward = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_SEEK_REQUEST,\r\n        detail: Math.min(\r\n          seekableEnd ?? Number.POSITIVE_INFINITY,\r\n          mediaCurrentTime + seconds,\r\n        ),\r\n      });\r\n    },\r\n    [dispatch, props.onClick, mediaCurrentTime, seekableEnd, seconds],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip\r\n      tooltip={`Forward ${seconds}s`}\r\n      shortcut={context.isVideo ? [\"→\"] : [\"Shift →\"]}\r\n    >\r\n      <Button\r\n        type=\"button\"\r\n        aria-controls={context.mediaId}\r\n        aria-label={`Forward ${seconds} seconds`}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-seek-forward\"\r\n        disabled={isDisabled}\r\n        {...seekForwardProps}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onSeekForward}\r\n      >\r\n        {children ?? <FastForwardIcon />}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n}\r\n\r\ninterface SeekState {\r\n  isHovering: boolean;\r\n  pendingSeekTime: number | null;\r\n  hasInitialPosition: boolean;\r\n}\r\n\r\ninterface MediaPlayerSeekProps\r\n  extends React.ComponentProps<typeof SliderPrimitive.Root> {\r\n  withTime?: boolean;\r\n  withoutChapter?: boolean;\r\n  withoutTooltip?: boolean;\r\n  tooltipThumbnailSrc?: string | ((time: number) => string);\r\n  tooltipTimeVariant?: \"current\" | \"progress\";\r\n  tooltipSideOffset?: number;\r\n  tooltipCollisionBoundary?: Element | Element[];\r\n  tooltipCollisionPadding?:\r\n    | number\r\n    | Partial<Record<\"top\" | \"right\" | \"bottom\" | \"left\", number>>;\r\n}\r\n\r\nfunction MediaPlayerSeek(props: MediaPlayerSeekProps) {\r\n  const {\r\n    withTime = false,\r\n    withoutChapter = false,\r\n    withoutTooltip = false,\r\n    tooltipTimeVariant = \"current\",\r\n    tooltipThumbnailSrc,\r\n    tooltipSideOffset,\r\n    tooltipCollisionPadding = SEEK_COLLISION_PADDING,\r\n    tooltipCollisionBoundary,\r\n    className,\r\n    disabled,\r\n    ...seekProps\r\n  } = props;\r\n\r\n  const context = useMediaPlayerContext(SEEK_NAME);\r\n  const store = useStoreContext(SEEK_NAME);\r\n  const dispatch = useMediaDispatch();\r\n  const mediaCurrentTime = useMediaSelector(\r\n    (state) => state.mediaCurrentTime ?? 0,\r\n  );\r\n  const [seekableStart = 0, seekableEnd = 0] = useMediaSelector(\r\n    (state) => state.mediaSeekable ?? [0, 0],\r\n  );\r\n  const mediaBuffered = useMediaSelector((state) => state.mediaBuffered ?? []);\r\n  const mediaEnded = useMediaSelector((state) => state.mediaEnded ?? false);\r\n\r\n  const chapterCues = useMediaSelector(\r\n    (state) => state.mediaChaptersCues ?? [],\r\n  );\r\n  const mediaPreviewTime = useMediaSelector((state) => state.mediaPreviewTime);\r\n  const mediaPreviewImage = useMediaSelector(\r\n    (state) => state.mediaPreviewImage,\r\n  );\r\n  const mediaPreviewCoords = useMediaSelector(\r\n    (state) => state.mediaPreviewCoords,\r\n  );\r\n\r\n  const seekRef = React.useRef<HTMLDivElement>(null);\r\n  const tooltipRef = React.useRef<HTMLDivElement>(null);\r\n  const justCommittedRef = React.useRef<boolean>(false);\r\n\r\n  const hoverTimeRef = React.useRef(0);\r\n  const tooltipXRef = React.useRef(0);\r\n  const tooltipYRef = React.useRef(0);\r\n  const seekRectRef = React.useRef<DOMRect | null>(null);\r\n  const collisionDataRef = React.useRef<{\r\n    padding: { top: number; right: number; bottom: number; left: number };\r\n    boundaries: Element[];\r\n  } | null>(null);\r\n\r\n  const [seekState, setSeekState] = React.useState<SeekState>({\r\n    isHovering: false,\r\n    pendingSeekTime: null,\r\n    hasInitialPosition: false,\r\n  });\r\n\r\n  const rafIdRef = React.useRef<number | null>(null);\r\n  const seekThrottleRef = React.useRef<number | null>(null);\r\n  const hoverTimeoutRef = React.useRef<number | null>(null);\r\n  const lastPointerXRef = React.useRef<number>(0);\r\n  const lastPointerYRef = React.useRef<number>(0);\r\n  const previewDebounceRef = React.useRef<number | null>(null);\r\n  const pointerEnterTimeRef = React.useRef<number>(0);\r\n  const horizontalMovementRef = React.useRef<number>(0);\r\n  const verticalMovementRef = React.useRef<number>(0);\r\n  const lastSeekCommitTimeRef = React.useRef<number>(0);\r\n\r\n  const timeCache = React.useRef<Map<number, string>>(new Map());\r\n\r\n  const displayValue = seekState.pendingSeekTime ?? mediaCurrentTime;\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n  const tooltipDisabled =\r\n    withoutTooltip || context.withoutTooltip || store.getState().menuOpen;\r\n\r\n  const currentTooltipSideOffset =\r\n    tooltipSideOffset ?? context.tooltipSideOffset;\r\n\r\n  const getCachedTime = React.useCallback((time: number, duration: number) => {\r\n    const roundedTime = Math.floor(time);\r\n    const key = roundedTime + duration * 10000;\r\n\r\n    if (timeCache.current.has(key)) {\r\n      return timeCache.current.get(key) as string;\r\n    }\r\n\r\n    const formatted = timeUtils.formatTime(time, duration);\r\n    timeCache.current.set(key, formatted);\r\n\r\n    if (timeCache.current.size > 100) {\r\n      timeCache.current.clear();\r\n    }\r\n\r\n    return formatted;\r\n  }, []);\r\n\r\n  const currentTime = getCachedTime(displayValue, seekableEnd);\r\n  const duration = getCachedTime(seekableEnd, seekableEnd);\r\n  const remainingTime = getCachedTime(seekableEnd - displayValue, seekableEnd);\r\n\r\n  const onCollisionDataUpdate = React.useCallback(() => {\r\n    if (collisionDataRef.current) return collisionDataRef.current;\r\n\r\n    const padding =\r\n      typeof tooltipCollisionPadding === \"number\"\r\n        ? {\r\n            top: tooltipCollisionPadding,\r\n            right: tooltipCollisionPadding,\r\n            bottom: tooltipCollisionPadding,\r\n            left: tooltipCollisionPadding,\r\n          }\r\n        : { top: 0, right: 0, bottom: 0, left: 0, ...tooltipCollisionPadding };\r\n\r\n    const boundaries = tooltipCollisionBoundary\r\n      ? Array.isArray(tooltipCollisionBoundary)\r\n        ? tooltipCollisionBoundary\r\n        : [tooltipCollisionBoundary]\r\n      : ([context.rootRef.current].filter(Boolean) as Element[]);\r\n\r\n    collisionDataRef.current = { padding, boundaries };\r\n    return collisionDataRef.current;\r\n  }, [tooltipCollisionPadding, tooltipCollisionBoundary, context.rootRef]);\r\n\r\n  const getCurrentChapterCue = React.useCallback(\r\n    (time: number) => {\r\n      if (withoutChapter || chapterCues.length === 0) return null;\r\n      return chapterCues.find((c) => time >= c.startTime && time < c.endTime);\r\n    },\r\n    [chapterCues, withoutChapter],\r\n  );\r\n\r\n  const getThumbnail = React.useCallback(\r\n    (time: number) => {\r\n      if (tooltipDisabled) return null;\r\n\r\n      if (tooltipThumbnailSrc) {\r\n        const src =\r\n          typeof tooltipThumbnailSrc === \"function\"\r\n            ? tooltipThumbnailSrc(time)\r\n            : tooltipThumbnailSrc;\r\n        return { src, coords: null };\r\n      }\r\n\r\n      if (\r\n        mediaPreviewTime !== undefined &&\r\n        Math.abs(time - mediaPreviewTime) < 0.1 &&\r\n        mediaPreviewImage\r\n      ) {\r\n        return {\r\n          src: mediaPreviewImage,\r\n          coords: mediaPreviewCoords ?? null,\r\n        };\r\n      }\r\n\r\n      return null;\r\n    },\r\n    [\r\n      tooltipThumbnailSrc,\r\n      mediaPreviewTime,\r\n      mediaPreviewImage,\r\n      mediaPreviewCoords,\r\n      tooltipDisabled,\r\n    ],\r\n  );\r\n\r\n  const onPreviewUpdate = React.useCallback(\r\n    (time: number) => {\r\n      if (tooltipDisabled) return;\r\n\r\n      if (previewDebounceRef.current) {\r\n        cancelAnimationFrame(previewDebounceRef.current);\r\n      }\r\n\r\n      previewDebounceRef.current = requestAnimationFrame(() => {\r\n        dispatch({\r\n          type: MediaActionTypes.MEDIA_PREVIEW_REQUEST,\r\n          detail: time,\r\n        });\r\n        previewDebounceRef.current = null;\r\n      });\r\n    },\r\n    [dispatch, tooltipDisabled],\r\n  );\r\n\r\n  const onTooltipPositionUpdate = React.useCallback(\r\n    (clientX: number) => {\r\n      if (!seekRef.current) return;\r\n\r\n      const tooltipWidth =\r\n        tooltipRef.current?.offsetWidth ?? SEEK_TOOLTIP_WIDTH_FALLBACK;\r\n\r\n      let x = clientX;\r\n      const y = seekRectRef.current?.top ?? 0;\r\n\r\n      const collisionData = onCollisionDataUpdate();\r\n      const halfTooltipWidth = tooltipWidth / 2;\r\n\r\n      let minLeft = 0;\r\n      let maxRight = window.innerWidth;\r\n\r\n      for (const boundary of collisionData.boundaries) {\r\n        const boundaryRect = boundary.getBoundingClientRect();\r\n        minLeft = Math.max(\r\n          minLeft,\r\n          boundaryRect.left + collisionData.padding.left,\r\n        );\r\n        maxRight = Math.min(\r\n          maxRight,\r\n          boundaryRect.right - collisionData.padding.right,\r\n        );\r\n      }\r\n\r\n      if (x - halfTooltipWidth < minLeft) {\r\n        x = minLeft + halfTooltipWidth;\r\n      } else if (x + halfTooltipWidth > maxRight) {\r\n        x = maxRight - halfTooltipWidth;\r\n      }\r\n\r\n      const viewportPadding = SEEK_COLLISION_PADDING;\r\n      if (x - halfTooltipWidth < viewportPadding) {\r\n        x = viewportPadding + halfTooltipWidth;\r\n      } else if (x + halfTooltipWidth > window.innerWidth - viewportPadding) {\r\n        x = window.innerWidth - viewportPadding - halfTooltipWidth;\r\n      }\r\n\r\n      tooltipXRef.current = x;\r\n      tooltipYRef.current = y;\r\n\r\n      if (tooltipRef.current) {\r\n        tooltipRef.current.style.setProperty(SEEK_TOOLTIP_X, `${x}px`);\r\n        tooltipRef.current.style.setProperty(SEEK_TOOLTIP_Y, `${y}px`);\r\n      }\r\n\r\n      if (!seekState.hasInitialPosition) {\r\n        setSeekState((prev) => ({ ...prev, hasInitialPosition: true }));\r\n      }\r\n    },\r\n    [onCollisionDataUpdate, seekState.hasInitialPosition],\r\n  );\r\n\r\n  const onHoverProgressUpdate = React.useCallback(() => {\r\n    if (!seekRef.current || seekableEnd <= 0) return;\r\n\r\n    const hoverPercent = Math.min(\r\n      100,\r\n      (hoverTimeRef.current / seekableEnd) * 100,\r\n    );\r\n    seekRef.current.style.setProperty(\r\n      SEEK_HOVER_PERCENT,\r\n      `${hoverPercent.toFixed(4)}%`,\r\n    );\r\n  }, [seekableEnd]);\r\n\r\n  React.useEffect(() => {\r\n    if (seekState.pendingSeekTime !== null) {\r\n      const diff = Math.abs(mediaCurrentTime - seekState.pendingSeekTime);\r\n      if (diff < 0.5) {\r\n        setSeekState((prev) => ({ ...prev, pendingSeekTime: null }));\r\n      }\r\n    }\r\n  }, [mediaCurrentTime, seekState.pendingSeekTime]);\r\n\r\n  React.useEffect(() => {\r\n    if (!seekState.isHovering || tooltipDisabled) return;\r\n\r\n    function onScroll() {\r\n      setSeekState((prev) => ({\r\n        ...prev,\r\n        isHovering: false,\r\n        hasInitialPosition: false,\r\n      }));\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_PREVIEW_REQUEST,\r\n        detail: undefined,\r\n      });\r\n    }\r\n\r\n    document.addEventListener(\"scroll\", onScroll, { passive: true });\r\n    return () => {\r\n      document.removeEventListener(\"scroll\", onScroll);\r\n    };\r\n  }, [dispatch, seekState.isHovering, tooltipDisabled]);\r\n\r\n  const bufferedProgress = React.useMemo(() => {\r\n    if (mediaBuffered.length === 0 || seekableEnd <= 0) return 0;\r\n\r\n    if (mediaEnded) return 1;\r\n\r\n    const containingRange = mediaBuffered.find(\r\n      ([start, end]) => start <= mediaCurrentTime && mediaCurrentTime <= end,\r\n    );\r\n\r\n    if (containingRange) {\r\n      return Math.min(1, containingRange[1] / seekableEnd);\r\n    }\r\n\r\n    return Math.min(1, seekableStart / seekableEnd);\r\n  }, [mediaBuffered, mediaCurrentTime, seekableEnd, mediaEnded, seekableStart]);\r\n\r\n  const onPointerEnter = React.useCallback(() => {\r\n    if (seekRef.current) {\r\n      seekRectRef.current = seekRef.current.getBoundingClientRect();\r\n    }\r\n\r\n    collisionDataRef.current = null;\r\n    pointerEnterTimeRef.current = Date.now();\r\n    horizontalMovementRef.current = 0;\r\n    verticalMovementRef.current = 0;\r\n\r\n    if (seekableEnd > 0) {\r\n      if (hoverTimeoutRef.current) {\r\n        clearTimeout(hoverTimeoutRef.current);\r\n      }\r\n\r\n      if (!tooltipDisabled) {\r\n        if (lastPointerXRef.current && seekRectRef.current) {\r\n          const clientX = Math.max(\r\n            seekRectRef.current.left,\r\n            Math.min(lastPointerXRef.current, seekRectRef.current.right),\r\n          );\r\n          onTooltipPositionUpdate(clientX);\r\n        }\r\n      }\r\n    }\r\n  }, [seekableEnd, onTooltipPositionUpdate, tooltipDisabled]);\r\n\r\n  const onPointerLeave = React.useCallback(() => {\r\n    if (hoverTimeoutRef.current) {\r\n      clearTimeout(hoverTimeoutRef.current);\r\n      hoverTimeoutRef.current = null;\r\n    }\r\n    if (rafIdRef.current) {\r\n      cancelAnimationFrame(rafIdRef.current);\r\n      rafIdRef.current = null;\r\n    }\r\n    if (previewDebounceRef.current) {\r\n      cancelAnimationFrame(previewDebounceRef.current);\r\n      previewDebounceRef.current = null;\r\n    }\r\n\r\n    setSeekState((prev) => ({\r\n      ...prev,\r\n      isHovering: false,\r\n      hasInitialPosition: false,\r\n    }));\r\n\r\n    justCommittedRef.current = false;\r\n    seekRectRef.current = null;\r\n    collisionDataRef.current = null;\r\n\r\n    pointerEnterTimeRef.current = 0;\r\n    horizontalMovementRef.current = 0;\r\n    verticalMovementRef.current = 0;\r\n    lastPointerXRef.current = 0;\r\n    lastPointerYRef.current = 0;\r\n    lastSeekCommitTimeRef.current = 0;\r\n\r\n    if (!tooltipDisabled) {\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_PREVIEW_REQUEST,\r\n        detail: undefined,\r\n      });\r\n    }\r\n  }, [dispatch, tooltipDisabled]);\r\n\r\n  const onPointerMove = React.useCallback(\r\n    (event: React.PointerEvent<HTMLDivElement>) => {\r\n      if (seekableEnd <= 0) return;\r\n\r\n      if (!seekRectRef.current && seekRef.current) {\r\n        seekRectRef.current = seekRef.current.getBoundingClientRect();\r\n      }\r\n\r\n      if (!seekRectRef.current) return;\r\n\r\n      const currentX = event.clientX;\r\n      const currentY = event.clientY;\r\n\r\n      if (lastPointerXRef.current !== 0 && lastPointerYRef.current !== 0) {\r\n        const deltaX = Math.abs(currentX - lastPointerXRef.current);\r\n        const deltaY = Math.abs(currentY - lastPointerYRef.current);\r\n\r\n        horizontalMovementRef.current += deltaX;\r\n        verticalMovementRef.current += deltaY;\r\n      }\r\n\r\n      lastPointerXRef.current = currentX;\r\n      lastPointerYRef.current = currentY;\r\n\r\n      if (rafIdRef.current) {\r\n        cancelAnimationFrame(rafIdRef.current);\r\n      }\r\n\r\n      rafIdRef.current = requestAnimationFrame(() => {\r\n        const wasJustCommitted = justCommittedRef.current;\r\n        if (wasJustCommitted) {\r\n          justCommittedRef.current = false;\r\n        }\r\n\r\n        const seekRect = seekRectRef.current;\r\n        if (!seekRect) {\r\n          rafIdRef.current = null;\r\n          return;\r\n        }\r\n\r\n        const clientX = lastPointerXRef.current;\r\n        const offsetXOnSeekBar = Math.max(\r\n          0,\r\n          Math.min(clientX - seekRect.left, seekRect.width),\r\n        );\r\n        const relativeX = offsetXOnSeekBar / seekRect.width;\r\n        const calculatedHoverTime = relativeX * seekableEnd;\r\n\r\n        hoverTimeRef.current = calculatedHoverTime;\r\n\r\n        onHoverProgressUpdate();\r\n\r\n        const wasHovering = seekState.isHovering;\r\n        const isCurrentlyHovering =\r\n          clientX >= seekRect.left && clientX <= seekRect.right;\r\n\r\n        const timeHovering = Date.now() - pointerEnterTimeRef.current;\r\n        const totalMovement =\r\n          horizontalMovementRef.current + verticalMovementRef.current;\r\n        const horizontalRatio =\r\n          totalMovement > 0 ? horizontalMovementRef.current / totalMovement : 0;\r\n\r\n        const timeSinceSeekCommit = Date.now() - lastSeekCommitTimeRef.current;\r\n        const isInSeekCooldown = timeSinceSeekCommit < 300;\r\n\r\n        const shouldShowTooltip =\r\n          !wasJustCommitted &&\r\n          !isInSeekCooldown &&\r\n          (timeHovering > 150 ||\r\n            horizontalRatio > 0.6 ||\r\n            (totalMovement < 10 && timeHovering > 50));\r\n\r\n        if (\r\n          !wasHovering &&\r\n          isCurrentlyHovering &&\r\n          shouldShowTooltip &&\r\n          !tooltipDisabled\r\n        ) {\r\n          setSeekState((prev) => ({ ...prev, isHovering: true }));\r\n        }\r\n\r\n        if (!tooltipDisabled) {\r\n          onPreviewUpdate(calculatedHoverTime);\r\n\r\n          if (isCurrentlyHovering && (wasHovering || shouldShowTooltip)) {\r\n            onTooltipPositionUpdate(clientX);\r\n          }\r\n        }\r\n\r\n        rafIdRef.current = null;\r\n      });\r\n    },\r\n    [\r\n      onPreviewUpdate,\r\n      onTooltipPositionUpdate,\r\n      onHoverProgressUpdate,\r\n      seekableEnd,\r\n      seekState.isHovering,\r\n      tooltipDisabled,\r\n    ],\r\n  );\r\n\r\n  const onSeek = React.useCallback(\r\n    (value: number[]) => {\r\n      const time = value[0] ?? 0;\r\n\r\n      setSeekState((prev) => ({ ...prev, pendingSeekTime: time }));\r\n\r\n      if (!store.getState().dragging) {\r\n        store.setState(\"dragging\", true);\r\n      }\r\n\r\n      if (seekThrottleRef.current) {\r\n        cancelAnimationFrame(seekThrottleRef.current);\r\n      }\r\n\r\n      seekThrottleRef.current = requestAnimationFrame(() => {\r\n        dispatch({\r\n          type: MediaActionTypes.MEDIA_SEEK_REQUEST,\r\n          detail: time,\r\n        });\r\n        seekThrottleRef.current = null;\r\n      });\r\n    },\r\n    [dispatch, store.getState, store.setState],\r\n  );\r\n\r\n  const onSeekCommit = React.useCallback(\r\n    (value: number[]) => {\r\n      const time = value[0] ?? 0;\r\n\r\n      if (seekThrottleRef.current) {\r\n        cancelAnimationFrame(seekThrottleRef.current);\r\n        seekThrottleRef.current = null;\r\n      }\r\n\r\n      if (hoverTimeoutRef.current) {\r\n        clearTimeout(hoverTimeoutRef.current);\r\n        hoverTimeoutRef.current = null;\r\n      }\r\n      if (rafIdRef.current) {\r\n        cancelAnimationFrame(rafIdRef.current);\r\n        rafIdRef.current = null;\r\n      }\r\n      if (previewDebounceRef.current) {\r\n        cancelAnimationFrame(previewDebounceRef.current);\r\n        previewDebounceRef.current = null;\r\n      }\r\n\r\n      setSeekState((prev) => ({\r\n        ...prev,\r\n        pendingSeekTime: time,\r\n        isHovering: false,\r\n        hasInitialPosition: false,\r\n      }));\r\n\r\n      justCommittedRef.current = true;\r\n      collisionDataRef.current = null;\r\n      lastSeekCommitTimeRef.current = Date.now();\r\n\r\n      // Reset movement tracking after seek commit\r\n      pointerEnterTimeRef.current = Date.now();\r\n      horizontalMovementRef.current = 0;\r\n      verticalMovementRef.current = 0;\r\n\r\n      if (store.getState().dragging) {\r\n        store.setState(\"dragging\", false);\r\n      }\r\n\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_SEEK_REQUEST,\r\n        detail: time,\r\n      });\r\n\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_PREVIEW_REQUEST,\r\n        detail: undefined,\r\n      });\r\n    },\r\n    [dispatch, store.getState, store.setState],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    return () => {\r\n      if (seekThrottleRef.current) {\r\n        cancelAnimationFrame(seekThrottleRef.current);\r\n      }\r\n      if (hoverTimeoutRef.current) {\r\n        clearTimeout(hoverTimeoutRef.current);\r\n      }\r\n      if (rafIdRef.current) {\r\n        cancelAnimationFrame(rafIdRef.current);\r\n      }\r\n      if (previewDebounceRef.current) {\r\n        cancelAnimationFrame(previewDebounceRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const currentChapterCue = getCurrentChapterCue(hoverTimeRef.current);\r\n  const thumbnail = getThumbnail(hoverTimeRef.current);\r\n  const hoverTime = getCachedTime(hoverTimeRef.current, seekableEnd);\r\n\r\n  const chapterSeparators = React.useMemo(() => {\r\n    if (withoutChapter || chapterCues.length <= 1 || seekableEnd <= 0) {\r\n      return null;\r\n    }\r\n\r\n    return chapterCues.slice(1).map((chapterCue, index) => {\r\n      const position = (chapterCue.startTime / seekableEnd) * 100;\r\n\r\n      return (\r\n        <div\r\n          key={`chapter-${index}-${chapterCue.startTime}`}\r\n          role=\"presentation\"\r\n          aria-hidden=\"true\"\r\n          data-slot=\"media-player-seek-chapter-separator\"\r\n          className=\"absolute top-0 h-full bg-zinc-50 dark:bg-zinc-950\"\r\n          style={{\r\n            width: \".1563rem\",\r\n            left: `${position}%`,\r\n            transform: \"translateX(-50%)\",\r\n          }}\r\n        />\r\n      );\r\n    });\r\n  }, [chapterCues, seekableEnd, withoutChapter]);\r\n\r\n  const spriteStyle = React.useMemo<React.CSSProperties>(() => {\r\n    if (!thumbnail?.coords || !thumbnail?.src) {\r\n      return {};\r\n    }\r\n\r\n    const coordX = thumbnail.coords[0];\r\n    const coordY = thumbnail.coords[1];\r\n\r\n    const spriteWidth = Number.parseFloat(thumbnail.coords[2] ?? \"0\");\r\n    const spriteHeight = Number.parseFloat(thumbnail.coords[3] ?? \"0\");\r\n\r\n    const scaleX = spriteWidth > 0 ? SPRITE_CONTAINER_WIDTH / spriteWidth : 1;\r\n    const scaleY =\r\n      spriteHeight > 0 ? SPRITE_CONTAINER_HEIGHT / spriteHeight : 1;\r\n    const scale = Math.min(scaleX, scaleY);\r\n\r\n    return {\r\n      width: `${spriteWidth}px`,\r\n      height: `${spriteHeight}px`,\r\n      backgroundImage: `url(${thumbnail.src})`,\r\n      backgroundPosition: `-${coordX}px -${coordY}px`,\r\n      backgroundRepeat: \"no-repeat\",\r\n      transform: `scale(${scale})`,\r\n      transformOrigin: \"top left\",\r\n    };\r\n  }, [thumbnail?.coords, thumbnail?.src]);\r\n\r\n  const SeekSlider = (\r\n    <div data-slot=\"media-player-seek-container\" className=\"relative w-full\">\r\n      <SliderPrimitive.Root\r\n        aria-controls={context.mediaId}\r\n        aria-valuetext={`${currentTime} of ${duration}`}\r\n        data-hovering={seekState.isHovering ? \"\" : undefined}\r\n        data-slider=\"\"\r\n        data-slot=\"media-player-seek\"\r\n        disabled={isDisabled}\r\n        {...seekProps}\r\n        ref={seekRef}\r\n        min={seekableStart}\r\n        max={seekableEnd}\r\n        step={0.01}\r\n        className={cn(\r\n          \"relative flex w-full touch-none select-none items-center data-disabled:pointer-events-none data-disabled:opacity-50\",\r\n          className,\r\n        )}\r\n        value={[displayValue]}\r\n        onValueChange={onSeek}\r\n        onValueCommit={onSeekCommit}\r\n        onPointerEnter={onPointerEnter}\r\n        onPointerLeave={onPointerLeave}\r\n        onPointerMove={onPointerMove}\r\n      >\r\n        <SliderPrimitive.Track className=\"relative h-1 w-full grow overflow-hidden rounded-full bg-primary/40\">\r\n          <div\r\n            data-slot=\"media-player-seek-buffered\"\r\n            className=\"absolute h-full bg-primary/70 will-change-[width]\"\r\n            style={{\r\n              width: `${bufferedProgress * 100}%`,\r\n            }}\r\n          />\r\n          <SliderPrimitive.Range className=\"absolute h-full bg-primary will-change-[width]\" />\r\n          {seekState.isHovering && seekableEnd > 0 && (\r\n            <div\r\n              data-slot=\"media-player-seek-hover-range\"\r\n              className=\"absolute h-full bg-primary/70 will-change-[width,opacity]\"\r\n              style={{\r\n                width: `var(${SEEK_HOVER_PERCENT}, 0%)`,\r\n                transition: \"opacity 150ms ease-out\",\r\n              }}\r\n            />\r\n          )}\r\n          {chapterSeparators}\r\n        </SliderPrimitive.Track>\r\n        <SliderPrimitive.Thumb className=\"relative z-10 block size-2.5 shrink-0 rounded-full bg-primary shadow-sm ring-ring/50 transition-[color,box-shadow] will-change-transform hover:ring-4 focus-visible:outline-hidden focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50\" />\r\n      </SliderPrimitive.Root>\r\n      {!withoutTooltip &&\r\n        !context.withoutTooltip &&\r\n        seekState.isHovering &&\r\n        seekableEnd > 0 && (\r\n          <MediaPlayerPortal>\r\n            <div\r\n              ref={tooltipRef}\r\n              className=\"backface-hidden contain-[layout_style] pointer-events-none z-50 [transition:opacity_150ms_ease-in-out]\"\r\n              style={{\r\n                position: \"fixed\" as const,\r\n                left: `var(${SEEK_TOOLTIP_X}, 0rem)`,\r\n                top: `var(${SEEK_TOOLTIP_Y}, 0rem)`,\r\n                transform: `translateX(-50%) translateY(calc(-100% - ${currentTooltipSideOffset}px))`,\r\n                visibility: seekState.hasInitialPosition ? \"visible\" : \"hidden\",\r\n                opacity: seekState.hasInitialPosition ? 1 : 0,\r\n              }}\r\n            >\r\n              <div\r\n                className={cn(\r\n                  \"flex flex-col items-center gap-1.5 rounded-md border bg-background text-foreground shadow-sm dark:bg-zinc-900\",\r\n                  thumbnail && \"min-h-10\",\r\n                  !thumbnail && currentChapterCue && \"px-3 py-1.5\",\r\n                )}\r\n              >\r\n                {thumbnail?.src && (\r\n                  <div\r\n                    data-slot=\"media-player-seek-thumbnail\"\r\n                    className=\"overflow-hidden rounded-md rounded-b-none\"\r\n                    style={{\r\n                      width: `${SPRITE_CONTAINER_WIDTH}px`,\r\n                      height: `${SPRITE_CONTAINER_HEIGHT}px`,\r\n                    }}\r\n                  >\r\n                    {thumbnail.coords ? (\r\n                      <div style={spriteStyle} />\r\n                    ) : (\r\n                      // biome-ignore lint/performance/noImgElement: dynamic thumbnail URLs from media don't work well with Next.js Image optimization\r\n                      <img\r\n                        src={thumbnail.src}\r\n                        alt={`Preview at ${hoverTime}`}\r\n                        className=\"size-full object-cover\"\r\n                      />\r\n                    )}\r\n                  </div>\r\n                )}\r\n                {currentChapterCue && (\r\n                  <div\r\n                    data-slot=\"media-player-seek-chapter-title\"\r\n                    className=\"line-clamp-2 max-w-48 text-balance text-center text-xs\"\r\n                  >\r\n                    {currentChapterCue.text}\r\n                  </div>\r\n                )}\r\n                <div\r\n                  data-slot=\"media-player-seek-time\"\r\n                  className={cn(\r\n                    \"whitespace-nowrap text-center text-xs tabular-nums\",\r\n                    thumbnail && \"pb-1.5\",\r\n                    !(thumbnail || currentChapterCue) && \"px-2.5 py-1\",\r\n                  )}\r\n                >\r\n                  {tooltipTimeVariant === \"progress\"\r\n                    ? `${hoverTime} / ${duration}`\r\n                    : hoverTime}\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </MediaPlayerPortal>\r\n        )}\r\n    </div>\r\n  );\r\n\r\n  if (withTime) {\r\n    return (\r\n      <div className=\"flex w-full items-center gap-2\">\r\n        <span className=\"text-sm tabular-nums\">{currentTime}</span>\r\n        {SeekSlider}\r\n        <span className=\"text-sm tabular-nums\">{remainingTime}</span>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return SeekSlider;\r\n}\r\n\r\ninterface MediaPlayerVolumeProps\r\n  extends React.ComponentProps<typeof SliderPrimitive.Root> {\r\n  asChild?: boolean;\r\n  expandable?: boolean;\r\n}\r\n\r\nfunction MediaPlayerVolume(props: MediaPlayerVolumeProps) {\r\n  const { expandable = false, className, disabled, ...volumeProps } = props;\r\n\r\n  const context = useMediaPlayerContext(VOLUME_NAME);\r\n  const store = useStoreContext(VOLUME_NAME);\r\n  const dispatch = useMediaDispatch();\r\n  const mediaVolume = useMediaSelector((state) => state.mediaVolume ?? 1);\r\n  const mediaMuted = useMediaSelector((state) => state.mediaMuted ?? false);\r\n  const mediaVolumeLevel = useMediaSelector(\r\n    (state) => state.mediaVolumeLevel ?? \"high\",\r\n  );\r\n\r\n  const sliderId = React.useId();\r\n  const volumeTriggerId = React.useId();\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onMute = React.useCallback(() => {\r\n    dispatch({\r\n      type: mediaMuted\r\n        ? MediaActionTypes.MEDIA_UNMUTE_REQUEST\r\n        : MediaActionTypes.MEDIA_MUTE_REQUEST,\r\n    });\r\n  }, [dispatch, mediaMuted]);\r\n\r\n  const onVolumeChange = React.useCallback(\r\n    (value: number[]) => {\r\n      const volume = value[0] ?? 0;\r\n\r\n      if (!store.getState().dragging) {\r\n        store.setState(\"dragging\", true);\r\n      }\r\n\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_VOLUME_REQUEST,\r\n        detail: volume,\r\n      });\r\n    },\r\n    [dispatch, store.getState, store.setState],\r\n  );\r\n\r\n  const onVolumeCommit = React.useCallback(\r\n    (value: number[]) => {\r\n      const volume = value[0] ?? 0;\r\n\r\n      if (store.getState().dragging) {\r\n        store.setState(\"dragging\", false);\r\n      }\r\n\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_VOLUME_REQUEST,\r\n        detail: volume,\r\n      });\r\n    },\r\n    [dispatch, store],\r\n  );\r\n\r\n  const effectiveVolume = mediaMuted ? 0 : mediaVolume;\r\n\r\n  return (\r\n    <div\r\n      data-disabled={isDisabled ? \"\" : undefined}\r\n      data-slot=\"media-player-volume-container\"\r\n      className={cn(\r\n        \"group flex items-center\",\r\n        expandable\r\n          ? \"gap-0 group-focus-within:gap-2 group-hover:gap-1.5\"\r\n          : \"gap-1.5\",\r\n        className,\r\n      )}\r\n    >\r\n      <MediaPlayerTooltip tooltip=\"Volume\" shortcut=\"M\">\r\n        <Button\r\n          id={volumeTriggerId}\r\n          type=\"button\"\r\n          aria-controls={`${context.mediaId} ${sliderId}`}\r\n          aria-label={mediaMuted ? \"Unmute\" : \"Mute\"}\r\n          aria-pressed={mediaMuted}\r\n          data-slot=\"media-player-volume-trigger\"\r\n          data-state={mediaMuted ? \"on\" : \"off\"}\r\n          variant=\"ghost\"\r\n          size=\"icon\"\r\n          className=\"size-8\"\r\n          disabled={isDisabled}\r\n          onClick={onMute}\r\n        >\r\n          {mediaVolumeLevel === \"off\" || mediaMuted ? (\r\n            <VolumeXIcon />\r\n          ) : mediaVolumeLevel === \"high\" ? (\r\n            <Volume2Icon />\r\n          ) : (\r\n            <Volume1Icon />\r\n          )}\r\n        </Button>\r\n      </MediaPlayerTooltip>\r\n      <SliderPrimitive.Root\r\n        id={sliderId}\r\n        aria-controls={context.mediaId}\r\n        aria-valuetext={`${Math.round(effectiveVolume * 100)}% volume`}\r\n        data-slider=\"\"\r\n        data-slot=\"media-player-volume\"\r\n        {...volumeProps}\r\n        min={0}\r\n        max={1}\r\n        step={0.1}\r\n        className={cn(\r\n          \"relative flex touch-none select-none items-center\",\r\n          expandable\r\n            ? \"w-0 opacity-0 transition-[width,opacity] duration-200 ease-in-out group-focus-within:w-16 group-focus-within:opacity-100 group-hover:w-16 group-hover:opacity-100\"\r\n            : \"w-16\",\r\n          className,\r\n        )}\r\n        disabled={isDisabled}\r\n        value={[effectiveVolume]}\r\n        onValueChange={onVolumeChange}\r\n        onValueCommit={onVolumeCommit}\r\n      >\r\n        <SliderPrimitive.Track className=\"relative h-1 w-full grow overflow-hidden rounded-full bg-zinc-500\">\r\n          <SliderPrimitive.Range className=\"absolute h-full bg-primary will-change-[width]\" />\r\n        </SliderPrimitive.Track>\r\n        <SliderPrimitive.Thumb className=\"block size-2.5 shrink-0 rounded-full bg-primary shadow-sm ring-ring/50 transition-[color,box-shadow] will-change-transform hover:ring-4 focus-visible:outline-hidden focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50\" />\r\n      </SliderPrimitive.Root>\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface MediaPlayerTimeProps extends React.ComponentProps<\"div\"> {\r\n  variant?: \"progress\" | \"remaining\" | \"duration\";\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction MediaPlayerTime(props: MediaPlayerTimeProps) {\r\n  const { variant = \"progress\", asChild, className, ...timeProps } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerTime\");\r\n  const mediaCurrentTime = useMediaSelector(\r\n    (state) => state.mediaCurrentTime ?? 0,\r\n  );\r\n  const [, seekableEnd = 0] = useMediaSelector(\r\n    (state) => state.mediaSeekable ?? [0, 0],\r\n  );\r\n\r\n  const times = React.useMemo(() => {\r\n    if (variant === \"remaining\") {\r\n      return {\r\n        remaining: timeUtils.formatTime(\r\n          seekableEnd - mediaCurrentTime,\r\n          seekableEnd,\r\n        ),\r\n      };\r\n    }\r\n\r\n    if (variant === \"duration\") {\r\n      return {\r\n        duration: timeUtils.formatTime(seekableEnd, seekableEnd),\r\n      };\r\n    }\r\n\r\n    return {\r\n      current: timeUtils.formatTime(mediaCurrentTime, seekableEnd),\r\n      duration: timeUtils.formatTime(seekableEnd, seekableEnd),\r\n    };\r\n  }, [variant, mediaCurrentTime, seekableEnd]);\r\n\r\n  const TimePrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  if (variant === \"remaining\" || variant === \"duration\") {\r\n    return (\r\n      <TimePrimitive\r\n        data-slot=\"media-player-time\"\r\n        data-variant={variant}\r\n        dir={context.dir}\r\n        {...timeProps}\r\n        className={cn(\"text-foreground/80 text-sm tabular-nums\", className)}\r\n      >\r\n        {times[variant]}\r\n      </TimePrimitive>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <TimePrimitive\r\n      data-slot=\"media-player-time\"\r\n      data-variant={variant}\r\n      dir={context.dir}\r\n      {...timeProps}\r\n      className={cn(\r\n        \"flex items-center gap-1 text-foreground/80 text-sm\",\r\n        className,\r\n      )}\r\n    >\r\n      <span className=\"tabular-nums\">{times.current}</span>\r\n      <span role=\"separator\" aria-hidden=\"true\" aria-valuenow={0} tabIndex={-1}>\r\n        /\r\n      </span>\r\n      <span className=\"tabular-nums\">{times.duration}</span>\r\n    </TimePrimitive>\r\n  );\r\n}\r\n\r\ninterface MediaPlayerPlaybackSpeedProps\r\n  extends React.ComponentProps<typeof DropdownMenuTrigger>,\r\n    React.ComponentProps<typeof Button>,\r\n    Omit<React.ComponentProps<typeof DropdownMenu>, \"dir\">,\r\n    Pick<React.ComponentProps<typeof DropdownMenuContent>, \"sideOffset\"> {\r\n  speeds?: number[];\r\n}\r\n\r\nfunction MediaPlayerPlaybackSpeed(props: MediaPlayerPlaybackSpeedProps) {\r\n  const {\r\n    open,\r\n    defaultOpen,\r\n    onOpenChange: onOpenChangeProp,\r\n    sideOffset = FLOATING_MENU_SIDE_OFFSET,\r\n    speeds = SPEEDS,\r\n    modal = false,\r\n    className,\r\n    disabled,\r\n    ...playbackSpeedProps\r\n  } = props;\r\n\r\n  const context = useMediaPlayerContext(PLAYBACK_SPEED_NAME);\r\n  const store = useStoreContext(PLAYBACK_SPEED_NAME);\r\n  const dispatch = useMediaDispatch();\r\n  const mediaPlaybackRate = useMediaSelector(\r\n    (state) => state.mediaPlaybackRate ?? 1,\r\n  );\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onPlaybackRateChange = React.useCallback(\r\n    (rate: number) => {\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_PLAYBACK_RATE_REQUEST,\r\n        detail: rate,\r\n      });\r\n    },\r\n    [dispatch],\r\n  );\r\n\r\n  const onOpenChange = React.useCallback(\r\n    (open: boolean) => {\r\n      store.setState(\"menuOpen\", open);\r\n      onOpenChangeProp?.(open);\r\n    },\r\n    [store.setState, onOpenChangeProp],\r\n  );\r\n\r\n  return (\r\n    <DropdownMenu\r\n      modal={modal}\r\n      open={open}\r\n      defaultOpen={defaultOpen}\r\n      onOpenChange={onOpenChange}\r\n    >\r\n      <MediaPlayerTooltip tooltip=\"Playback speed\" shortcut={[\"<\", \">\"]}>\r\n        <DropdownMenuTrigger asChild>\r\n          <Button\r\n            type=\"button\"\r\n            aria-controls={context.mediaId}\r\n            disabled={isDisabled}\r\n            {...playbackSpeedProps}\r\n            variant=\"ghost\"\r\n            size=\"icon\"\r\n            className={cn(\"h-8 w-16 aria-expanded:bg-accent/50\", className)}\r\n          >\r\n            {mediaPlaybackRate}x\r\n          </Button>\r\n        </DropdownMenuTrigger>\r\n      </MediaPlayerTooltip>\r\n      <DropdownMenuContent\r\n        container={context.portalContainer}\r\n        sideOffset={sideOffset}\r\n        align=\"center\"\r\n        className=\"min-w-(--radix-dropdown-menu-trigger-width) data-[side=top]:mb-3.5\"\r\n      >\r\n        {speeds.map((speed) => (\r\n          <DropdownMenuItem\r\n            key={speed}\r\n            className=\"justify-between\"\r\n            onSelect={() => onPlaybackRateChange(speed)}\r\n          >\r\n            {speed}x{mediaPlaybackRate === speed && <CheckIcon />}\r\n          </DropdownMenuItem>\r\n        ))}\r\n      </DropdownMenuContent>\r\n    </DropdownMenu>\r\n  );\r\n}\r\n\r\ninterface MediaPlayerLoopProps extends React.ComponentProps<typeof Button> {}\r\n\r\nfunction MediaPlayerLoop(props: MediaPlayerLoopProps) {\r\n  const { children, className, disabled, ...loopProps } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerLoop\");\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const [isLooping, setIsLooping] = React.useState(() => {\r\n    const mediaElement = context.mediaRef.current;\r\n    return mediaElement?.loop ?? false;\r\n  });\r\n\r\n  React.useEffect(() => {\r\n    const mediaElement = context.mediaRef.current;\r\n    if (!mediaElement) return;\r\n\r\n    setIsLooping(mediaElement.loop);\r\n\r\n    const checkLoop = () => setIsLooping(mediaElement.loop);\r\n    const observer = new MutationObserver(checkLoop);\r\n    observer.observe(mediaElement, {\r\n      attributes: true,\r\n      attributeFilter: [\"loop\"],\r\n    });\r\n\r\n    return () => observer.disconnect();\r\n  }, [context.mediaRef]);\r\n\r\n  const onLoopToggle = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const mediaElement = context.mediaRef.current;\r\n      if (mediaElement) {\r\n        const newLoopState = !mediaElement.loop;\r\n        mediaElement.loop = newLoopState;\r\n        setIsLooping(newLoopState);\r\n      }\r\n    },\r\n    [context.mediaRef, props.onClick],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip\r\n      tooltip={isLooping ? \"Disable loop\" : \"Enable loop\"}\r\n      shortcut=\"R\"\r\n    >\r\n      <Button\r\n        type=\"button\"\r\n        aria-controls={context.mediaId}\r\n        aria-label={isLooping ? \"Disable loop\" : \"Enable loop\"}\r\n        aria-pressed={isLooping}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-loop\"\r\n        data-state={isLooping ? \"on\" : \"off\"}\r\n        disabled={isDisabled}\r\n        {...loopProps}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onLoopToggle}\r\n      >\r\n        {children ??\r\n          (isLooping ? (\r\n            <RepeatIcon className=\"text-muted-foreground\" />\r\n          ) : (\r\n            <RepeatIcon />\r\n          ))}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n}\r\n\r\ninterface MediaPlayerFullscreenProps\r\n  extends React.ComponentProps<typeof Button> {}\r\n\r\nfunction MediaPlayerFullscreen(props: MediaPlayerFullscreenProps) {\r\n  const { children, className, disabled, ...fullscreenProps } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerFullscreen\");\r\n  const dispatch = useMediaDispatch();\r\n  const isFullscreen = useMediaSelector(\r\n    (state) => state.mediaIsFullscreen ?? false,\r\n  );\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onFullscreen = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      dispatch({\r\n        type: isFullscreen\r\n          ? MediaActionTypes.MEDIA_EXIT_FULLSCREEN_REQUEST\r\n          : MediaActionTypes.MEDIA_ENTER_FULLSCREEN_REQUEST,\r\n      });\r\n    },\r\n    [dispatch, props.onClick, isFullscreen],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip tooltip=\"Fullscreen\" shortcut=\"F\">\r\n      <Button\r\n        type=\"button\"\r\n        aria-label={isFullscreen ? \"Exit fullscreen\" : \"Enter fullscreen\"}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-fullscreen\"\r\n        data-state={isFullscreen ? \"on\" : \"off\"}\r\n        disabled={isDisabled}\r\n        {...fullscreenProps}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onFullscreen}\r\n      >\r\n        {children ?? (isFullscreen ? <Minimize2Icon /> : <Maximize2Icon />)}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n}\r\n\r\ninterface MediaPlayerPiPProps\r\n  extends Omit<React.ComponentProps<typeof Button>, \"children\"> {\r\n  children?:\r\n    | React.ReactNode\r\n    | ((isPictureInPicture: boolean) => React.ReactNode);\r\n  onPipError?: (error: unknown, state: \"enter\" | \"exit\") => void;\r\n}\r\n\r\nfunction MediaPlayerPiP(props: MediaPlayerPiPProps) {\r\n  const { children, className, onPipError, disabled, ...pipButtonProps } =\r\n    props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerPiP\");\r\n  const dispatch = useMediaDispatch();\r\n  const isPictureInPicture = useMediaSelector(\r\n    (state) => state.mediaIsPip ?? false,\r\n  );\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onPictureInPicture = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      dispatch({\r\n        type: isPictureInPicture\r\n          ? MediaActionTypes.MEDIA_EXIT_PIP_REQUEST\r\n          : MediaActionTypes.MEDIA_ENTER_PIP_REQUEST,\r\n      });\r\n\r\n      const mediaElement = context.mediaRef.current;\r\n\r\n      if (mediaElement instanceof HTMLVideoElement) {\r\n        if (isPictureInPicture) {\r\n          document.exitPictureInPicture().catch((error) => {\r\n            onPipError?.(error, \"exit\");\r\n          });\r\n        } else {\r\n          mediaElement.requestPictureInPicture().catch((error) => {\r\n            onPipError?.(error, \"enter\");\r\n          });\r\n        }\r\n      }\r\n    },\r\n    [dispatch, props.onClick, isPictureInPicture, onPipError, context.mediaRef],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip tooltip=\"Picture in picture\" shortcut=\"P\">\r\n      <Button\r\n        type=\"button\"\r\n        aria-controls={context.mediaId}\r\n        aria-label={isPictureInPicture ? \"Exit pip\" : \"Enter pip\"}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-pip\"\r\n        data-state={isPictureInPicture ? \"on\" : \"off\"}\r\n        disabled={isDisabled}\r\n        {...pipButtonProps}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onPictureInPicture}\r\n      >\r\n        {typeof children === \"function\"\r\n          ? children(isPictureInPicture)\r\n          : (children ??\r\n            (isPictureInPicture ? (\r\n              <PictureInPicture2Icon />\r\n            ) : (\r\n              <PictureInPictureIcon />\r\n            )))}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n}\r\n\r\nfunction MediaPlayerCaptions(props: React.ComponentProps<typeof Button>) {\r\n  const { children, className, disabled, ...captionsProps } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerCaptions\");\r\n  const dispatch = useMediaDispatch();\r\n  const isSubtitlesActive = useMediaSelector(\r\n    (state) => (state.mediaSubtitlesShowing ?? []).length > 0,\r\n  );\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n  const onCaptionsToggle = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_TOGGLE_SUBTITLES_REQUEST,\r\n      });\r\n    },\r\n    [dispatch, props.onClick],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip tooltip=\"Captions\" shortcut=\"C\">\r\n      <Button\r\n        type=\"button\"\r\n        aria-controls={context.mediaId}\r\n        aria-label={isSubtitlesActive ? \"Disable captions\" : \"Enable captions\"}\r\n        aria-pressed={isSubtitlesActive}\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-captions\"\r\n        data-state={isSubtitlesActive ? \"on\" : \"off\"}\r\n        disabled={isDisabled}\r\n        {...captionsProps}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onCaptionsToggle}\r\n      >\r\n        {children ??\r\n          (isSubtitlesActive ? <SubtitlesIcon /> : <CaptionsOffIcon />)}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n}\r\n\r\nfunction MediaPlayerDownload(props: React.ComponentProps<typeof Button>) {\r\n  const { children, className, disabled, ...downloadProps } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerDownload\");\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n\r\n  const onDownload = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      props.onClick?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      const mediaElement = context.mediaRef.current;\r\n\r\n      if (!mediaElement || !mediaElement.currentSrc) return;\r\n\r\n      const link = document.createElement(\"a\");\r\n      link.href = mediaElement.currentSrc;\r\n      link.download = \"\";\r\n      document.body.appendChild(link);\r\n      link.click();\r\n      document.body.removeChild(link);\r\n    },\r\n    [context.mediaRef, props.onClick],\r\n  );\r\n\r\n  return (\r\n    <MediaPlayerTooltip tooltip=\"Download\" shortcut=\"D\">\r\n      <Button\r\n        type=\"button\"\r\n        aria-controls={context.mediaId}\r\n        aria-label=\"Download\"\r\n        data-disabled={isDisabled ? \"\" : undefined}\r\n        data-slot=\"media-player-download\"\r\n        disabled={isDisabled}\r\n        {...downloadProps}\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn(\"size-8\", className)}\r\n        onClick={onDownload}\r\n      >\r\n        {children ?? <DownloadIcon />}\r\n      </Button>\r\n    </MediaPlayerTooltip>\r\n  );\r\n}\r\n\r\ninterface MediaPlayerSettingsProps extends MediaPlayerPlaybackSpeedProps {}\r\n\r\nfunction MediaPlayerSettings(props: MediaPlayerSettingsProps) {\r\n  const {\r\n    open,\r\n    defaultOpen,\r\n    onOpenChange: onOpenChangeProp,\r\n    sideOffset = FLOATING_MENU_SIDE_OFFSET,\r\n    speeds = SPEEDS,\r\n    modal = false,\r\n    className,\r\n    disabled,\r\n    ...settingsProps\r\n  } = props;\r\n\r\n  const context = useMediaPlayerContext(SETTINGS_NAME);\r\n  const store = useStoreContext(SETTINGS_NAME);\r\n  const dispatch = useMediaDispatch();\r\n\r\n  const mediaPlaybackRate = useMediaSelector(\r\n    (state) => state.mediaPlaybackRate ?? 1,\r\n  );\r\n  const mediaSubtitlesList = useMediaSelector(\r\n    (state) => state.mediaSubtitlesList ?? [],\r\n  );\r\n  const mediaSubtitlesShowing = useMediaSelector(\r\n    (state) => state.mediaSubtitlesShowing ?? [],\r\n  );\r\n  const mediaRenditionList = useMediaSelector(\r\n    (state) => state.mediaRenditionList ?? [],\r\n  );\r\n  const selectedRenditionId = useMediaSelector(\r\n    (state) => state.mediaRenditionSelected,\r\n  );\r\n\r\n  const isDisabled = disabled || context.disabled;\r\n  const isSubtitlesActive = mediaSubtitlesShowing.length > 0;\r\n\r\n  const onPlaybackRateChange = React.useCallback(\r\n    (rate: number) => {\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_PLAYBACK_RATE_REQUEST,\r\n        detail: rate,\r\n      });\r\n    },\r\n    [dispatch],\r\n  );\r\n\r\n  const onRenditionChange = React.useCallback(\r\n    (renditionId: string) => {\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_RENDITION_REQUEST,\r\n        detail: renditionId === \"auto\" ? undefined : renditionId,\r\n      });\r\n    },\r\n    [dispatch],\r\n  );\r\n\r\n  const onSubtitlesToggle = React.useCallback(() => {\r\n    dispatch({\r\n      type: MediaActionTypes.MEDIA_TOGGLE_SUBTITLES_REQUEST,\r\n      detail: false,\r\n    });\r\n  }, [dispatch]);\r\n\r\n  const onShowSubtitleTrack = React.useCallback(\r\n    (subtitleTrack: (typeof mediaSubtitlesList)[number]) => {\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_TOGGLE_SUBTITLES_REQUEST,\r\n        detail: false,\r\n      });\r\n      dispatch({\r\n        type: MediaActionTypes.MEDIA_SHOW_SUBTITLES_REQUEST,\r\n        detail: subtitleTrack,\r\n      });\r\n    },\r\n    [dispatch],\r\n  );\r\n\r\n  const selectedSubtitleLabel = React.useMemo(() => {\r\n    if (!isSubtitlesActive) return \"Off\";\r\n    if (mediaSubtitlesShowing.length > 0) {\r\n      return mediaSubtitlesShowing[0]?.label ?? \"On\";\r\n    }\r\n    return \"Off\";\r\n  }, [isSubtitlesActive, mediaSubtitlesShowing]);\r\n\r\n  const selectedRenditionLabel = React.useMemo(() => {\r\n    if (!selectedRenditionId) return \"Auto\";\r\n\r\n    const currentRendition = mediaRenditionList?.find(\r\n      (rendition) => rendition.id === selectedRenditionId,\r\n    );\r\n    if (!currentRendition) return \"Auto\";\r\n\r\n    if (currentRendition.height) return `${currentRendition.height}p`;\r\n    if (currentRendition.width) return `${currentRendition.width}p`;\r\n    return currentRendition.id ?? \"Auto\";\r\n  }, [selectedRenditionId, mediaRenditionList]);\r\n\r\n  const onOpenChange = React.useCallback(\r\n    (open: boolean) => {\r\n      store.setState(\"menuOpen\", open);\r\n      onOpenChangeProp?.(open);\r\n    },\r\n    [store.setState, onOpenChangeProp],\r\n  );\r\n\r\n  return (\r\n    <DropdownMenu\r\n      modal={modal}\r\n      open={open}\r\n      defaultOpen={defaultOpen}\r\n      onOpenChange={onOpenChange}\r\n    >\r\n      <MediaPlayerTooltip tooltip=\"Settings\">\r\n        <DropdownMenuTrigger asChild>\r\n          <Button\r\n            type=\"button\"\r\n            aria-controls={context.mediaId}\r\n            aria-label=\"Settings\"\r\n            data-disabled={isDisabled ? \"\" : undefined}\r\n            data-slot=\"media-player-settings\"\r\n            disabled={isDisabled}\r\n            {...settingsProps}\r\n            variant=\"ghost\"\r\n            size=\"icon\"\r\n            className={cn(\"size-8 aria-expanded:bg-accent/50\", className)}\r\n          >\r\n            <SettingsIcon />\r\n          </Button>\r\n        </DropdownMenuTrigger>\r\n      </MediaPlayerTooltip>\r\n      <DropdownMenuContent\r\n        align=\"end\"\r\n        side=\"top\"\r\n        sideOffset={sideOffset}\r\n        container={context.portalContainer}\r\n        className=\"w-56 data-[side=top]:mb-3.5\"\r\n      >\r\n        <DropdownMenuLabel className=\"sr-only\">Settings</DropdownMenuLabel>\r\n        <DropdownMenuSub>\r\n          <DropdownMenuSubTrigger>\r\n            <span className=\"flex-1\">Speed</span>\r\n            <Badge variant=\"outline\" className=\"rounded-sm\">\r\n              {mediaPlaybackRate}x\r\n            </Badge>\r\n          </DropdownMenuSubTrigger>\r\n          <DropdownMenuSubContent>\r\n            {speeds.map((speed) => (\r\n              <DropdownMenuItem\r\n                key={speed}\r\n                className=\"justify-between\"\r\n                onSelect={() => onPlaybackRateChange(speed)}\r\n              >\r\n                {speed}x{mediaPlaybackRate === speed && <CheckIcon />}\r\n              </DropdownMenuItem>\r\n            ))}\r\n          </DropdownMenuSubContent>\r\n        </DropdownMenuSub>\r\n        {context.isVideo && mediaRenditionList.length > 0 && (\r\n          <DropdownMenuSub>\r\n            <DropdownMenuSubTrigger>\r\n              <span className=\"flex-1\">Quality</span>\r\n              <Badge variant=\"outline\" className=\"rounded-sm\">\r\n                {selectedRenditionLabel}\r\n              </Badge>\r\n            </DropdownMenuSubTrigger>\r\n            <DropdownMenuSubContent>\r\n              <DropdownMenuItem\r\n                className=\"justify-between\"\r\n                onSelect={() => onRenditionChange(\"auto\")}\r\n              >\r\n                Auto\r\n                {!selectedRenditionId && <CheckIcon />}\r\n              </DropdownMenuItem>\r\n              {mediaRenditionList\r\n                .slice()\r\n                .sort((a, b) => {\r\n                  const aHeight = a.height ?? 0;\r\n                  const bHeight = b.height ?? 0;\r\n                  return bHeight - aHeight;\r\n                })\r\n                .map((rendition) => {\r\n                  const label = rendition.height\r\n                    ? `${rendition.height}p`\r\n                    : rendition.width\r\n                      ? `${rendition.width}p`\r\n                      : (rendition.id ?? \"Unknown\");\r\n\r\n                  const selected = rendition.id === selectedRenditionId;\r\n\r\n                  return (\r\n                    <DropdownMenuItem\r\n                      key={rendition.id}\r\n                      className=\"justify-between\"\r\n                      onSelect={() => onRenditionChange(rendition.id ?? \"\")}\r\n                    >\r\n                      {label}\r\n                      {selected && <CheckIcon />}\r\n                    </DropdownMenuItem>\r\n                  );\r\n                })}\r\n            </DropdownMenuSubContent>\r\n          </DropdownMenuSub>\r\n        )}\r\n        <DropdownMenuSub>\r\n          <DropdownMenuSubTrigger>\r\n            <span className=\"flex-1\">Captions</span>\r\n            <Badge variant=\"outline\" className=\"rounded-sm\">\r\n              {selectedSubtitleLabel}\r\n            </Badge>\r\n          </DropdownMenuSubTrigger>\r\n          <DropdownMenuSubContent>\r\n            <DropdownMenuItem\r\n              className=\"justify-between\"\r\n              onSelect={onSubtitlesToggle}\r\n            >\r\n              Off\r\n              {!isSubtitlesActive && <CheckIcon />}\r\n            </DropdownMenuItem>\r\n            {mediaSubtitlesList.map((subtitleTrack) => {\r\n              const isSelected = mediaSubtitlesShowing.some(\r\n                (showingSubtitle) =>\r\n                  showingSubtitle.label === subtitleTrack.label,\r\n              );\r\n              return (\r\n                <DropdownMenuItem\r\n                  key={`${subtitleTrack.kind}-${subtitleTrack.label}-${subtitleTrack.language}`}\r\n                  className=\"justify-between\"\r\n                  onSelect={() => onShowSubtitleTrack(subtitleTrack)}\r\n                >\r\n                  {subtitleTrack.label}\r\n                  {isSelected && <CheckIcon />}\r\n                </DropdownMenuItem>\r\n              );\r\n            })}\r\n            {mediaSubtitlesList.length === 0 && (\r\n              <DropdownMenuItem disabled>\r\n                No captions available\r\n              </DropdownMenuItem>\r\n            )}\r\n          </DropdownMenuSubContent>\r\n        </DropdownMenuSub>\r\n      </DropdownMenuContent>\r\n    </DropdownMenu>\r\n  );\r\n}\r\n\r\ninterface MediaPlayerPortalProps {\r\n  container?: Element | DocumentFragment | null;\r\n  children?: React.ReactNode;\r\n}\r\n\r\nfunction MediaPlayerPortal(props: MediaPlayerPortalProps) {\r\n  const { container: containerProp, children } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerPortal\");\r\n  const container = containerProp ?? context.portalContainer;\r\n\r\n  if (!container) return null;\r\n\r\n  return ReactDOM.createPortal(children, container);\r\n}\r\n\r\ninterface MediaPlayerTooltipProps\r\n  extends React.ComponentProps<typeof Tooltip>,\r\n    Pick<React.ComponentProps<typeof TooltipContent>, \"sideOffset\"> {\r\n  tooltip?: string;\r\n  shortcut?: string | string[];\r\n}\r\n\r\nfunction MediaPlayerTooltip(props: MediaPlayerTooltipProps) {\r\n  const {\r\n    tooltip,\r\n    shortcut,\r\n    delayDuration,\r\n    sideOffset,\r\n    children,\r\n    ...tooltipProps\r\n  } = props;\r\n\r\n  const context = useMediaPlayerContext(\"MediaPlayerTooltip\");\r\n  const tooltipDelayDuration = delayDuration ?? context.tooltipDelayDuration;\r\n  const tooltipSideOffset = sideOffset ?? context.tooltipSideOffset;\r\n\r\n  if ((!tooltip && !shortcut) || context.withoutTooltip) return <>{children}</>;\r\n\r\n  return (\r\n    <Tooltip {...tooltipProps} delayDuration={tooltipDelayDuration}>\r\n      <TooltipTrigger\r\n        className=\"text-foreground focus-visible:ring-ring/50\"\r\n        asChild\r\n      >\r\n        {children}\r\n      </TooltipTrigger>\r\n      <TooltipContent\r\n        container={context.portalContainer}\r\n        sideOffset={tooltipSideOffset}\r\n        className=\"flex items-center gap-2 border bg-accent px-2 py-1 font-medium text-foreground data-[side=top]:mb-3.5 dark:bg-zinc-900 [&>span]:hidden\"\r\n      >\r\n        <p>{tooltip}</p>\r\n        {Array.isArray(shortcut) ? (\r\n          <div className=\"flex items-center gap-1\">\r\n            {shortcut.map((shortcutKey) => (\r\n              <kbd\r\n                key={shortcutKey}\r\n                className=\"select-none rounded border bg-secondary px-1.5 py-0.5 font-mono text-[11.2px] text-foreground shadow-xs\"\r\n              >\r\n                <abbr title={shortcutKey} className=\"no-underline\">\r\n                  {shortcutKey}\r\n                </abbr>\r\n              </kbd>\r\n            ))}\r\n          </div>\r\n        ) : (\r\n          shortcut && (\r\n            <kbd\r\n              key={shortcut}\r\n              className=\"select-none rounded border bg-secondary px-1.5 py-px font-mono text-[11.2px] text-foreground shadow-xs\"\r\n            >\r\n              <abbr title={shortcut} className=\"no-underline\">\r\n                {shortcut}\r\n              </abbr>\r\n            </kbd>\r\n          )\r\n        )}\r\n      </TooltipContent>\r\n    </Tooltip>\r\n  );\r\n}\r\n\r\nexport {\r\n  MediaPlayer,\r\n  MediaPlayerVideo,\r\n  MediaPlayerAudio,\r\n  MediaPlayerControls,\r\n  MediaPlayerControlsOverlay,\r\n  MediaPlayerLoading,\r\n  MediaPlayerError,\r\n  MediaPlayerVolumeIndicator,\r\n  MediaPlayerPlay,\r\n  MediaPlayerSeekBackward,\r\n  MediaPlayerSeekForward,\r\n  MediaPlayerSeek,\r\n  MediaPlayerVolume,\r\n  MediaPlayerTime,\r\n  MediaPlayerPlaybackSpeed,\r\n  MediaPlayerLoop,\r\n  MediaPlayerFullscreen,\r\n  MediaPlayerPiP,\r\n  MediaPlayerCaptions,\r\n  MediaPlayerDownload,\r\n  MediaPlayerSettings,\r\n  MediaPlayerPortal,\r\n  MediaPlayerTooltip,\r\n  //\r\n  useMediaSelector as useMediaPlayer,\r\n  useStore as useMediaPlayerStore,\r\n  //\r\n  type MediaPlayerProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}