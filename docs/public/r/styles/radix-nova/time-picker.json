{
  "name": "time-picker",
  "dependencies": [
    "radix-ui"
  ],
  "registryDependencies": [
    "popover",
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/time-picker.tsx",
      "content": "\"use client\";\r\n\r\nimport { Clock } from \"lucide-react\";\r\nimport { Slot as SlotPrimitive } from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport {\r\n  Popover,\r\n  PopoverAnchor,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from \"@/components/ui/popover\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { VisuallyHiddenInput } from \"@/registry/bases/radix/components/visually-hidden-input\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"TimePicker\";\r\nconst LABEL_NAME = \"TimePickerLabel\";\r\nconst INPUT_GROUP_NAME = \"TimePickerInputGroup\";\r\nconst INPUT_NAME = \"TimePickerInput\";\r\nconst TRIGGER_NAME = \"TimePickerTrigger\";\r\nconst CONTENT_NAME = \"TimePickerContent\";\r\nconst COLUMN_NAME = \"TimePickerColumn\";\r\nconst COLUMN_ITEM_NAME = \"TimePickerColumnItem\";\r\nconst HOUR_NAME = \"TimePickerHour\";\r\nconst MINUTE_NAME = \"TimePickerMinute\";\r\nconst SECOND_NAME = \"TimePickerSecond\";\r\nconst PERIOD_NAME = \"TimePickerPeriod\";\r\nconst CLEAR_NAME = \"TimePickerClear\";\r\n\r\nconst DEFAULT_STEP = 1;\r\nconst DEFAULT_SEGMENT_PLACEHOLDER = \"--\";\r\nconst DEFAULT_LOCALE = undefined;\r\nconst SEGMENTS: Segment[] = [\"hour\", \"minute\", \"second\", \"period\"];\r\nconst PERIODS = [\"AM\", \"PM\"] as const;\r\n\r\ntype Segment = \"hour\" | \"minute\" | \"second\" | \"period\";\r\ntype SegmentFormat = \"numeric\" | \"2-digit\";\r\ntype Period = (typeof PERIODS)[number];\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ninterface ButtonProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype PopoverContentProps = React.ComponentProps<typeof PopoverContent>;\r\n\r\ntype InputGroupElement = React.ComponentRef<typeof TimePickerInputGroup>;\r\ntype InputElement = React.ComponentRef<typeof TimePickerInput>;\r\ntype TriggerElement = React.ComponentRef<typeof TimePickerTrigger>;\r\ntype ColumnElement = React.ComponentRef<typeof TimePickerColumn>;\r\ntype ColumnItemElement = React.ComponentRef<typeof TimePickerColumnItem>;\r\n\r\ninterface TimeValue {\r\n  hour?: number;\r\n  minute?: number;\r\n  second?: number;\r\n  period?: Period;\r\n}\r\n\r\ninterface ItemData {\r\n  value: number | string;\r\n  ref: React.RefObject<ColumnItemElement | null>;\r\n  selected: boolean;\r\n}\r\n\r\ninterface ColumnData {\r\n  id: string;\r\n  ref: React.RefObject<ColumnElement | null>;\r\n  getSelectedItemRef: () => React.RefObject<ColumnItemElement | null> | null;\r\n  getItems: () => ItemData[];\r\n}\r\n\r\nfunction focusFirst(\r\n  candidates: React.RefObject<ColumnItemElement | null>[],\r\n  preventScroll = false,\r\n) {\r\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\r\n  for (const candidateRef of candidates) {\r\n    const candidate = candidateRef.current;\r\n    if (!candidate) continue;\r\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\r\n    candidate.focus({ preventScroll });\r\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\r\n  }\r\n}\r\n\r\nfunction sortNodes<T extends { ref: React.RefObject<Element | null> }>(\r\n  items: T[],\r\n): T[] {\r\n  return items.sort((a, b) => {\r\n    const elementA = a.ref.current;\r\n    const elementB = b.ref.current;\r\n    if (!elementA || !elementB) return 0;\r\n    const position = elementA.compareDocumentPosition(elementB);\r\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\r\n      return -1;\r\n    }\r\n    if (position & Node.DOCUMENT_POSITION_PRECEDING) {\r\n      return 1;\r\n    }\r\n    return 0;\r\n  });\r\n}\r\n\r\nfunction getIs12Hour(locale?: string): boolean {\r\n  const testDate = new Date(2000, 0, 1, 13, 0, 0);\r\n  const formatted = new Intl.DateTimeFormat(locale, {\r\n    hour: \"numeric\",\r\n  }).format(testDate);\r\n\r\n  return /am|pm/i.test(formatted) || !formatted.includes(\"13\");\r\n}\r\n\r\nfunction parseTimeString(timeString: string | undefined): TimeValue | null {\r\n  if (!timeString) return null;\r\n\r\n  const parts = timeString.split(\":\");\r\n  if (parts.length < 2) return null;\r\n\r\n  const result: TimeValue = {};\r\n\r\n  if (parts[0] && parts[0] !== DEFAULT_SEGMENT_PLACEHOLDER) {\r\n    const hour = Number.parseInt(parts[0], 10);\r\n    if (!Number.isNaN(hour) && hour >= 0 && hour <= 23) {\r\n      result.hour = hour;\r\n    }\r\n  }\r\n\r\n  if (parts[1] && parts[1] !== DEFAULT_SEGMENT_PLACEHOLDER) {\r\n    const minute = Number.parseInt(parts[1], 10);\r\n    if (!Number.isNaN(minute) && minute >= 0 && minute <= 59) {\r\n      result.minute = minute;\r\n    }\r\n  }\r\n\r\n  if (parts[2] && parts[2] !== DEFAULT_SEGMENT_PLACEHOLDER) {\r\n    const second = Number.parseInt(parts[2], 10);\r\n    if (!Number.isNaN(second) && second >= 0 && second <= 59) {\r\n      result.second = second;\r\n    }\r\n  }\r\n  if (\r\n    result.hour === undefined &&\r\n    result.minute === undefined &&\r\n    result.second === undefined\r\n  ) {\r\n    return null;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction formatTimeValue(value: TimeValue, showSeconds: boolean): string {\r\n  const hourStr =\r\n    value.hour !== undefined\r\n      ? value.hour.toString().padStart(2, \"0\")\r\n      : DEFAULT_SEGMENT_PLACEHOLDER;\r\n  const minuteStr =\r\n    value.minute !== undefined\r\n      ? value.minute.toString().padStart(2, \"0\")\r\n      : DEFAULT_SEGMENT_PLACEHOLDER;\r\n  const secondStr =\r\n    value.second !== undefined\r\n      ? value.second.toString().padStart(2, \"0\")\r\n      : DEFAULT_SEGMENT_PLACEHOLDER;\r\n\r\n  if (showSeconds) {\r\n    return `${hourStr}:${minuteStr}:${secondStr}`;\r\n  }\r\n  return `${hourStr}:${minuteStr}`;\r\n}\r\n\r\nfunction to12Hour(hour24: number): { hour: number; period: Period } {\r\n  const period: Period = hour24 >= 12 ? \"PM\" : \"AM\";\r\n  const hour = hour24 % 12 || 12;\r\n  return { hour, period };\r\n}\r\n\r\nfunction to24Hour(hour12: number, period: Period): number {\r\n  if (hour12 === 12) {\r\n    return period === \"PM\" ? 12 : 0;\r\n  }\r\n  return period === \"PM\" ? hour12 + 12 : hour12;\r\n}\r\n\r\nfunction clamp(value: number, min: number, max: number) {\r\n  return Math.min(Math.max(value, min), max);\r\n}\r\n\r\ninterface StoreState {\r\n  value: string;\r\n  open: boolean;\r\n  openedViaFocus: boolean;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  notify: () => void;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(\r\n  selector: (state: StoreState) => T,\r\n  ogStore?: Store | null,\r\n): T {\r\n  const contextStore = React.useContext(StoreContext);\r\n\r\n  const store = ogStore ?? contextStore;\r\n\r\n  if (!store) {\r\n    throw new Error(`\\`useStore\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ntype SegmentPlaceholder =\r\n  | string\r\n  | {\r\n      hour?: string;\r\n      minute?: string;\r\n      second?: string;\r\n      period?: string;\r\n    };\r\n\r\ninterface TimePickerContextValue {\r\n  id: string;\r\n  inputGroupId: string;\r\n  labelId: string;\r\n  triggerId: string;\r\n  inputGroupRef: React.RefObject<InputGroupElement | null>;\r\n  triggerRef: React.RefObject<TriggerElement | null>;\r\n  openOnFocus: boolean;\r\n  inputGroupClickAction: \"focus\" | \"open\";\r\n  onInputGroupChange: (inputGroup: InputGroupElement | null) => void;\r\n  disabled: boolean;\r\n  readOnly: boolean;\r\n  required: boolean;\r\n  invalid: boolean;\r\n  showSeconds: boolean;\r\n  is12Hour: boolean;\r\n  minuteStep: number;\r\n  secondStep: number;\r\n  hourStep: number;\r\n  segmentPlaceholder: {\r\n    hour: string;\r\n    minute: string;\r\n    second: string;\r\n    period: string;\r\n  };\r\n  min?: string;\r\n  max?: string;\r\n}\r\n\r\nconst TimePickerContext = React.createContext<TimePickerContextValue | null>(\r\n  null,\r\n);\r\n\r\nfunction useTimePickerContext(consumerName: string) {\r\n  const context = React.useContext(TimePickerContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface TimePickerProps extends DivProps {\r\n  value?: string;\r\n  defaultValue?: string;\r\n  onValueChange?: (value: string) => void;\r\n  open?: boolean;\r\n  defaultOpen?: boolean;\r\n  onOpenChange?: (open: boolean) => void;\r\n  openOnFocus?: boolean;\r\n  inputGroupClickAction?: \"focus\" | \"open\";\r\n  min?: string;\r\n  max?: string;\r\n  hourStep?: number;\r\n  minuteStep?: number;\r\n  secondStep?: number;\r\n  segmentPlaceholder?: SegmentPlaceholder;\r\n  locale?: string;\r\n  name?: string;\r\n  disabled?: boolean;\r\n  invalid?: boolean;\r\n  readOnly?: boolean;\r\n  required?: boolean;\r\n  showSeconds?: boolean;\r\n}\r\n\r\nfunction TimePicker(props: TimePickerProps) {\r\n  const {\r\n    value: valueProp,\r\n    defaultValue,\r\n    onValueChange,\r\n    open,\r\n    defaultOpen,\r\n    onOpenChange,\r\n    openOnFocus = false,\r\n    inputGroupClickAction = \"focus\",\r\n    min,\r\n    max,\r\n    hourStep = DEFAULT_STEP,\r\n    minuteStep = DEFAULT_STEP,\r\n    secondStep = DEFAULT_STEP,\r\n    segmentPlaceholder = DEFAULT_SEGMENT_PLACEHOLDER,\r\n    locale = DEFAULT_LOCALE,\r\n    name,\r\n    asChild,\r\n    disabled = false,\r\n    invalid = false,\r\n    readOnly = false,\r\n    required = false,\r\n    showSeconds = false,\r\n    className,\r\n    children,\r\n    id,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const instanceId = React.useId();\r\n  const rootId = id ?? instanceId;\r\n  const inputGroupId = React.useId();\r\n  const labelId = React.useId();\r\n  const triggerId = React.useId();\r\n\r\n  const inputGroupRef = React.useRef<InputGroupElement>(null);\r\n  const triggerRef = React.useRef<TriggerElement>(null);\r\n\r\n  const [inputGroup, setInputGroup] = React.useState<InputGroupElement | null>(\r\n    null,\r\n  );\r\n  const isFormControl = inputGroup ? !!inputGroup.closest(\"form\") : true;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    value: valueProp ?? defaultValue ?? \"\",\r\n    open: open ?? defaultOpen ?? false,\r\n    openedViaFocus: false,\r\n  }));\r\n\r\n  const propsRef = useAsRef({ onValueChange, onOpenChange });\r\n\r\n  const store: Store = React.useMemo(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n\r\n        if (key === \"value\" && typeof value === \"string\") {\r\n          stateRef.current.value = value;\r\n          propsRef.current.onValueChange?.(value);\r\n        } else if (key === \"open\" && typeof value === \"boolean\") {\r\n          stateRef.current.open = value;\r\n          propsRef.current.onOpenChange?.(value);\r\n          if (!value) {\r\n            stateRef.current.openedViaFocus = false;\r\n          }\r\n        } else {\r\n          stateRef.current[key] = value;\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef]);\r\n\r\n  const value = useStore((state) => state.value, store);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (valueProp !== undefined) {\r\n      store.setState(\"value\", valueProp);\r\n    }\r\n  }, [valueProp]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (open !== undefined) {\r\n      store.setState(\"open\", open);\r\n    }\r\n  }, [open]);\r\n\r\n  const storeOpen = useStore((state) => state.open, store);\r\n\r\n  const onPopoverOpenChange = React.useCallback(\r\n    (newOpen: boolean) => store.setState(\"open\", newOpen),\r\n    [store],\r\n  );\r\n\r\n  const is12Hour = React.useMemo(() => getIs12Hour(locale), [locale]);\r\n\r\n  const normalizedPlaceholder = React.useMemo(() => {\r\n    if (typeof segmentPlaceholder === \"string\") {\r\n      return {\r\n        hour: segmentPlaceholder,\r\n        minute: segmentPlaceholder,\r\n        second: segmentPlaceholder,\r\n        period: segmentPlaceholder,\r\n      };\r\n    }\r\n    return {\r\n      hour: segmentPlaceholder.hour ?? DEFAULT_SEGMENT_PLACEHOLDER,\r\n      minute: segmentPlaceholder.minute ?? DEFAULT_SEGMENT_PLACEHOLDER,\r\n      second: segmentPlaceholder.second ?? DEFAULT_SEGMENT_PLACEHOLDER,\r\n      period: segmentPlaceholder.period ?? DEFAULT_SEGMENT_PLACEHOLDER,\r\n    };\r\n  }, [segmentPlaceholder]);\r\n\r\n  const rootContext = React.useMemo<TimePickerContextValue>(\r\n    () => ({\r\n      id: rootId,\r\n      inputGroupId,\r\n      labelId,\r\n      triggerId,\r\n      inputGroupRef,\r\n      triggerRef,\r\n      openOnFocus,\r\n      inputGroupClickAction,\r\n      onInputGroupChange: setInputGroup,\r\n      disabled,\r\n      readOnly,\r\n      required,\r\n      invalid,\r\n      showSeconds,\r\n      is12Hour,\r\n      minuteStep,\r\n      secondStep,\r\n      hourStep,\r\n      segmentPlaceholder: normalizedPlaceholder,\r\n      min,\r\n      max,\r\n    }),\r\n    [\r\n      rootId,\r\n      inputGroupId,\r\n      labelId,\r\n      triggerId,\r\n      openOnFocus,\r\n      inputGroupClickAction,\r\n      disabled,\r\n      readOnly,\r\n      required,\r\n      invalid,\r\n      showSeconds,\r\n      is12Hour,\r\n      minuteStep,\r\n      secondStep,\r\n      hourStep,\r\n      normalizedPlaceholder,\r\n      min,\r\n      max,\r\n    ],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <>\r\n      <StoreContext.Provider value={store}>\r\n        <TimePickerContext.Provider value={rootContext}>\r\n          <Popover open={storeOpen} onOpenChange={onPopoverOpenChange}>\r\n            <RootPrimitive\r\n              data-slot=\"time-picker\"\r\n              data-disabled={disabled ? \"\" : undefined}\r\n              data-invalid={invalid ? \"\" : undefined}\r\n              {...rootProps}\r\n              className={cn(\"relative\", className)}\r\n            >\r\n              {children}\r\n            </RootPrimitive>\r\n          </Popover>\r\n        </TimePickerContext.Provider>\r\n      </StoreContext.Provider>\r\n      {isFormControl && (\r\n        <VisuallyHiddenInput\r\n          type=\"hidden\"\r\n          control={inputGroup}\r\n          name={name}\r\n          value={value}\r\n          disabled={disabled}\r\n          readOnly={readOnly}\r\n          required={required}\r\n        />\r\n      )}\r\n    </>\r\n  );\r\n}\r\n\r\ninterface TimePickerLabelProps extends React.ComponentProps<\"label\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction TimePickerLabel(props: TimePickerLabelProps) {\r\n  const { asChild, className, ...labelProps } = props;\r\n\r\n  const { labelId } = useTimePickerContext(LABEL_NAME);\r\n\r\n  const LabelPrimitive = asChild ? SlotPrimitive.Slot : \"label\";\r\n\r\n  return (\r\n    <LabelPrimitive\r\n      data-slot=\"time-picker-label\"\r\n      {...labelProps}\r\n      htmlFor={labelId}\r\n      className={cn(\r\n        \"font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface TimePickerInputGroupContextValue {\r\n  onInputRegister: (\r\n    segment: Segment,\r\n    ref: React.RefObject<InputElement | null>,\r\n  ) => void;\r\n  onInputUnregister: (segment: Segment) => void;\r\n  getNextInput: (\r\n    currentSegment: Segment,\r\n  ) => React.RefObject<InputElement | null> | null;\r\n}\r\n\r\nconst TimePickerInputGroupContext =\r\n  React.createContext<TimePickerInputGroupContextValue | null>(null);\r\n\r\nfunction useTimePickerInputGroupContext(consumerName: string) {\r\n  const context = React.useContext(TimePickerInputGroupContext);\r\n  if (!context) {\r\n    throw new Error(\r\n      `\\`${consumerName}\\` must be used within \\`${INPUT_GROUP_NAME}\\``,\r\n    );\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction TimePickerInputGroup(props: DivProps) {\r\n  const {\r\n    onPointerDown: onPointerDownProp,\r\n    onClick: onClickProp,\r\n    asChild,\r\n    className,\r\n    style,\r\n    ref,\r\n    ...inputGroupProps\r\n  } = props;\r\n\r\n  const {\r\n    inputGroupId,\r\n    labelId,\r\n    onInputGroupChange,\r\n    disabled,\r\n    readOnly,\r\n    invalid,\r\n    segmentPlaceholder,\r\n    inputGroupRef,\r\n    triggerRef,\r\n    inputGroupClickAction,\r\n  } = useTimePickerContext(INPUT_GROUP_NAME);\r\n\r\n  const store = useStoreContext(INPUT_GROUP_NAME);\r\n\r\n  const composedRef = useComposedRefs(ref, inputGroupRef, onInputGroupChange);\r\n\r\n  const inputRefsMap = React.useRef<\r\n    Map<Segment, React.RefObject<InputElement | null>>\r\n  >(new Map());\r\n\r\n  const onInputRegister = React.useCallback(\r\n    (segment: Segment, ref: React.RefObject<InputElement | null>) => {\r\n      inputRefsMap.current.set(segment, ref);\r\n    },\r\n    [],\r\n  );\r\n\r\n  const onInputUnregister = React.useCallback((segment: Segment) => {\r\n    inputRefsMap.current.delete(segment);\r\n  }, []);\r\n\r\n  const getNextInput = React.useCallback(\r\n    (currentSegment: Segment): React.RefObject<InputElement | null> | null => {\r\n      const segmentOrder: Segment[] = [\"hour\", \"minute\", \"second\", \"period\"];\r\n      const currentIndex = segmentOrder.indexOf(currentSegment);\r\n\r\n      if (currentIndex === -1 || currentIndex === segmentOrder.length - 1) {\r\n        return null;\r\n      }\r\n\r\n      for (let i = currentIndex + 1; i < segmentOrder.length; i++) {\r\n        const nextSegment = segmentOrder[i];\r\n        if (nextSegment) {\r\n          const nextRef = inputRefsMap.current.get(nextSegment);\r\n          if (nextRef?.current) {\r\n            return nextRef;\r\n          }\r\n        }\r\n      }\r\n\r\n      return null;\r\n    },\r\n    [],\r\n  );\r\n\r\n  const onPointerDown = React.useCallback(\r\n    (event: React.PointerEvent<InputGroupElement>) => {\r\n      onPointerDownProp?.(event);\r\n      if (disabled || readOnly || event.defaultPrevented) return;\r\n\r\n      const target = event.target as HTMLElement;\r\n\r\n      if (target.tagName === \"INPUT\" || target.closest(\"input\")) {\r\n        return;\r\n      }\r\n\r\n      if (triggerRef.current?.contains(target)) {\r\n        return;\r\n      }\r\n\r\n      event.preventDefault();\r\n    },\r\n    [onPointerDownProp, disabled, readOnly, triggerRef],\r\n  );\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<InputGroupElement>) => {\r\n      onClickProp?.(event);\r\n      if (disabled || readOnly || event.defaultPrevented) return;\r\n\r\n      const target = event.target as HTMLElement;\r\n\r\n      if (target.tagName === \"INPUT\" || target.closest(\"input\")) {\r\n        return;\r\n      }\r\n\r\n      if (triggerRef.current?.contains(target)) {\r\n        return;\r\n      }\r\n\r\n      if (inputGroupClickAction === \"open\") {\r\n        store.setState(\"open\", true);\r\n      } else {\r\n        const activeElement = document.activeElement;\r\n        const isInputAlreadyFocused =\r\n          activeElement &&\r\n          activeElement.tagName === \"INPUT\" &&\r\n          inputGroupRef.current?.contains(activeElement);\r\n\r\n        if (!isInputAlreadyFocused) {\r\n          for (const segment of SEGMENTS) {\r\n            const inputRef = inputRefsMap.current.get(segment);\r\n            if (inputRef?.current) {\r\n              inputRef.current.focus();\r\n              inputRef.current.select();\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    },\r\n    [\r\n      onClickProp,\r\n      disabled,\r\n      readOnly,\r\n      inputGroupClickAction,\r\n      store,\r\n      triggerRef,\r\n      inputGroupRef,\r\n    ],\r\n  );\r\n\r\n  const inputGroupContextValue =\r\n    React.useMemo<TimePickerInputGroupContextValue>(\r\n      () => ({\r\n        onInputRegister,\r\n        onInputUnregister,\r\n        getNextInput,\r\n      }),\r\n      [onInputRegister, onInputUnregister, getNextInput],\r\n    );\r\n\r\n  const InputGroupPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <TimePickerInputGroupContext.Provider value={inputGroupContextValue}>\r\n      <PopoverAnchor asChild>\r\n        <InputGroupPrimitive\r\n          role=\"group\"\r\n          id={inputGroupId}\r\n          aria-labelledby={labelId}\r\n          data-slot=\"time-picker-input-group\"\r\n          data-disabled={disabled ? \"\" : undefined}\r\n          data-invalid={invalid ? \"\" : undefined}\r\n          {...inputGroupProps}\r\n          className={cn(\r\n            \"flex h-10 w-full cursor-text items-center gap-0.5 rounded-md border border-input bg-background px-3 py-2 shadow-xs outline-none transition-shadow\",\r\n            \"has-[input:focus]:border-ring has-[input:focus]:ring-[3px] has-[input:focus]:ring-ring/50\",\r\n            invalid && \"border-destructive ring-destructive/20\",\r\n            disabled && \"cursor-not-allowed opacity-50\",\r\n            className,\r\n          )}\r\n          style={\r\n            {\r\n              \"--time-picker-hour-input-width\": `${segmentPlaceholder.hour.length}ch`,\r\n              \"--time-picker-minute-input-width\": `${segmentPlaceholder.minute.length}ch`,\r\n              \"--time-picker-second-input-width\": `${segmentPlaceholder.second.length}ch`,\r\n              \"--time-picker-period-input-width\": `${Math.max(segmentPlaceholder.period.length, 2) + 0.5}ch`,\r\n              ...style,\r\n            } as React.CSSProperties\r\n          }\r\n          ref={composedRef}\r\n          onPointerDown={onPointerDown}\r\n          onClick={onClick}\r\n        />\r\n      </PopoverAnchor>\r\n    </TimePickerInputGroupContext.Provider>\r\n  );\r\n}\r\n\r\ninterface TimePickerInputProps\r\n  extends Omit<React.ComponentProps<\"input\">, \"type\" | \"value\"> {\r\n  segment: Segment;\r\n}\r\n\r\nfunction TimePickerInput(props: TimePickerInputProps) {\r\n  const {\r\n    segment,\r\n    onBlur: onBlurProp,\r\n    onChange: onChangeProp,\r\n    onClick: onClickProp,\r\n    onFocus: onFocusProp,\r\n    onKeyDown: onKeyDownProp,\r\n    disabled: disabledProp,\r\n    readOnly: readOnlyProp,\r\n    className,\r\n    style,\r\n    ref,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const {\r\n    is12Hour,\r\n    showSeconds,\r\n    disabled,\r\n    readOnly,\r\n    segmentPlaceholder,\r\n    openOnFocus,\r\n  } = useTimePickerContext(INPUT_NAME);\r\n  const store = useStoreContext(INPUT_NAME);\r\n  const inputGroupContext = useTimePickerInputGroupContext(INPUT_NAME);\r\n\r\n  const isDisabled = disabledProp || disabled;\r\n  const isReadOnly = readOnlyProp || readOnly;\r\n\r\n  const value = useStore((state) => state.value);\r\n  const timeValue = parseTimeString(value);\r\n\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n  const composedRef = useComposedRefs(ref, inputRef);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (segment) {\r\n      inputGroupContext.onInputRegister(segment as Segment, inputRef);\r\n      return () => inputGroupContext.onInputUnregister(segment as Segment);\r\n    }\r\n  }, [inputGroupContext, segment]);\r\n\r\n  const getSegmentValue = React.useCallback(() => {\r\n    if (!timeValue) {\r\n      if (!segment) return \"\";\r\n      return segmentPlaceholder[segment];\r\n    }\r\n    switch (segment) {\r\n      case \"hour\": {\r\n        if (timeValue.hour === undefined) return segmentPlaceholder.hour;\r\n        if (is12Hour) {\r\n          return to12Hour(timeValue.hour).hour.toString().padStart(2, \"0\");\r\n        }\r\n        return timeValue.hour.toString().padStart(2, \"0\");\r\n      }\r\n      case \"minute\":\r\n        if (timeValue.minute === undefined) return segmentPlaceholder.minute;\r\n        return timeValue.minute.toString().padStart(2, \"0\");\r\n      case \"second\":\r\n        if (timeValue.second === undefined) return segmentPlaceholder.second;\r\n        return timeValue.second.toString().padStart(2, \"0\");\r\n      case \"period\": {\r\n        if (!timeValue || timeValue.hour === undefined)\r\n          return segmentPlaceholder.period;\r\n        return to12Hour(timeValue.hour).period;\r\n      }\r\n      default:\r\n        return \"\";\r\n    }\r\n  }, [timeValue, segment, is12Hour, segmentPlaceholder]);\r\n\r\n  const [editValue, setEditValue] = React.useState(getSegmentValue());\r\n  const [isEditing, setIsEditing] = React.useState(false);\r\n  const [pendingDigit, setPendingDigit] = React.useState<string | null>(null);\r\n\r\n  React.useEffect(() => {\r\n    if (!isEditing) {\r\n      setEditValue(getSegmentValue());\r\n      setPendingDigit(null);\r\n    }\r\n  }, [getSegmentValue, isEditing]);\r\n\r\n  const updateTimeValue = React.useCallback(\r\n    (newSegmentValue: string | undefined, shouldCreateIfEmpty = false) => {\r\n      const placeholder = segment\r\n        ? segmentPlaceholder[segment]\r\n        : DEFAULT_SEGMENT_PLACEHOLDER;\r\n      if (!newSegmentValue || newSegmentValue === placeholder) return;\r\n      if (!timeValue && !shouldCreateIfEmpty) return;\r\n\r\n      const currentTime = timeValue ?? {};\r\n      const newTime = { ...currentTime };\r\n\r\n      switch (segment) {\r\n        case \"hour\": {\r\n          const displayHour = Number.parseInt(newSegmentValue, 10);\r\n          if (!Number.isNaN(displayHour)) {\r\n            if (is12Hour) {\r\n              const clampedHour = clamp(displayHour, 1, 12);\r\n              let currentPeriod: Period;\r\n              if (timeValue?.period !== undefined) {\r\n                currentPeriod = timeValue.period;\r\n              } else if (timeValue?.hour !== undefined) {\r\n                currentPeriod = to12Hour(timeValue.hour).period;\r\n              } else {\r\n                const now = new Date();\r\n                currentPeriod = to12Hour(now.getHours()).period;\r\n              }\r\n              const hour24 = to24Hour(clampedHour, currentPeriod);\r\n              newTime.hour = hour24;\r\n              if (timeValue?.period !== undefined) {\r\n                newTime.period = timeValue.period;\r\n              }\r\n            } else {\r\n              newTime.hour = clamp(displayHour, 0, 23);\r\n            }\r\n          }\r\n          break;\r\n        }\r\n        case \"minute\": {\r\n          const minute = Number.parseInt(newSegmentValue, 10);\r\n          if (!Number.isNaN(minute)) {\r\n            newTime.minute = clamp(minute, 0, 59);\r\n          }\r\n          break;\r\n        }\r\n        case \"second\": {\r\n          const second = Number.parseInt(newSegmentValue, 10);\r\n          if (!Number.isNaN(second)) {\r\n            newTime.second = clamp(second, 0, 59);\r\n          }\r\n          break;\r\n        }\r\n        case \"period\": {\r\n          if (newSegmentValue === \"AM\" || newSegmentValue === \"PM\") {\r\n            newTime.period = newSegmentValue;\r\n            if (timeValue && timeValue.hour !== undefined) {\r\n              const currentDisplay = to12Hour(timeValue.hour);\r\n              newTime.hour = to24Hour(currentDisplay.hour, newSegmentValue);\r\n            }\r\n          }\r\n          break;\r\n        }\r\n      }\r\n\r\n      const newValue = formatTimeValue(newTime, showSeconds);\r\n      store.setState(\"value\", newValue);\r\n    },\r\n    [timeValue, segment, is12Hour, showSeconds, store, segmentPlaceholder],\r\n  );\r\n\r\n  const onBlur = React.useCallback(\r\n    (event: React.FocusEvent<InputElement>) => {\r\n      onBlurProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      setIsEditing(false);\r\n\r\n      const placeholder = segment\r\n        ? segmentPlaceholder[segment]\r\n        : DEFAULT_SEGMENT_PLACEHOLDER;\r\n      if (editValue && editValue !== placeholder && editValue.length > 0) {\r\n        let valueToUpdate = editValue;\r\n\r\n        if (segment !== \"period\") {\r\n          if (editValue.length === 2) {\r\n            valueToUpdate = editValue;\r\n          } else if (editValue.length === 1) {\r\n            const numValue = Number.parseInt(editValue, 10);\r\n            if (!Number.isNaN(numValue)) {\r\n              valueToUpdate = numValue.toString().padStart(2, \"0\");\r\n            }\r\n          }\r\n        }\r\n\r\n        updateTimeValue(valueToUpdate, true);\r\n\r\n        queueMicrotask(() => {\r\n          const currentTimeValue = parseTimeString(store.getState().value);\r\n          if (currentTimeValue) {\r\n            const now = new Date();\r\n            const newTime = { ...currentTimeValue };\r\n            let needsUpdate = false;\r\n\r\n            if (newTime.hour === undefined) {\r\n              newTime.hour = now.getHours();\r\n              needsUpdate = true;\r\n            }\r\n\r\n            if (newTime.minute === undefined) {\r\n              newTime.minute = now.getMinutes();\r\n              needsUpdate = true;\r\n            }\r\n\r\n            if (showSeconds && newTime.second === undefined) {\r\n              newTime.second = now.getSeconds();\r\n              needsUpdate = true;\r\n            }\r\n\r\n            if (needsUpdate) {\r\n              const newValue = formatTimeValue(newTime, showSeconds);\r\n              store.setState(\"value\", newValue);\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      setEditValue(getSegmentValue());\r\n      setPendingDigit(null);\r\n    },\r\n    [\r\n      onBlurProp,\r\n      editValue,\r\n      updateTimeValue,\r\n      getSegmentValue,\r\n      segment,\r\n      segmentPlaceholder,\r\n      showSeconds,\r\n      store,\r\n    ],\r\n  );\r\n\r\n  const onChange = React.useCallback(\r\n    (event: React.ChangeEvent<InputElement>) => {\r\n      onChangeProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      let newValue = event.target.value;\r\n\r\n      const placeholder = segment\r\n        ? segmentPlaceholder[segment]\r\n        : DEFAULT_SEGMENT_PLACEHOLDER;\r\n      if (\r\n        editValue === placeholder &&\r\n        newValue.length > 0 &&\r\n        newValue !== placeholder\r\n      ) {\r\n        newValue = newValue.replace(new RegExp(`^${placeholder}`), \"\");\r\n      }\r\n\r\n      if (segment === \"period\") {\r\n        const firstChar = newValue.charAt(0).toUpperCase();\r\n        let newPeriod: Period | null = null;\r\n\r\n        if (firstChar === \"A\" || firstChar === \"1\") {\r\n          newPeriod = \"AM\";\r\n        } else if (firstChar === \"P\" || firstChar === \"2\") {\r\n          newPeriod = \"PM\";\r\n        }\r\n\r\n        if (newPeriod) {\r\n          setEditValue(newPeriod);\r\n          updateTimeValue(newPeriod, true);\r\n          queueMicrotask(() => {\r\n            inputRef.current?.select();\r\n          });\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (segment === \"hour\" || segment === \"minute\" || segment === \"second\") {\r\n        newValue = newValue.replace(/\\D/g, \"\");\r\n      }\r\n\r\n      if (newValue.length > 2) {\r\n        newValue = newValue.slice(0, 2);\r\n      }\r\n      if (segment === \"hour\" || segment === \"minute\" || segment === \"second\") {\r\n        const numValue = Number.parseInt(newValue, 10);\r\n\r\n        if (!Number.isNaN(numValue) && newValue.length > 0) {\r\n          if (pendingDigit !== null && newValue.length === 1) {\r\n            const twoDigitValue = pendingDigit + newValue;\r\n            const combinedNum = Number.parseInt(twoDigitValue, 10);\r\n\r\n            if (!Number.isNaN(combinedNum)) {\r\n              const paddedValue = combinedNum.toString().padStart(2, \"0\");\r\n              setEditValue(paddedValue);\r\n              updateTimeValue(paddedValue, true);\r\n              setPendingDigit(null);\r\n\r\n              queueMicrotask(() => {\r\n                if (segment) {\r\n                  const nextInputRef = inputGroupContext.getNextInput(segment);\r\n                  if (nextInputRef?.current) {\r\n                    nextInputRef.current.focus();\r\n                    nextInputRef.current.select();\r\n                  }\r\n                }\r\n              });\r\n              return;\r\n            }\r\n          }\r\n\r\n          const maxFirstDigit = segment === \"hour\" ? (is12Hour ? 1 : 2) : 5;\r\n\r\n          const firstDigit = Number.parseInt(newValue[0] ?? \"0\", 10);\r\n          const shouldAutoAdvance = firstDigit > maxFirstDigit;\r\n\r\n          if (newValue.length === 1) {\r\n            if (shouldAutoAdvance) {\r\n              const paddedValue = numValue.toString().padStart(2, \"0\");\r\n              setEditValue(paddedValue);\r\n              updateTimeValue(paddedValue, true);\r\n              setPendingDigit(null);\r\n\r\n              queueMicrotask(() => {\r\n                if (segment) {\r\n                  const nextInputRef = inputGroupContext.getNextInput(segment);\r\n                  if (nextInputRef?.current) {\r\n                    nextInputRef.current.focus();\r\n                    nextInputRef.current.select();\r\n                  }\r\n                }\r\n              });\r\n            } else {\r\n              const paddedValue = numValue.toString().padStart(2, \"0\");\r\n              setEditValue(paddedValue);\r\n              setPendingDigit(newValue);\r\n              queueMicrotask(() => {\r\n                inputRef.current?.select();\r\n              });\r\n            }\r\n          } else if (newValue.length === 2) {\r\n            const paddedValue = numValue.toString().padStart(2, \"0\");\r\n            setEditValue(paddedValue);\r\n            updateTimeValue(paddedValue, true);\r\n            setPendingDigit(null);\r\n\r\n            queueMicrotask(() => {\r\n              if (segment) {\r\n                const nextInputRef = inputGroupContext.getNextInput(segment);\r\n                if (nextInputRef?.current) {\r\n                  nextInputRef.current.focus();\r\n                  nextInputRef.current.select();\r\n                }\r\n              }\r\n            });\r\n          }\r\n        } else if (newValue.length === 0) {\r\n          setEditValue(\"\");\r\n          setPendingDigit(null);\r\n        }\r\n      }\r\n    },\r\n    [\r\n      segment,\r\n      updateTimeValue,\r\n      onChangeProp,\r\n      editValue,\r\n      is12Hour,\r\n      inputGroupContext,\r\n      pendingDigit,\r\n      segmentPlaceholder,\r\n    ],\r\n  );\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<InputElement>) => {\r\n      onClickProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      event.currentTarget.select();\r\n    },\r\n    [onClickProp],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<InputElement>) => {\r\n      onFocusProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      setIsEditing(true);\r\n      setPendingDigit(null);\r\n\r\n      if (openOnFocus && !store.getState().open) {\r\n        store.setState(\"openedViaFocus\", true);\r\n        store.setState(\"open\", true);\r\n      }\r\n\r\n      queueMicrotask(() => event.target.select());\r\n    },\r\n    [onFocusProp, openOnFocus, store],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<InputElement>) => {\r\n      onKeyDownProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (event.key === \"ArrowLeft\" || event.key === \"ArrowRight\") {\r\n        event.preventDefault();\r\n\r\n        const goToPrevious = event.key === \"ArrowLeft\";\r\n        const inputGroup = inputRef.current?.closest(\r\n          '[data-slot=\"time-picker-input-group\"]',\r\n        );\r\n\r\n        if (inputGroup && inputRef.current) {\r\n          const allInputs = Array.from(\r\n            inputGroup.querySelectorAll('input[type=\"text\"]'),\r\n          ) as HTMLInputElement[];\r\n          const currentIdx = allInputs.indexOf(inputRef.current);\r\n\r\n          if (currentIdx !== -1) {\r\n            const targetIdx = goToPrevious\r\n              ? Math.max(0, currentIdx - 1)\r\n              : Math.min(allInputs.length - 1, currentIdx + 1);\r\n\r\n            const targetInput = allInputs[targetIdx];\r\n            if (targetInput && targetInput !== inputRef.current) {\r\n              targetInput.focus();\r\n              targetInput.select();\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (event.key === \"Backspace\" || event.key === \"Delete\") {\r\n        const input = inputRef.current;\r\n        if (\r\n          input &&\r\n          input.selectionStart === 0 &&\r\n          input.selectionEnd === input.value.length\r\n        ) {\r\n          event.preventDefault();\r\n          const placeholder = segment\r\n            ? segmentPlaceholder[segment]\r\n            : DEFAULT_SEGMENT_PLACEHOLDER;\r\n          setEditValue(placeholder);\r\n          setPendingDigit(null);\r\n\r\n          if (timeValue) {\r\n            const newTime = { ...timeValue };\r\n            switch (segment) {\r\n              case \"hour\":\r\n                delete newTime.hour;\r\n                break;\r\n              case \"minute\":\r\n                delete newTime.minute;\r\n                break;\r\n              case \"second\":\r\n                delete newTime.second;\r\n                break;\r\n              case \"period\":\r\n                delete newTime.period;\r\n                break;\r\n            }\r\n\r\n            if (\r\n              newTime.hour !== undefined ||\r\n              newTime.minute !== undefined ||\r\n              newTime.second !== undefined ||\r\n              newTime.period !== undefined\r\n            ) {\r\n              const newValue = formatTimeValue(newTime, showSeconds);\r\n              store.setState(\"value\", newValue);\r\n            } else {\r\n              store.setState(\"value\", \"\");\r\n            }\r\n          } else {\r\n            store.setState(\"value\", \"\");\r\n          }\r\n\r\n          queueMicrotask(() => {\r\n            inputRef.current?.select();\r\n          });\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (segment === \"period\") {\r\n        const key = event.key.toLowerCase();\r\n        if (key === \"a\" || key === \"p\" || key === \"1\" || key === \"2\") {\r\n          event.preventDefault();\r\n          let newPeriod: Period;\r\n          if (key === \"a\" || key === \"1\") {\r\n            newPeriod = \"AM\";\r\n          } else {\r\n            newPeriod = \"PM\";\r\n          }\r\n          setEditValue(newPeriod);\r\n          updateTimeValue(newPeriod, true);\r\n          queueMicrotask(() => {\r\n            inputRef.current?.select();\r\n          });\r\n        } else if (event.key === \"ArrowUp\" || event.key === \"ArrowDown\") {\r\n          event.preventDefault();\r\n          const placeholder = segmentPlaceholder.period;\r\n          const currentPeriod =\r\n            editValue === placeholder || editValue === \"\" ? \"AM\" : editValue;\r\n          const newPeriod =\r\n            currentPeriod === \"AM\" || currentPeriod === \"A\" ? \"PM\" : \"AM\";\r\n          setEditValue(newPeriod);\r\n          updateTimeValue(newPeriod, true);\r\n          queueMicrotask(() => {\r\n            inputRef.current?.select();\r\n          });\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (event.key === \"Tab\") {\r\n        const placeholder = segment\r\n          ? segmentPlaceholder[segment]\r\n          : DEFAULT_SEGMENT_PLACEHOLDER;\r\n        if (editValue && editValue.length > 0 && editValue !== placeholder) {\r\n          if (editValue.length === 2) {\r\n            updateTimeValue(editValue, true);\r\n          } else if (editValue.length === 1) {\r\n            const numValue = Number.parseInt(editValue, 10);\r\n            if (!Number.isNaN(numValue)) {\r\n              const paddedValue = numValue.toString().padStart(2, \"0\");\r\n              updateTimeValue(paddedValue, true);\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (event.key === \"Enter\") {\r\n        event.preventDefault();\r\n        const placeholder = segment\r\n          ? segmentPlaceholder[segment]\r\n          : DEFAULT_SEGMENT_PLACEHOLDER;\r\n        if (editValue && editValue.length > 0 && editValue !== placeholder) {\r\n          if (editValue.length === 2) {\r\n            updateTimeValue(editValue, true);\r\n          } else if (editValue.length === 1) {\r\n            const numValue = Number.parseInt(editValue, 10);\r\n            if (!Number.isNaN(numValue)) {\r\n              const paddedValue = numValue.toString().padStart(2, \"0\");\r\n              updateTimeValue(paddedValue, true);\r\n            }\r\n          }\r\n        }\r\n        queueMicrotask(() => {\r\n          inputRef.current?.select();\r\n        });\r\n      }\r\n\r\n      if (event.key === \"Escape\") {\r\n        event.preventDefault();\r\n        setEditValue(getSegmentValue());\r\n        inputRef.current?.blur();\r\n      }\r\n\r\n      if (event.key === \"ArrowUp\") {\r\n        event.preventDefault();\r\n        const placeholder = segment\r\n          ? segmentPlaceholder[segment]\r\n          : DEFAULT_SEGMENT_PLACEHOLDER;\r\n        if (editValue === placeholder || editValue === \"\") {\r\n          const defaultValue = segment === \"hour\" ? (is12Hour ? 12 : 0) : 0;\r\n          const formattedValue = defaultValue.toString().padStart(2, \"0\");\r\n          setEditValue(formattedValue);\r\n          updateTimeValue(formattedValue, true);\r\n          queueMicrotask(() => {\r\n            inputRef.current?.select();\r\n          });\r\n          return;\r\n        }\r\n        const currentValue = Number.parseInt(editValue, 10);\r\n        if (!Number.isNaN(currentValue)) {\r\n          let newValue: number;\r\n          switch (segment) {\r\n            case \"hour\":\r\n              if (is12Hour) {\r\n                newValue = currentValue === 12 ? 1 : currentValue + 1;\r\n              } else {\r\n                newValue = currentValue === 23 ? 0 : currentValue + 1;\r\n              }\r\n              break;\r\n            case \"minute\":\r\n            case \"second\":\r\n              newValue = currentValue === 59 ? 0 : currentValue + 1;\r\n              break;\r\n            default:\r\n              return;\r\n          }\r\n          const formattedValue = newValue.toString().padStart(2, \"0\");\r\n          setEditValue(formattedValue);\r\n          updateTimeValue(formattedValue, true);\r\n          queueMicrotask(() => {\r\n            inputRef.current?.select();\r\n          });\r\n        }\r\n      }\r\n\r\n      if (event.key === \"ArrowDown\") {\r\n        event.preventDefault();\r\n        const placeholder = segment\r\n          ? segmentPlaceholder[segment]\r\n          : DEFAULT_SEGMENT_PLACEHOLDER;\r\n        if (editValue === placeholder || editValue === \"\") {\r\n          const defaultValue = segment === \"hour\" ? (is12Hour ? 12 : 23) : 59;\r\n          const formattedValue = defaultValue.toString().padStart(2, \"0\");\r\n          setEditValue(formattedValue);\r\n          updateTimeValue(formattedValue, true);\r\n          queueMicrotask(() => {\r\n            inputRef.current?.select();\r\n          });\r\n          return;\r\n        }\r\n        const currentValue = Number.parseInt(editValue, 10);\r\n        if (!Number.isNaN(currentValue)) {\r\n          let newValue: number;\r\n          switch (segment) {\r\n            case \"hour\":\r\n              if (is12Hour) {\r\n                newValue = currentValue === 1 ? 12 : currentValue - 1;\r\n              } else {\r\n                newValue = currentValue === 0 ? 23 : currentValue - 1;\r\n              }\r\n              break;\r\n            case \"minute\":\r\n            case \"second\":\r\n              newValue = currentValue === 0 ? 59 : currentValue - 1;\r\n              break;\r\n            default:\r\n              return;\r\n          }\r\n          const formattedValue = newValue.toString().padStart(2, \"0\");\r\n          setEditValue(formattedValue);\r\n          updateTimeValue(formattedValue, true);\r\n          queueMicrotask(() => {\r\n            inputRef.current?.select();\r\n          });\r\n        }\r\n      }\r\n    },\r\n    [\r\n      onKeyDownProp,\r\n      editValue,\r\n      segment,\r\n      is12Hour,\r\n      getSegmentValue,\r\n      updateTimeValue,\r\n      showSeconds,\r\n      timeValue,\r\n      store,\r\n      segmentPlaceholder,\r\n    ],\r\n  );\r\n\r\n  const displayValue = isEditing ? editValue : getSegmentValue();\r\n\r\n  const segmentWidth = segment\r\n    ? `var(--time-picker-${segment}-input-width)`\r\n    : \"2ch\";\r\n\r\n  return (\r\n    <input\r\n      type=\"text\"\r\n      inputMode={segment === \"period\" ? \"text\" : \"numeric\"}\r\n      autoComplete=\"off\"\r\n      autoCorrect=\"off\"\r\n      autoCapitalize=\"off\"\r\n      spellCheck={false}\r\n      translate=\"no\"\r\n      {...inputProps}\r\n      disabled={isDisabled}\r\n      readOnly={isReadOnly}\r\n      className={cn(\r\n        \"inline-flex h-full items-center justify-center border-0 bg-transparent text-center text-sm tabular-nums outline-none transition-colors focus:bg-transparent disabled:cursor-not-allowed disabled:opacity-50\",\r\n        className,\r\n      )}\r\n      style={{ width: segmentWidth, ...style }}\r\n      ref={composedRef}\r\n      value={displayValue}\r\n      onBlur={onBlur}\r\n      onChange={onChange}\r\n      onClick={onClick}\r\n      onFocus={onFocus}\r\n      onKeyDown={onKeyDown}\r\n    />\r\n  );\r\n}\r\n\r\nfunction TimePickerTrigger(props: ButtonProps) {\r\n  const {\r\n    className,\r\n    children,\r\n    disabled: disabledProp,\r\n    ref,\r\n    ...triggerProps\r\n  } = props;\r\n\r\n  const { triggerId, disabled, triggerRef } =\r\n    useTimePickerContext(TRIGGER_NAME);\r\n\r\n  const isDisabled = disabledProp || disabled;\r\n\r\n  const composedRef = useComposedRefs(ref, triggerRef);\r\n\r\n  return (\r\n    <PopoverTrigger\r\n      type=\"button\"\r\n      id={triggerId}\r\n      data-slot=\"time-picker-trigger\"\r\n      disabled={isDisabled}\r\n      ref={composedRef}\r\n      {...triggerProps}\r\n      className={cn(\r\n        \"ml-auto flex items-center text-muted-foreground transition-colors hover:text-foreground disabled:pointer-events-none [&>svg:not([class*='size-'])]:size-4\",\r\n        className,\r\n      )}\r\n    >\r\n      {children ?? <Clock />}\r\n    </PopoverTrigger>\r\n  );\r\n}\r\n\r\ninterface TimePickerGroupContextValue {\r\n  getColumns: () => ColumnData[];\r\n  onColumnRegister: (column: ColumnData) => void;\r\n  onColumnUnregister: (id: string) => void;\r\n}\r\n\r\nconst TimePickerGroupContext =\r\n  React.createContext<TimePickerGroupContextValue | null>(null);\r\n\r\nfunction useTimePickerGroupContext(consumerName: string) {\r\n  const context = React.useContext(TimePickerGroupContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface TimePickerContentProps\r\n  extends DivProps,\r\n    React.ComponentProps<typeof PopoverContent> {}\r\n\r\nfunction TimePickerContent(props: TimePickerContentProps) {\r\n  const {\r\n    side = \"bottom\",\r\n    align = \"start\",\r\n    sideOffset = 6,\r\n    className,\r\n    onOpenAutoFocus: onOpenAutoFocusProp,\r\n    onInteractOutside: onInteractOutsideProp,\r\n    ...contentProps\r\n  } = props;\r\n\r\n  const store = useStoreContext(CONTENT_NAME);\r\n  const { openOnFocus, inputGroupRef } = useTimePickerContext(CONTENT_NAME);\r\n  const columnsRef = React.useRef<Map<string, Omit<ColumnData, \"id\">>>(\r\n    new Map(),\r\n  );\r\n\r\n  const onColumnRegister = React.useCallback((column: ColumnData) => {\r\n    columnsRef.current.set(column.id, column);\r\n  }, []);\r\n\r\n  const onColumnUnregister = React.useCallback((id: string) => {\r\n    columnsRef.current.delete(id);\r\n  }, []);\r\n\r\n  const getColumns = React.useCallback(() => {\r\n    const columns = Array.from(columnsRef.current.entries())\r\n      .map(([id, { ref, getSelectedItemRef, getItems }]) => ({\r\n        id,\r\n        ref,\r\n        getSelectedItemRef,\r\n        getItems,\r\n      }))\r\n      .filter((c) => c.ref.current !== null);\r\n    return sortNodes(columns);\r\n  }, []);\r\n\r\n  const groupContextValue = React.useMemo<TimePickerGroupContextValue>(\r\n    () => ({\r\n      getColumns,\r\n      onColumnRegister,\r\n      onColumnUnregister,\r\n    }),\r\n    [getColumns, onColumnRegister, onColumnUnregister],\r\n  );\r\n\r\n  const onOpenAutoFocus: NonNullable<PopoverContentProps[\"onOpenAutoFocus\"]> =\r\n    React.useCallback(\r\n      (event) => {\r\n        onOpenAutoFocusProp?.(event);\r\n        if (event.defaultPrevented) return;\r\n\r\n        event.preventDefault();\r\n\r\n        const { openedViaFocus } = store.getState();\r\n\r\n        if (openedViaFocus) {\r\n          store.setState(\"openedViaFocus\", false);\r\n          return;\r\n        }\r\n\r\n        const columns = getColumns();\r\n        const firstColumn = columns[0];\r\n\r\n        if (!firstColumn) return;\r\n\r\n        const items = firstColumn.getItems();\r\n        const selectedItem = items.find((item) => item.selected);\r\n\r\n        const candidateRefs = selectedItem\r\n          ? [selectedItem.ref, ...items.map((item) => item.ref)]\r\n          : items.map((item) => item.ref);\r\n\r\n        focusFirst(candidateRefs, false);\r\n      },\r\n      [onOpenAutoFocusProp, getColumns, store],\r\n    );\r\n\r\n  const onInteractOutside: NonNullable<\r\n    PopoverContentProps[\"onInteractOutside\"]\r\n  > = React.useCallback(\r\n    (event) => {\r\n      onInteractOutsideProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (openOnFocus && inputGroupRef.current) {\r\n        const target = event.target;\r\n        if (!(target instanceof Node)) return;\r\n        const isInsideInputGroup = inputGroupRef.current.contains(target);\r\n\r\n        if (isInsideInputGroup) {\r\n          event.preventDefault();\r\n        }\r\n      }\r\n    },\r\n    [onInteractOutsideProp, openOnFocus, inputGroupRef],\r\n  );\r\n\r\n  return (\r\n    <TimePickerGroupContext.Provider value={groupContextValue}>\r\n      <PopoverContent\r\n        data-slot=\"time-picker-content\"\r\n        side={side}\r\n        align={align}\r\n        sideOffset={sideOffset}\r\n        {...contentProps}\r\n        className={cn(\r\n          \"flex w-auto max-w-(--radix-popover-trigger-width) p-0\",\r\n          className,\r\n        )}\r\n        onOpenAutoFocus={onOpenAutoFocus}\r\n        onInteractOutside={onInteractOutside}\r\n      />\r\n    </TimePickerGroupContext.Provider>\r\n  );\r\n}\r\n\r\ninterface TimePickerColumnContextValue {\r\n  getItems: () => ItemData[];\r\n  onItemRegister: (\r\n    value: number | string,\r\n    ref: React.RefObject<ColumnItemElement | null>,\r\n    selected: boolean,\r\n  ) => void;\r\n  onItemUnregister: (value: number | string) => void;\r\n}\r\n\r\nconst TimePickerColumnContext =\r\n  React.createContext<TimePickerColumnContextValue | null>(null);\r\n\r\nfunction useTimePickerColumnContext(consumerName: string) {\r\n  const context = React.useContext(TimePickerColumnContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within a column`);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface TimePickerColumnProps extends DivProps {}\r\n\r\nfunction TimePickerColumn(props: TimePickerColumnProps) {\r\n  const { children, className, ref, ...columnProps } = props;\r\n\r\n  const columnId = React.useId();\r\n  const columnRef = React.useRef<ColumnElement | null>(null);\r\n  const composedRef = useComposedRefs(ref, columnRef);\r\n\r\n  const itemsRef = React.useRef<\r\n    Map<\r\n      number | string,\r\n      {\r\n        ref: React.RefObject<ColumnItemElement | null>;\r\n        selected: boolean;\r\n      }\r\n    >\r\n  >(new Map());\r\n\r\n  const groupContext = useTimePickerGroupContext(COLUMN_NAME);\r\n\r\n  const onItemRegister = React.useCallback(\r\n    (\r\n      value: number | string,\r\n      ref: React.RefObject<HTMLButtonElement | null>,\r\n      selected: boolean,\r\n    ) => {\r\n      itemsRef.current.set(value, { ref, selected });\r\n    },\r\n    [],\r\n  );\r\n\r\n  const onItemUnregister = React.useCallback((value: number | string) => {\r\n    itemsRef.current.delete(value);\r\n  }, []);\r\n\r\n  const getItems = React.useCallback(() => {\r\n    const items = Array.from(itemsRef.current.entries())\r\n      .map(([value, { ref, selected }]) => ({\r\n        value,\r\n        ref,\r\n        selected,\r\n      }))\r\n      .filter((item) => item.ref.current);\r\n    return sortNodes(items);\r\n  }, []);\r\n\r\n  const getSelectedItemRef = React.useCallback(() => {\r\n    const items = getItems();\r\n    return items.find((item) => item.selected)?.ref ?? null;\r\n  }, [getItems]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    groupContext.onColumnRegister({\r\n      id: columnId,\r\n      ref: columnRef,\r\n      getSelectedItemRef,\r\n      getItems,\r\n    });\r\n    return () => groupContext.onColumnUnregister(columnId);\r\n  }, [groupContext, columnId, getSelectedItemRef, getItems]);\r\n\r\n  const columnContextValue = React.useMemo<TimePickerColumnContextValue>(\r\n    () => ({\r\n      getItems,\r\n      onItemRegister,\r\n      onItemUnregister,\r\n    }),\r\n    [getItems, onItemRegister, onItemUnregister],\r\n  );\r\n\r\n  return (\r\n    <TimePickerColumnContext.Provider value={columnContextValue}>\r\n      <div\r\n        ref={composedRef}\r\n        data-slot=\"time-picker-column\"\r\n        {...columnProps}\r\n        className={cn(\"flex flex-col gap-1 not-last:border-r p-1\", className)}\r\n      >\r\n        {children}\r\n      </div>\r\n    </TimePickerColumnContext.Provider>\r\n  );\r\n}\r\n\r\ninterface TimePickerColumnItemProps extends ButtonProps {\r\n  value: number | string;\r\n  selected?: boolean;\r\n  format?: SegmentFormat;\r\n}\r\n\r\nfunction TimePickerColumnItem(props: TimePickerColumnItemProps) {\r\n  const {\r\n    value,\r\n    selected = false,\r\n    format = \"numeric\",\r\n    className,\r\n    ref,\r\n    ...itemProps\r\n  } = props;\r\n\r\n  const itemRef = React.useRef<ColumnItemElement | null>(null);\r\n  const composedRef = useComposedRefs(ref, itemRef);\r\n  const columnContext = useTimePickerColumnContext(COLUMN_ITEM_NAME);\r\n  const groupContext = useTimePickerGroupContext(COLUMN_ITEM_NAME);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    columnContext.onItemRegister(value, itemRef, selected);\r\n    return () => columnContext.onItemUnregister(value);\r\n  }, [columnContext, value, selected]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (selected && itemRef.current) {\r\n      itemRef.current.scrollIntoView({ block: \"nearest\" });\r\n    }\r\n  }, [selected]);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<ColumnItemElement>) => {\r\n      itemProps.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      itemRef.current?.focus();\r\n    },\r\n    [itemProps.onClick],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<ColumnItemElement>) => {\r\n      itemProps.onKeyDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (event.key === \"ArrowUp\" || event.key === \"ArrowDown\") {\r\n        event.preventDefault();\r\n        const items = columnContext.getItems().sort((a, b) => {\r\n          if (typeof a.value === \"number\" && typeof b.value === \"number\") {\r\n            return a.value - b.value;\r\n          }\r\n          return 0;\r\n        });\r\n        const currentIndex = items.findIndex((item) => item.value === value);\r\n\r\n        let nextIndex: number;\r\n        if (event.key === \"ArrowUp\") {\r\n          nextIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;\r\n        } else {\r\n          nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;\r\n        }\r\n\r\n        const nextItem = items[nextIndex];\r\n        nextItem?.ref.current?.focus();\r\n        nextItem?.ref.current?.click();\r\n      } else if (\r\n        (event.key === \"Tab\" ||\r\n          event.key === \"ArrowLeft\" ||\r\n          event.key === \"ArrowRight\") &&\r\n        groupContext\r\n      ) {\r\n        event.preventDefault();\r\n\r\n        queueMicrotask(() => {\r\n          const columns = groupContext.getColumns();\r\n\r\n          if (columns.length === 0) return;\r\n\r\n          const currentColumnIndex = columns.findIndex(\r\n            (c) => c.ref.current?.contains(itemRef.current) ?? false,\r\n          );\r\n\r\n          if (currentColumnIndex === -1) return;\r\n\r\n          const goToPrevious =\r\n            event.key === \"ArrowLeft\" ||\r\n            (event.key === \"Tab\" && event.shiftKey);\r\n\r\n          const nextColumnIndex = goToPrevious\r\n            ? currentColumnIndex > 0\r\n              ? currentColumnIndex - 1\r\n              : columns.length - 1\r\n            : currentColumnIndex < columns.length - 1\r\n              ? currentColumnIndex + 1\r\n              : 0;\r\n\r\n          const nextColumn = columns[nextColumnIndex];\r\n          if (nextColumn?.ref.current) {\r\n            const items = nextColumn.getItems();\r\n            const selectedItem = items.find((item) => item.selected);\r\n\r\n            const candidateRefs = selectedItem\r\n              ? [selectedItem.ref, ...items.map((item) => item.ref)]\r\n              : items.map((item) => item.ref);\r\n\r\n            focusFirst(candidateRefs, false);\r\n          }\r\n        });\r\n      }\r\n    },\r\n    [itemProps.onKeyDown, columnContext, groupContext, value],\r\n  );\r\n\r\n  const formattedValue =\r\n    typeof value === \"number\" && format === \"2-digit\"\r\n      ? value.toString().padStart(2, \"0\")\r\n      : value.toString();\r\n\r\n  return (\r\n    <button\r\n      type=\"button\"\r\n      {...itemProps}\r\n      ref={composedRef}\r\n      data-selected={selected ? \"\" : undefined}\r\n      className={cn(\r\n        \"w-full rounded px-3 py-1.5 text-left text-sm hover:bg-accent hover:text-accent-foreground focus:border-ring focus:outline-none focus:ring-[3px] focus:ring-ring/50\",\r\n        \"data-selected:bg-primary data-selected:text-primary-foreground data-selected:hover:bg-primary data-selected:hover:text-primary-foreground\",\r\n        className,\r\n      )}\r\n      onClick={onClick}\r\n      onKeyDown={onKeyDown}\r\n    >\r\n      {formattedValue}\r\n    </button>\r\n  );\r\n}\r\n\r\ninterface TimePickerHourProps extends DivProps {\r\n  format?: SegmentFormat;\r\n}\r\n\r\nfunction TimePickerHour(props: TimePickerHourProps) {\r\n  const { asChild, format = \"numeric\", className, ...hourProps } = props;\r\n\r\n  const { is12Hour, hourStep, showSeconds } = useTimePickerContext(HOUR_NAME);\r\n  const store = useStoreContext(HOUR_NAME);\r\n\r\n  const value = useStore((state) => state.value);\r\n  const timeValue = parseTimeString(value);\r\n\r\n  const hours = Array.from(\r\n    {\r\n      length: is12Hour ? Math.ceil(12 / hourStep) : Math.ceil(24 / hourStep),\r\n    },\r\n    (_, i) => {\r\n      if (is12Hour) {\r\n        const hour = (i * hourStep) % 12;\r\n        return hour === 0 ? 12 : hour;\r\n      }\r\n      return i * hourStep;\r\n    },\r\n  );\r\n\r\n  const onHourSelect = React.useCallback(\r\n    (displayHour: number) => {\r\n      const now = new Date();\r\n      const currentTime = timeValue ?? {};\r\n\r\n      let hour24 = displayHour;\r\n      if (is12Hour) {\r\n        let currentPeriod: Period;\r\n        if (timeValue?.period !== undefined) {\r\n          currentPeriod = timeValue.period;\r\n        } else if (timeValue?.hour !== undefined) {\r\n          currentPeriod = to12Hour(timeValue.hour).period;\r\n        } else {\r\n          currentPeriod = to12Hour(now.getHours()).period;\r\n        }\r\n        hour24 = to24Hour(displayHour, currentPeriod);\r\n      }\r\n\r\n      const newTime = { ...currentTime, hour: hour24 };\r\n      if (timeValue && timeValue.period !== undefined) {\r\n        newTime.period = timeValue.period;\r\n      }\r\n\r\n      if (newTime.minute === undefined) {\r\n        newTime.minute = now.getMinutes();\r\n      }\r\n\r\n      if (showSeconds && newTime.second === undefined) {\r\n        newTime.second = now.getSeconds();\r\n      }\r\n\r\n      const newValue = formatTimeValue(newTime, showSeconds);\r\n      store.setState(\"value\", newValue);\r\n    },\r\n    [timeValue, showSeconds, is12Hour, store],\r\n  );\r\n\r\n  const now = new Date();\r\n  const referenceHour = timeValue?.hour ?? now.getHours();\r\n  const displayHour = is12Hour ? to12Hour(referenceHour).hour : referenceHour;\r\n\r\n  const HourPrimitive = asChild ? SlotPrimitive.Slot : TimePickerColumn;\r\n\r\n  return (\r\n    <HourPrimitive\r\n      data-slot=\"time-picker-hour\"\r\n      {...hourProps}\r\n      className={cn(\r\n        \"scrollbar-none flex max-h-[200px] flex-col gap-1 overflow-y-auto p-1\",\r\n        className,\r\n      )}\r\n    >\r\n      {hours.map((hour) => (\r\n        <TimePickerColumnItem\r\n          key={hour}\r\n          value={hour}\r\n          selected={displayHour === hour}\r\n          format={format}\r\n          onClick={() => onHourSelect(hour)}\r\n        />\r\n      ))}\r\n    </HourPrimitive>\r\n  );\r\n}\r\n\r\ninterface TimePickerMinuteProps extends DivProps {\r\n  format?: SegmentFormat;\r\n}\r\n\r\nfunction TimePickerMinute(props: TimePickerMinuteProps) {\r\n  const { asChild, format = \"2-digit\", className, ...minuteProps } = props;\r\n\r\n  const { minuteStep, showSeconds } = useTimePickerContext(MINUTE_NAME);\r\n  const store = useStoreContext(MINUTE_NAME);\r\n\r\n  const value = useStore((state) => state.value);\r\n  const timeValue = parseTimeString(value);\r\n\r\n  const minutes = Array.from(\r\n    { length: Math.ceil(60 / minuteStep) },\r\n    (_, i) => i * minuteStep,\r\n  );\r\n\r\n  const onMinuteSelect = React.useCallback(\r\n    (minute: number) => {\r\n      const now = new Date();\r\n      const currentTime = timeValue ?? {};\r\n      const newTime = { ...currentTime, minute };\r\n\r\n      if (newTime.hour === undefined) {\r\n        newTime.hour = now.getHours();\r\n      }\r\n\r\n      if (showSeconds && newTime.second === undefined) {\r\n        newTime.second = now.getSeconds();\r\n      }\r\n\r\n      const newValue = formatTimeValue(newTime, showSeconds);\r\n      store.setState(\"value\", newValue);\r\n    },\r\n    [timeValue, showSeconds, store],\r\n  );\r\n\r\n  const MinutePrimitive = asChild ? SlotPrimitive.Slot : TimePickerColumn;\r\n\r\n  const now = new Date();\r\n  const referenceMinute = timeValue?.minute ?? now.getMinutes();\r\n\r\n  return (\r\n    <MinutePrimitive\r\n      data-slot=\"time-picker-minute\"\r\n      {...minuteProps}\r\n      className={cn(\r\n        \"scrollbar-none flex max-h-[200px] flex-col gap-1 overflow-y-auto p-1\",\r\n        className,\r\n      )}\r\n    >\r\n      {minutes.map((minute) => (\r\n        <TimePickerColumnItem\r\n          key={minute}\r\n          value={minute}\r\n          selected={referenceMinute === minute}\r\n          format={format}\r\n          onClick={() => onMinuteSelect(minute)}\r\n        />\r\n      ))}\r\n    </MinutePrimitive>\r\n  );\r\n}\r\n\r\ninterface TimePickerSecondProps extends DivProps {\r\n  format?: SegmentFormat;\r\n}\r\n\r\nfunction TimePickerSecond(props: TimePickerSecondProps) {\r\n  const { asChild, format = \"2-digit\", className, ...secondProps } = props;\r\n\r\n  const { secondStep } = useTimePickerContext(SECOND_NAME);\r\n  const store = useStoreContext(SECOND_NAME);\r\n\r\n  const value = useStore((state) => state.value);\r\n  const timeValue = parseTimeString(value);\r\n\r\n  const seconds = Array.from(\r\n    { length: Math.ceil(60 / secondStep) },\r\n    (_, i) => i * secondStep,\r\n  );\r\n\r\n  const onSecondSelect = React.useCallback(\r\n    (second: number) => {\r\n      const now = new Date();\r\n      const currentTime = timeValue ?? {};\r\n      const newTime = { ...currentTime, second };\r\n\r\n      if (newTime.hour === undefined) {\r\n        newTime.hour = now.getHours();\r\n      }\r\n\r\n      if (newTime.minute === undefined) {\r\n        newTime.minute = now.getMinutes();\r\n      }\r\n\r\n      const newValue = formatTimeValue(newTime, true);\r\n      store.setState(\"value\", newValue);\r\n    },\r\n    [timeValue, store],\r\n  );\r\n\r\n  const SecondPrimitive = asChild ? SlotPrimitive.Slot : TimePickerColumn;\r\n\r\n  const now = new Date();\r\n  const referenceSecond = timeValue?.second ?? now.getSeconds();\r\n\r\n  return (\r\n    <SecondPrimitive\r\n      data-slot=\"time-picker-second\"\r\n      {...secondProps}\r\n      className={cn(\r\n        \"scrollbar-none flex max-h-[200px] flex-col gap-1 overflow-y-auto p-1\",\r\n        className,\r\n      )}\r\n    >\r\n      {seconds.map((second) => (\r\n        <TimePickerColumnItem\r\n          key={second}\r\n          value={second}\r\n          selected={referenceSecond === second}\r\n          format={format}\r\n          onClick={() => onSecondSelect(second)}\r\n        />\r\n      ))}\r\n    </SecondPrimitive>\r\n  );\r\n}\r\n\r\nfunction TimePickerPeriod(props: DivProps) {\r\n  const { asChild, className, ...periodProps } = props;\r\n\r\n  const { is12Hour, showSeconds } = useTimePickerContext(PERIOD_NAME);\r\n  const store = useStoreContext(PERIOD_NAME);\r\n\r\n  const value = useStore((state) => state.value);\r\n  const timeValue = parseTimeString(value);\r\n\r\n  const onPeriodToggle = React.useCallback(\r\n    (period: Period) => {\r\n      const now = new Date();\r\n      const currentTime = timeValue ?? {};\r\n\r\n      const currentHour =\r\n        currentTime.hour !== undefined ? currentTime.hour : now.getHours();\r\n      const currentDisplay = to12Hour(currentHour);\r\n      const new24Hour = to24Hour(currentDisplay.hour, period);\r\n\r\n      const newTime = { ...currentTime, hour: new24Hour };\r\n\r\n      if (newTime.minute === undefined) {\r\n        newTime.minute = now.getMinutes();\r\n      }\r\n\r\n      if (showSeconds && newTime.second === undefined) {\r\n        newTime.second = now.getSeconds();\r\n      }\r\n\r\n      const newValue = formatTimeValue(newTime, showSeconds);\r\n      store.setState(\"value\", newValue);\r\n    },\r\n    [timeValue, showSeconds, store],\r\n  );\r\n\r\n  if (!is12Hour) return null;\r\n\r\n  const now = new Date();\r\n  const referenceHour = timeValue?.hour ?? now.getHours();\r\n  const currentPeriod = to12Hour(referenceHour).period;\r\n\r\n  const PeriodPrimitive = asChild ? SlotPrimitive.Slot : TimePickerColumn;\r\n\r\n  return (\r\n    <PeriodPrimitive\r\n      data-slot=\"time-picker-period\"\r\n      {...periodProps}\r\n      className={cn(\"flex flex-col gap-1 p-1\", className)}\r\n    >\r\n      {PERIODS.map((period) => (\r\n        <TimePickerColumnItem\r\n          key={period}\r\n          value={period}\r\n          selected={currentPeriod === period}\r\n          onClick={() => onPeriodToggle(period)}\r\n        />\r\n      ))}\r\n    </PeriodPrimitive>\r\n  );\r\n}\r\n\r\ninterface TimePickerSeparatorProps extends React.ComponentProps<\"span\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction TimePickerSeparator(props: TimePickerSeparatorProps) {\r\n  const { asChild, children, ...separatorProps } = props;\r\n\r\n  const SeparatorPrimitive = asChild ? SlotPrimitive.Slot : \"span\";\r\n\r\n  return (\r\n    <SeparatorPrimitive\r\n      aria-hidden=\"true\"\r\n      data-slot=\"time-picker-separator\"\r\n      {...separatorProps}\r\n    >\r\n      {children ?? \":\"}\r\n    </SeparatorPrimitive>\r\n  );\r\n}\r\n\r\nfunction TimePickerClear(props: ButtonProps) {\r\n  const {\r\n    asChild,\r\n    className,\r\n    children,\r\n    disabled: disabledProp,\r\n    ...clearProps\r\n  } = props;\r\n\r\n  const { disabled, readOnly } = useTimePickerContext(CLEAR_NAME);\r\n  const store = useStoreContext(CLEAR_NAME);\r\n\r\n  const isDisabled = disabledProp || disabled;\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      clearProps.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      event.preventDefault();\r\n      if (disabled || readOnly) return;\r\n      store.setState(\"value\", \"\");\r\n    },\r\n    [clearProps.onClick, disabled, readOnly, store],\r\n  );\r\n\r\n  const ClearPrimitive = asChild ? SlotPrimitive.Slot : \"button\";\r\n\r\n  return (\r\n    <ClearPrimitive\r\n      type=\"button\"\r\n      data-slot=\"time-picker-clear\"\r\n      disabled={isDisabled}\r\n      {...clearProps}\r\n      className={cn(\r\n        \"inline-flex items-center justify-center rounded-sm font-medium text-sm transition-colors hover:bg-accent hover:text-accent-foreground disabled:pointer-events-none disabled:opacity-50\",\r\n        className,\r\n      )}\r\n      onClick={onClick}\r\n    >\r\n      {children ?? \"Clear\"}\r\n    </ClearPrimitive>\r\n  );\r\n}\r\n\r\nexport {\r\n  TimePicker,\r\n  TimePickerLabel,\r\n  TimePickerInputGroup,\r\n  TimePickerInput,\r\n  TimePickerTrigger,\r\n  TimePickerContent,\r\n  TimePickerHour,\r\n  TimePickerMinute,\r\n  TimePickerSecond,\r\n  TimePickerPeriod,\r\n  TimePickerSeparator,\r\n  TimePickerClear,\r\n  //\r\n  useStore as useTimePicker,\r\n  //\r\n  type TimePickerProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/visually-hidden-input.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\n\r\ntype InputValue = string[] | string;\r\n\r\ninterface VisuallyHiddenInputProps<T = InputValue>\r\n  extends Omit<\r\n    React.InputHTMLAttributes<HTMLInputElement>,\r\n    \"value\" | \"checked\" | \"onReset\"\r\n  > {\r\n  value?: T;\r\n  checked?: boolean;\r\n  control: HTMLElement | null;\r\n  bubbles?: boolean;\r\n}\r\n\r\nfunction VisuallyHiddenInput<T = InputValue>(\r\n  props: VisuallyHiddenInputProps<T>,\r\n) {\r\n  const {\r\n    control,\r\n    value,\r\n    checked,\r\n    bubbles = true,\r\n    type = \"hidden\",\r\n    style,\r\n    ...inputProps\r\n  } = props;\r\n\r\n  const isCheckInput = React.useMemo(\r\n    () => type === \"checkbox\" || type === \"radio\" || type === \"switch\",\r\n    [type],\r\n  );\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  const prevValueRef = React.useRef<{\r\n    value: T | boolean | undefined;\r\n    previous: T | boolean | undefined;\r\n  }>({\r\n    value: isCheckInput ? checked : value,\r\n    previous: isCheckInput ? checked : value,\r\n  });\r\n\r\n  const prevValue = React.useMemo(() => {\r\n    const currentValue = isCheckInput ? checked : value;\r\n    if (prevValueRef.current.value !== currentValue) {\r\n      prevValueRef.current.previous = prevValueRef.current.value;\r\n      prevValueRef.current.value = currentValue;\r\n    }\r\n    return prevValueRef.current.previous;\r\n  }, [isCheckInput, value, checked]);\r\n\r\n  const [controlSize, setControlSize] = React.useState<{\r\n    width?: number;\r\n    height?: number;\r\n  }>({});\r\n\r\n  React.useLayoutEffect(() => {\r\n    if (!control) {\r\n      setControlSize({});\r\n      return;\r\n    }\r\n\r\n    setControlSize({\r\n      width: control.offsetWidth,\r\n      height: control.offsetHeight,\r\n    });\r\n\r\n    if (typeof window === \"undefined\") return;\r\n\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      if (!Array.isArray(entries) || !entries.length) return;\r\n\r\n      const entry = entries[0];\r\n      if (!entry) return;\r\n\r\n      let width: number;\r\n      let height: number;\r\n\r\n      if (\"borderBoxSize\" in entry) {\r\n        const borderSizeEntry = entry.borderBoxSize;\r\n        const borderSize = Array.isArray(borderSizeEntry)\r\n          ? borderSizeEntry[0]\r\n          : borderSizeEntry;\r\n        width = borderSize.inlineSize;\r\n        height = borderSize.blockSize;\r\n      } else {\r\n        width = control.offsetWidth;\r\n        height = control.offsetHeight;\r\n      }\r\n\r\n      setControlSize({ width, height });\r\n    });\r\n\r\n    resizeObserver.observe(control, { box: \"border-box\" });\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [control]);\r\n\r\n  React.useEffect(() => {\r\n    const input = inputRef.current;\r\n    if (!input) return;\r\n\r\n    const inputProto = window.HTMLInputElement.prototype;\r\n    const propertyKey = isCheckInput ? \"checked\" : \"value\";\r\n    const eventType = isCheckInput ? \"click\" : \"input\";\r\n    const currentValue = isCheckInput ? checked : value;\r\n\r\n    const serializedCurrentValue = isCheckInput\r\n      ? checked\r\n      : typeof value === \"object\" && value !== null\r\n        ? JSON.stringify(value)\r\n        : value;\r\n\r\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, propertyKey);\r\n\r\n    const setter = descriptor?.set;\r\n\r\n    if (prevValue !== currentValue && setter) {\r\n      const event = new Event(eventType, { bubbles });\r\n      setter.call(input, serializedCurrentValue);\r\n      input.dispatchEvent(event);\r\n    }\r\n  }, [prevValue, value, checked, bubbles, isCheckInput]);\r\n\r\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\r\n    return {\r\n      ...style,\r\n      ...(controlSize.width !== undefined && controlSize.height !== undefined\r\n        ? controlSize\r\n        : {}),\r\n      border: 0,\r\n      clip: \"rect(0 0 0 0)\",\r\n      clipPath: \"inset(50%)\",\r\n      height: \"1px\",\r\n      margin: \"-1px\",\r\n      overflow: \"hidden\",\r\n      padding: 0,\r\n      position: \"absolute\",\r\n      whiteSpace: \"nowrap\",\r\n      width: \"1px\",\r\n    };\r\n  }, [style, controlSize]);\r\n\r\n  return (\r\n    <input\r\n      type={type}\r\n      {...inputProps}\r\n      ref={inputRef}\r\n      aria-hidden={isCheckInput}\r\n      tabIndex={-1}\r\n      defaultChecked={isCheckInput ? checked : undefined}\r\n      style={composedStyle}\r\n    />\r\n  );\r\n}\r\n\r\nexport { VisuallyHiddenInput };\r\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "css": {
    "@utility scrollbar-none": {
      "scrollbar-width": "none",
      "&::-webkit-scrollbar": {
        "display": "none"
      }
    }
  },
  "type": "registry:ui"
}