{
  "name": "stepper",
  "dependencies": [
    "radix-ui"
  ],
  "registryDependencies": [
    "button",
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/stepper.tsx",
      "content": "\"use client\";\r\n\r\nimport { Check } from \"lucide-react\";\r\nimport {\r\n  Direction as DirectionPrimitive,\r\n  Slot as SlotPrimitive,\r\n} from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"Stepper\";\r\nconst LIST_NAME = \"StepperList\";\r\nconst ITEM_NAME = \"StepperItem\";\r\nconst TRIGGER_NAME = \"StepperTrigger\";\r\nconst INDICATOR_NAME = \"StepperIndicator\";\r\nconst SEPARATOR_NAME = \"StepperSeparator\";\r\nconst TITLE_NAME = \"StepperTitle\";\r\nconst DESCRIPTION_NAME = \"StepperDescription\";\r\nconst CONTENT_NAME = \"StepperContent\";\r\nconst PREV_NAME = \"StepperPrev\";\r\nconst NEXT_NAME = \"StepperNext\";\r\n\r\nconst ENTRY_FOCUS = \"stepperFocusGroup.onEntryFocus\";\r\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\r\nconst ARROW_KEYS = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\ntype Orientation = \"horizontal\" | \"vertical\";\r\ntype NavigationDirection = \"next\" | \"prev\";\r\ntype ActivationMode = \"automatic\" | \"manual\";\r\ntype DataState = \"inactive\" | \"active\" | \"completed\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\ninterface ButtonProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype ListElement = React.ComponentRef<typeof StepperList>;\r\ntype TriggerElement = React.ComponentRef<typeof StepperTrigger>;\r\n\r\nfunction getId(\r\n  id: string,\r\n  variant: \"trigger\" | \"content\" | \"title\" | \"description\",\r\n  value: string,\r\n) {\r\n  return `${id}-${variant}-${value}`;\r\n}\r\n\r\ntype FocusIntent = \"first\" | \"last\" | \"prev\" | \"next\";\r\n\r\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\r\n  ArrowLeft: \"prev\",\r\n  ArrowUp: \"prev\",\r\n  ArrowRight: \"next\",\r\n  ArrowDown: \"next\",\r\n  PageUp: \"first\",\r\n  Home: \"first\",\r\n  PageDown: \"last\",\r\n  End: \"last\",\r\n};\r\n\r\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\r\n  if (dir !== \"rtl\") return key;\r\n  return key === \"ArrowLeft\"\r\n    ? \"ArrowRight\"\r\n    : key === \"ArrowRight\"\r\n      ? \"ArrowLeft\"\r\n      : key;\r\n}\r\n\r\nfunction getFocusIntent(\r\n  event: React.KeyboardEvent<TriggerElement>,\r\n  dir?: Direction,\r\n  orientation?: Orientation,\r\n) {\r\n  const key = getDirectionAwareKey(event.key, dir);\r\n  if (orientation === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(key))\r\n    return undefined;\r\n  if (orientation === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(key))\r\n    return undefined;\r\n  return MAP_KEY_TO_FOCUS_INTENT[key];\r\n}\r\n\r\nfunction focusFirst(\r\n  candidates: React.RefObject<TriggerElement | null>[],\r\n  preventScroll = false,\r\n) {\r\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\r\n  for (const candidateRef of candidates) {\r\n    const candidate = candidateRef.current;\r\n    if (!candidate) continue;\r\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\r\n    candidate.focus({ preventScroll });\r\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\r\n  }\r\n}\r\n\r\nfunction wrapArray<T>(array: T[], startIndex: number) {\r\n  return array.map<T>(\r\n    (_, index) => array[(startIndex + index) % array.length] as T,\r\n  );\r\n}\r\n\r\nfunction getDataState(\r\n  value: string | undefined,\r\n  itemValue: string,\r\n  stepState: StepState | undefined,\r\n  steps: Map<string, StepState>,\r\n  variant: \"item\" | \"separator\" = \"item\",\r\n): DataState {\r\n  const stepKeys = Array.from(steps.keys());\r\n  const currentIndex = stepKeys.indexOf(itemValue);\r\n\r\n  if (stepState?.completed) return \"completed\";\r\n\r\n  if (value === itemValue) {\r\n    return variant === \"separator\" ? \"inactive\" : \"active\";\r\n  }\r\n\r\n  if (value) {\r\n    const activeIndex = stepKeys.indexOf(value);\r\n\r\n    if (activeIndex > currentIndex) return \"completed\";\r\n  }\r\n\r\n  return \"inactive\";\r\n}\r\n\r\ninterface StepState {\r\n  value: string;\r\n  completed: boolean;\r\n  disabled: boolean;\r\n}\r\n\r\ninterface StoreState {\r\n  steps: Map<string, StepState>;\r\n  value: string;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  setStateWithValidation: (\r\n    value: string,\r\n    direction: NavigationDirection,\r\n  ) => Promise<boolean>;\r\n  hasValidation: () => boolean;\r\n  notify: () => void;\r\n  addStep: (value: string, completed: boolean, disabled: boolean) => void;\r\n  removeStep: (value: string) => void;\r\n  setStep: (value: string, completed: boolean, disabled: boolean) => void;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(selector: (state: StoreState) => T): T {\r\n  const store = useStoreContext(\"useStore\");\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface ItemData {\r\n  id: string;\r\n  ref: React.RefObject<TriggerElement | null>;\r\n  value: string;\r\n  active: boolean;\r\n  disabled: boolean;\r\n}\r\n\r\ninterface StepperContextValue {\r\n  rootId: string;\r\n  dir: Direction;\r\n  orientation: Orientation;\r\n  activationMode: ActivationMode;\r\n  disabled: boolean;\r\n  nonInteractive: boolean;\r\n  loop: boolean;\r\n}\r\n\r\nconst StepperContext = React.createContext<StepperContextValue | null>(null);\r\n\r\nfunction useStepperContext(consumerName: string) {\r\n  const context = React.useContext(StepperContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface StepperProps extends DivProps {\r\n  value?: string;\r\n  defaultValue?: string;\r\n  onValueChange?: (value: string) => void;\r\n  onValueComplete?: (value: string, completed: boolean) => void;\r\n  onValueAdd?: (value: string) => void;\r\n  onValueRemove?: (value: string) => void;\r\n  onValidate?: (\r\n    value: string,\r\n    direction: NavigationDirection,\r\n  ) => boolean | Promise<boolean>;\r\n  activationMode?: ActivationMode;\r\n  dir?: Direction;\r\n  orientation?: Orientation;\r\n  disabled?: boolean;\r\n  loop?: boolean;\r\n  nonInteractive?: boolean;\r\n}\r\n\r\nfunction Stepper(props: StepperProps) {\r\n  const {\r\n    value,\r\n    defaultValue,\r\n    onValueChange,\r\n    onValueComplete,\r\n    onValueAdd,\r\n    onValueRemove,\r\n    onValidate,\r\n    dir: dirProp,\r\n    orientation = \"horizontal\",\r\n    activationMode = \"automatic\",\r\n    asChild,\r\n    disabled = false,\r\n    nonInteractive = false,\r\n    loop = false,\r\n    className,\r\n    id,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    steps: new Map(),\r\n    value: value ?? defaultValue ?? \"\",\r\n  }));\r\n\r\n  const propsRef = useAsRef({\r\n    onValueChange,\r\n    onValueComplete,\r\n    onValueAdd,\r\n    onValueRemove,\r\n    onValidate,\r\n  });\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n\r\n        if (key === \"value\" && typeof value === \"string\") {\r\n          stateRef.current.value = value;\r\n          propsRef.current.onValueChange?.(value);\r\n        } else {\r\n          stateRef.current[key] = value;\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      setStateWithValidation: async (value, direction) => {\r\n        if (!propsRef.current.onValidate) {\r\n          store.setState(\"value\", value);\r\n          return true;\r\n        }\r\n\r\n        try {\r\n          const isValid = await propsRef.current.onValidate(value, direction);\r\n          if (isValid) {\r\n            store.setState(\"value\", value);\r\n          }\r\n          return isValid;\r\n        } catch {\r\n          return false;\r\n        }\r\n      },\r\n      hasValidation: () => !!propsRef.current.onValidate,\r\n      addStep: (value, completed, disabled) => {\r\n        const newStep: StepState = { value, completed, disabled };\r\n        stateRef.current.steps.set(value, newStep);\r\n        propsRef.current.onValueAdd?.(value);\r\n        store.notify();\r\n      },\r\n      removeStep: (value) => {\r\n        stateRef.current.steps.delete(value);\r\n        propsRef.current.onValueRemove?.(value);\r\n        store.notify();\r\n      },\r\n      setStep: (value, completed, disabled) => {\r\n        const step = stateRef.current.steps.get(value);\r\n        if (step) {\r\n          const updatedStep: StepState = { ...step, completed, disabled };\r\n          stateRef.current.steps.set(value, updatedStep);\r\n\r\n          if (completed !== step.completed) {\r\n            propsRef.current.onValueComplete?.(value, completed);\r\n          }\r\n\r\n          store.notify();\r\n        }\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (value !== undefined) {\r\n      store.setState(\"value\", value);\r\n    }\r\n  }, [value]);\r\n\r\n  const dir = DirectionPrimitive.useDirection(dirProp);\r\n\r\n  const instanceId = React.useId();\r\n  const rootId = id ?? instanceId;\r\n\r\n  const contextValue = React.useMemo<StepperContextValue>(\r\n    () => ({\r\n      rootId,\r\n      dir,\r\n      orientation,\r\n      activationMode,\r\n      disabled,\r\n      nonInteractive,\r\n      loop,\r\n    }),\r\n    [rootId, dir, orientation, activationMode, disabled, nonInteractive, loop],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <StepperContext.Provider value={contextValue}>\r\n        <RootPrimitive\r\n          id={rootId}\r\n          data-disabled={disabled ? \"\" : undefined}\r\n          data-orientation={orientation}\r\n          data-slot=\"stepper\"\r\n          dir={dir}\r\n          {...rootProps}\r\n          className={cn(\r\n            \"flex gap-6\",\r\n            orientation === \"horizontal\" ? \"w-full flex-col\" : \"flex-row\",\r\n            className,\r\n          )}\r\n        />\r\n      </StepperContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface FocusContextValue {\r\n  tabStopId: string | null;\r\n  onItemFocus: (tabStopId: string) => void;\r\n  onItemShiftTab: () => void;\r\n  onFocusableItemAdd: () => void;\r\n  onFocusableItemRemove: () => void;\r\n  onItemRegister: (item: ItemData) => void;\r\n  onItemUnregister: (id: string) => void;\r\n  getItems: () => ItemData[];\r\n}\r\n\r\nconst FocusContext = React.createContext<FocusContextValue | null>(null);\r\n\r\nfunction useFocusContext(consumerName: string) {\r\n  const context = React.useContext(FocusContext);\r\n  if (!context) {\r\n    throw new Error(\r\n      `\\`${consumerName}\\` must be used within \\`FocusProvider\\``,\r\n    );\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction StepperList(props: DivProps) {\r\n  const {\r\n    asChild,\r\n    onBlur: onBlurProp,\r\n    onFocus: onFocusProp,\r\n    onMouseDown: onMouseDownProp,\r\n    className,\r\n    children,\r\n    ref,\r\n    ...listProps\r\n  } = props;\r\n\r\n  const context = useStepperContext(LIST_NAME);\r\n  const orientation = context.orientation;\r\n  const currentValue = useStore((state) => state.value);\r\n\r\n  const propsRef = useAsRef({\r\n    onBlur: onBlurProp,\r\n    onFocus: onFocusProp,\r\n    onMouseDown: onMouseDownProp,\r\n  });\r\n\r\n  const [tabStopId, setTabStopId] = React.useState<string | null>(null);\r\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\r\n  const [focusableItemCount, setFocusableItemCount] = React.useState(0);\r\n  const isClickFocusRef = React.useRef(false);\r\n  const itemsRef = React.useRef<Map<string, ItemData>>(new Map());\r\n  const listRef = React.useRef<ListElement>(null);\r\n  const composedRef = useComposedRefs(ref, listRef);\r\n\r\n  const onItemFocus = React.useCallback((tabStopId: string) => {\r\n    setTabStopId(tabStopId);\r\n  }, []);\r\n\r\n  const onItemShiftTab = React.useCallback(() => {\r\n    setIsTabbingBackOut(true);\r\n  }, []);\r\n\r\n  const onFocusableItemAdd = React.useCallback(() => {\r\n    setFocusableItemCount((prevCount) => prevCount + 1);\r\n  }, []);\r\n\r\n  const onFocusableItemRemove = React.useCallback(() => {\r\n    setFocusableItemCount((prevCount) => prevCount - 1);\r\n  }, []);\r\n\r\n  const onItemRegister = React.useCallback((item: ItemData) => {\r\n    itemsRef.current.set(item.id, item);\r\n  }, []);\r\n\r\n  const onItemUnregister = React.useCallback((id: string) => {\r\n    itemsRef.current.delete(id);\r\n  }, []);\r\n\r\n  const getItems = React.useCallback(() => {\r\n    return Array.from(itemsRef.current.values())\r\n      .filter((item) => item.ref.current)\r\n      .sort((a, b) => {\r\n        const elementA = a.ref.current;\r\n        const elementB = b.ref.current;\r\n        if (!elementA || !elementB) return 0;\r\n        const position = elementA.compareDocumentPosition(elementB);\r\n        if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\r\n          return -1;\r\n        }\r\n        if (position & Node.DOCUMENT_POSITION_PRECEDING) {\r\n          return 1;\r\n        }\r\n        return 0;\r\n      });\r\n  }, []);\r\n\r\n  const onBlur = React.useCallback(\r\n    (event: React.FocusEvent<ListElement>) => {\r\n      propsRef.current.onBlur?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      setIsTabbingBackOut(false);\r\n    },\r\n    [propsRef],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<ListElement>) => {\r\n      propsRef.current.onFocus?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const isKeyboardFocus = !isClickFocusRef.current;\r\n      if (\r\n        event.target === event.currentTarget &&\r\n        isKeyboardFocus &&\r\n        !isTabbingBackOut\r\n      ) {\r\n        const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\r\n        event.currentTarget.dispatchEvent(entryFocusEvent);\r\n\r\n        if (!entryFocusEvent.defaultPrevented) {\r\n          const items = Array.from(itemsRef.current.values()).filter(\r\n            (item) => !item.disabled,\r\n          );\r\n          const selectedItem = currentValue\r\n            ? items.find((item) => item.value === currentValue)\r\n            : undefined;\r\n          const activeItem = items.find((item) => item.active);\r\n          const currentItem = items.find((item) => item.id === tabStopId);\r\n\r\n          const candidateItems = [\r\n            selectedItem,\r\n            activeItem,\r\n            currentItem,\r\n            ...items,\r\n          ].filter(Boolean) as ItemData[];\r\n          const candidateRefs = candidateItems.map((item) => item.ref);\r\n          focusFirst(candidateRefs, false);\r\n        }\r\n      }\r\n      isClickFocusRef.current = false;\r\n    },\r\n    [propsRef, isTabbingBackOut, currentValue, tabStopId],\r\n  );\r\n\r\n  const onMouseDown = React.useCallback(\r\n    (event: React.MouseEvent<ListElement>) => {\r\n      propsRef.current.onMouseDown?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      isClickFocusRef.current = true;\r\n    },\r\n    [propsRef],\r\n  );\r\n\r\n  const focusContextValue = React.useMemo<FocusContextValue>(\r\n    () => ({\r\n      tabStopId,\r\n      onItemFocus,\r\n      onItemShiftTab,\r\n      onFocusableItemAdd,\r\n      onFocusableItemRemove,\r\n      onItemRegister,\r\n      onItemUnregister,\r\n      getItems,\r\n    }),\r\n    [\r\n      tabStopId,\r\n      onItemFocus,\r\n      onItemShiftTab,\r\n      onFocusableItemAdd,\r\n      onFocusableItemRemove,\r\n      onItemRegister,\r\n      onItemUnregister,\r\n      getItems,\r\n    ],\r\n  );\r\n\r\n  const ListPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <FocusContext.Provider value={focusContextValue}>\r\n      <ListPrimitive\r\n        role=\"tablist\"\r\n        aria-orientation={orientation}\r\n        data-orientation={orientation}\r\n        data-slot=\"stepper-list\"\r\n        dir={context.dir}\r\n        tabIndex={isTabbingBackOut || focusableItemCount === 0 ? -1 : 0}\r\n        {...listProps}\r\n        ref={composedRef}\r\n        className={cn(\r\n          \"flex outline-none\",\r\n          orientation === \"horizontal\"\r\n            ? \"flex-row items-center\"\r\n            : \"flex-col items-start\",\r\n          className,\r\n        )}\r\n        onBlur={onBlur}\r\n        onFocus={onFocus}\r\n        onMouseDown={onMouseDown}\r\n      >\r\n        {children}\r\n      </ListPrimitive>\r\n    </FocusContext.Provider>\r\n  );\r\n}\r\n\r\ninterface StepperItemContextValue {\r\n  value: string;\r\n  stepState: StepState | undefined;\r\n}\r\n\r\nconst StepperItemContext = React.createContext<StepperItemContextValue | null>(\r\n  null,\r\n);\r\n\r\nfunction useStepperItemContext(consumerName: string) {\r\n  const context = React.useContext(StepperItemContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ITEM_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface StepperItemProps extends DivProps {\r\n  value: string;\r\n  completed?: boolean;\r\n  disabled?: boolean;\r\n}\r\n\r\nfunction StepperItem(props: StepperItemProps) {\r\n  const {\r\n    value: itemValue,\r\n    completed = false,\r\n    disabled = false,\r\n    asChild,\r\n    className,\r\n    children,\r\n    ref,\r\n    ...itemProps\r\n  } = props;\r\n\r\n  const context = useStepperContext(ITEM_NAME);\r\n  const store = useStoreContext(ITEM_NAME);\r\n  const orientation = context.orientation;\r\n  const value = useStore((state) => state.value);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    store.addStep(itemValue, completed, disabled);\r\n\r\n    return () => {\r\n      store.removeStep(itemValue);\r\n    };\r\n  }, [itemValue, completed, disabled]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    store.setStep(itemValue, completed, disabled);\r\n  }, [itemValue, completed, disabled]);\r\n\r\n  const stepState = useStore((state) => state.steps.get(itemValue));\r\n  const steps = useStore((state) => state.steps);\r\n  const dataState = getDataState(value, itemValue, stepState, steps);\r\n\r\n  const itemContextValue = React.useMemo<StepperItemContextValue>(\r\n    () => ({\r\n      value: itemValue,\r\n      stepState,\r\n    }),\r\n    [itemValue, stepState],\r\n  );\r\n\r\n  const ItemPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StepperItemContext.Provider value={itemContextValue}>\r\n      <ItemPrimitive\r\n        data-disabled={stepState?.disabled ? \"\" : undefined}\r\n        data-orientation={orientation}\r\n        data-state={dataState}\r\n        data-slot=\"stepper-item\"\r\n        dir={context.dir}\r\n        {...itemProps}\r\n        ref={ref}\r\n        className={cn(\r\n          \"relative flex not-last:flex-1 items-center\",\r\n          orientation === \"horizontal\" ? \"flex-row\" : \"flex-col\",\r\n          className,\r\n        )}\r\n      >\r\n        {children}\r\n      </ItemPrimitive>\r\n    </StepperItemContext.Provider>\r\n  );\r\n}\r\n\r\nfunction StepperTrigger(props: ButtonProps) {\r\n  const {\r\n    asChild,\r\n    onClick: onClickProp,\r\n    onFocus: onFocusProp,\r\n    onKeyDown: onKeyDownProp,\r\n    onMouseDown: onMouseDownProp,\r\n    disabled,\r\n    className,\r\n    ref,\r\n    ...triggerProps\r\n  } = props;\r\n\r\n  const context = useStepperContext(TRIGGER_NAME);\r\n  const itemContext = useStepperItemContext(TRIGGER_NAME);\r\n  const itemValue = itemContext.value;\r\n\r\n  const store = useStoreContext(TRIGGER_NAME);\r\n  const focusContext = useFocusContext(TRIGGER_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n  const stepState = useStore((state) => state.steps.get(itemValue));\r\n\r\n  const propsRef = useAsRef({\r\n    onClick: onClickProp,\r\n    onFocus: onFocusProp,\r\n    onKeyDown: onKeyDownProp,\r\n    onMouseDown: onMouseDownProp,\r\n  });\r\n\r\n  const activationMode = context.activationMode;\r\n  const orientation = context.orientation;\r\n  const loop = context.loop;\r\n\r\n  const stepIndex = Array.from(steps.keys()).indexOf(itemValue);\r\n\r\n  const stepPosition = stepIndex + 1;\r\n  const stepCount = steps.size;\r\n\r\n  const triggerId = getId(context.rootId, \"trigger\", itemValue);\r\n  const contentId = getId(context.rootId, \"content\", itemValue);\r\n  const titleId = getId(context.rootId, \"title\", itemValue);\r\n  const descriptionId = getId(context.rootId, \"description\", itemValue);\r\n\r\n  const isDisabled = disabled || stepState?.disabled || context.disabled;\r\n  const isActive = value === itemValue;\r\n  const isTabStop = focusContext.tabStopId === triggerId;\r\n  const dataState = getDataState(value, itemValue, stepState, steps);\r\n\r\n  const triggerRef = React.useRef<TriggerElement>(null);\r\n  const composedRef = useComposedRefs(ref, triggerRef);\r\n  const isArrowKeyPressedRef = React.useRef(false);\r\n  const isMouseClickRef = React.useRef(false);\r\n\r\n  React.useEffect(() => {\r\n    function onKeyDown(event: KeyboardEvent) {\r\n      if (ARROW_KEYS.includes(event.key)) {\r\n        isArrowKeyPressedRef.current = true;\r\n      }\r\n    }\r\n    function onKeyUp() {\r\n      isArrowKeyPressedRef.current = false;\r\n    }\r\n    document.addEventListener(\"keydown\", onKeyDown);\r\n    document.addEventListener(\"keyup\", onKeyUp);\r\n    return () => {\r\n      document.removeEventListener(\"keydown\", onKeyDown);\r\n      document.removeEventListener(\"keyup\", onKeyUp);\r\n    };\r\n  }, []);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    focusContext.onItemRegister({\r\n      id: triggerId,\r\n      ref: triggerRef,\r\n      value: itemValue,\r\n      active: isTabStop,\r\n      disabled: !!isDisabled,\r\n    });\r\n\r\n    if (!isDisabled) {\r\n      focusContext.onFocusableItemAdd();\r\n    }\r\n\r\n    return () => {\r\n      focusContext.onItemUnregister(triggerId);\r\n      if (!isDisabled) {\r\n        focusContext.onFocusableItemRemove();\r\n      }\r\n    };\r\n  }, [focusContext, triggerId, itemValue, isTabStop, isDisabled]);\r\n\r\n  const onClick = React.useCallback(\r\n    async (event: React.MouseEvent<TriggerElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (!isDisabled && !context.nonInteractive) {\r\n        const currentStepIndex = Array.from(steps.keys()).indexOf(value ?? \"\");\r\n        const targetStepIndex = Array.from(steps.keys()).indexOf(itemValue);\r\n        const direction = targetStepIndex > currentStepIndex ? \"next\" : \"prev\";\r\n\r\n        await store.setStateWithValidation(itemValue, direction);\r\n      }\r\n    },\r\n    [\r\n      isDisabled,\r\n      context.nonInteractive,\r\n      store,\r\n      itemValue,\r\n      value,\r\n      steps,\r\n      propsRef,\r\n    ],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    async (event: React.FocusEvent<TriggerElement>) => {\r\n      propsRef.current.onFocus?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      focusContext.onItemFocus(triggerId);\r\n\r\n      const isKeyboardFocus = !isMouseClickRef.current;\r\n\r\n      if (\r\n        !isActive &&\r\n        !isDisabled &&\r\n        activationMode !== \"manual\" &&\r\n        !context.nonInteractive &&\r\n        isKeyboardFocus\r\n      ) {\r\n        const currentStepIndex = Array.from(steps.keys()).indexOf(value || \"\");\r\n        const targetStepIndex = Array.from(steps.keys()).indexOf(itemValue);\r\n        const direction = targetStepIndex > currentStepIndex ? \"next\" : \"prev\";\r\n\r\n        await store.setStateWithValidation(itemValue, direction);\r\n      }\r\n\r\n      isMouseClickRef.current = false;\r\n    },\r\n    [\r\n      focusContext,\r\n      triggerId,\r\n      activationMode,\r\n      isActive,\r\n      isDisabled,\r\n      context.nonInteractive,\r\n      store,\r\n      itemValue,\r\n      value,\r\n      steps,\r\n      propsRef,\r\n    ],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    async (event: React.KeyboardEvent<TriggerElement>) => {\r\n      propsRef.current.onKeyDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (event.key === \"Enter\" && context.nonInteractive) {\r\n        event.preventDefault();\r\n        return;\r\n      }\r\n\r\n      if (\r\n        (event.key === \"Enter\" || event.key === \" \") &&\r\n        activationMode === \"manual\" &&\r\n        !context.nonInteractive\r\n      ) {\r\n        event.preventDefault();\r\n        if (!isDisabled && triggerRef.current) {\r\n          triggerRef.current.click();\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (event.key === \"Tab\" && event.shiftKey) {\r\n        focusContext.onItemShiftTab();\r\n        return;\r\n      }\r\n\r\n      if (event.target !== event.currentTarget) return;\r\n\r\n      const focusIntent = getFocusIntent(event, context.dir, orientation);\r\n\r\n      if (focusIntent !== undefined) {\r\n        if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)\r\n          return;\r\n        event.preventDefault();\r\n\r\n        const items = focusContext.getItems().filter((item) => !item.disabled);\r\n        let candidateRefs = items.map((item) => item.ref);\r\n\r\n        if (focusIntent === \"last\") {\r\n          candidateRefs.reverse();\r\n        } else if (focusIntent === \"prev\" || focusIntent === \"next\") {\r\n          if (focusIntent === \"prev\") candidateRefs.reverse();\r\n          const currentIndex = candidateRefs.findIndex(\r\n            (ref) => ref.current === event.currentTarget,\r\n          );\r\n          candidateRefs = loop\r\n            ? wrapArray(candidateRefs, currentIndex + 1)\r\n            : candidateRefs.slice(currentIndex + 1);\r\n        }\r\n\r\n        if (store.hasValidation() && candidateRefs.length > 0) {\r\n          const nextRef = candidateRefs[0];\r\n          const nextElement = nextRef?.current;\r\n          const nextItem = items.find(\r\n            (item) => item.ref.current === nextElement,\r\n          );\r\n\r\n          if (nextItem && nextItem.value !== itemValue) {\r\n            const currentStepIndex = Array.from(steps.keys()).indexOf(\r\n              value || \"\",\r\n            );\r\n            const targetStepIndex = Array.from(steps.keys()).indexOf(\r\n              nextItem.value,\r\n            );\r\n            const direction: NavigationDirection =\r\n              targetStepIndex > currentStepIndex ? \"next\" : \"prev\";\r\n\r\n            if (direction === \"next\") {\r\n              const isValid = await store.setStateWithValidation(\r\n                nextItem.value,\r\n                direction,\r\n              );\r\n              if (!isValid) return;\r\n            } else {\r\n              store.setState(\"value\", nextItem.value);\r\n            }\r\n\r\n            queueMicrotask(() => nextElement?.focus());\r\n            return;\r\n          }\r\n        }\r\n\r\n        queueMicrotask(() => focusFirst(candidateRefs));\r\n      }\r\n    },\r\n    [\r\n      focusContext,\r\n      context.nonInteractive,\r\n      context.dir,\r\n      activationMode,\r\n      orientation,\r\n      loop,\r\n      isDisabled,\r\n      store,\r\n      propsRef,\r\n      itemValue,\r\n      value,\r\n      steps,\r\n    ],\r\n  );\r\n\r\n  const onMouseDown = React.useCallback(\r\n    (event: React.MouseEvent<TriggerElement>) => {\r\n      propsRef.current.onMouseDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      isMouseClickRef.current = true;\r\n\r\n      if (isDisabled) {\r\n        event.preventDefault();\r\n      } else {\r\n        focusContext.onItemFocus(triggerId);\r\n      }\r\n    },\r\n    [focusContext, triggerId, isDisabled, propsRef],\r\n  );\r\n\r\n  const TriggerPrimitive = asChild ? SlotPrimitive.Slot : \"button\";\r\n\r\n  return (\r\n    <TriggerPrimitive\r\n      id={triggerId}\r\n      role=\"tab\"\r\n      type=\"button\"\r\n      aria-controls={contentId}\r\n      aria-current={isActive ? \"step\" : undefined}\r\n      aria-describedby={`${titleId} ${descriptionId}`}\r\n      aria-posinset={stepPosition}\r\n      aria-selected={isActive}\r\n      aria-setsize={stepCount}\r\n      data-disabled={isDisabled ? \"\" : undefined}\r\n      data-state={dataState}\r\n      data-slot=\"stepper-trigger\"\r\n      disabled={isDisabled}\r\n      tabIndex={isTabStop ? 0 : -1}\r\n      {...triggerProps}\r\n      ref={composedRef}\r\n      className={cn(\r\n        \"inline-flex items-center justify-center gap-3 rounded-md text-left outline-none transition-all focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:pointer-events-none disabled:opacity-50 aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0\",\r\n        \"not-has-data-[slot=description]:rounded-full not-has-data-[slot=title]:rounded-full\",\r\n        className,\r\n      )}\r\n      onClick={onClick}\r\n      onFocus={onFocus}\r\n      onKeyDown={onKeyDown}\r\n      onMouseDown={onMouseDown}\r\n    />\r\n  );\r\n}\r\n\r\ninterface StepperIndicatorProps extends Omit<DivProps, \"children\"> {\r\n  children?: React.ReactNode | ((dataState: DataState) => React.ReactNode);\r\n}\r\n\r\nfunction StepperIndicator(props: StepperIndicatorProps) {\r\n  const { className, children, asChild, ref, ...indicatorProps } = props;\r\n\r\n  const context = useStepperContext(INDICATOR_NAME);\r\n  const itemContext = useStepperItemContext(INDICATOR_NAME);\r\n\r\n  const value = useStore((state) => state.value);\r\n  const itemValue = itemContext.value;\r\n  const stepState = useStore((state) => state.steps.get(itemValue));\r\n  const steps = useStore((state) => state.steps);\r\n\r\n  const stepPosition = Array.from(steps.keys()).indexOf(itemValue) + 1;\r\n\r\n  const dataState = getDataState(value, itemValue, stepState, steps);\r\n\r\n  const IndicatorPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <IndicatorPrimitive\r\n      data-state={dataState}\r\n      data-slot=\"stepper-indicator\"\r\n      dir={context.dir}\r\n      {...indicatorProps}\r\n      ref={ref}\r\n      className={cn(\r\n        \"flex size-7 shrink-0 items-center justify-center rounded-full border-2 border-muted bg-background font-medium text-muted-foreground text-sm transition-colors data-[state=active]:border-primary data-[state=completed]:border-primary data-[state=active]:bg-primary data-[state=completed]:bg-primary data-[state=active]:text-primary-foreground data-[state=completed]:text-primary-foreground\",\r\n        className,\r\n      )}\r\n    >\r\n      {typeof children === \"function\" ? (\r\n        children(dataState)\r\n      ) : children ? (\r\n        children\r\n      ) : dataState === \"completed\" ? (\r\n        <Check className=\"size-4\" />\r\n      ) : (\r\n        stepPosition\r\n      )}\r\n    </IndicatorPrimitive>\r\n  );\r\n}\r\n\r\ninterface StepperSeparatorProps extends DivProps {\r\n  forceMount?: boolean;\r\n}\r\n\r\nfunction StepperSeparator(props: StepperSeparatorProps) {\r\n  const {\r\n    className,\r\n    asChild,\r\n    forceMount = false,\r\n    ref,\r\n    ...separatorProps\r\n  } = props;\r\n\r\n  const context = useStepperContext(SEPARATOR_NAME);\r\n  const itemContext = useStepperItemContext(SEPARATOR_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n\r\n  const orientation = context.orientation;\r\n\r\n  const stepIndex = Array.from(steps.keys()).indexOf(itemContext.value);\r\n\r\n  const isLastStep = stepIndex === steps.size - 1;\r\n\r\n  if (isLastStep && !forceMount) return null;\r\n\r\n  const dataState = getDataState(\r\n    value,\r\n    itemContext.value,\r\n    itemContext.stepState,\r\n    steps,\r\n    \"separator\",\r\n  );\r\n\r\n  const SeparatorPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <SeparatorPrimitive\r\n      role=\"separator\"\r\n      aria-hidden=\"true\"\r\n      aria-orientation={orientation}\r\n      data-orientation={orientation}\r\n      data-state={dataState}\r\n      data-slot=\"stepper-separator\"\r\n      dir={context.dir}\r\n      {...separatorProps}\r\n      ref={ref}\r\n      className={cn(\r\n        \"bg-border transition-colors data-[state=active]:bg-primary data-[state=completed]:bg-primary\",\r\n        orientation === \"horizontal\" ? \"h-px flex-1\" : \"h-10 w-px\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface StepperTitleProps extends React.ComponentProps<\"span\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction StepperTitle(props: StepperTitleProps) {\r\n  const { className, asChild, ref, ...titleProps } = props;\r\n\r\n  const context = useStepperContext(TITLE_NAME);\r\n  const itemContext = useStepperItemContext(TITLE_NAME);\r\n\r\n  const titleId = getId(context.rootId, \"title\", itemContext.value);\r\n\r\n  const TitlePrimitive = asChild ? SlotPrimitive.Slot : \"span\";\r\n\r\n  return (\r\n    <TitlePrimitive\r\n      id={titleId}\r\n      data-slot=\"title\"\r\n      dir={context.dir}\r\n      {...titleProps}\r\n      ref={ref}\r\n      className={cn(\"font-medium text-sm\", className)}\r\n    />\r\n  );\r\n}\r\n\r\ninterface StepperDescriptionProps extends React.ComponentProps<\"span\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction StepperDescription(props: StepperDescriptionProps) {\r\n  const { className, asChild, ref, ...descriptionProps } = props;\r\n\r\n  const context = useStepperContext(DESCRIPTION_NAME);\r\n  const itemContext = useStepperItemContext(DESCRIPTION_NAME);\r\n\r\n  const descriptionId = getId(context.rootId, \"description\", itemContext.value);\r\n\r\n  const DescriptionPrimitive = asChild ? SlotPrimitive.Slot : \"span\";\r\n\r\n  return (\r\n    <DescriptionPrimitive\r\n      id={descriptionId}\r\n      data-slot=\"description\"\r\n      dir={context.dir}\r\n      {...descriptionProps}\r\n      ref={ref}\r\n      className={cn(\"text-muted-foreground text-xs\", className)}\r\n    />\r\n  );\r\n}\r\n\r\ninterface StepperContentProps extends DivProps {\r\n  value: string;\r\n  forceMount?: boolean;\r\n}\r\n\r\nfunction StepperContent(props: StepperContentProps) {\r\n  const {\r\n    value: valueProp,\r\n    asChild,\r\n    forceMount = false,\r\n    ref,\r\n    className,\r\n    ...contentProps\r\n  } = props;\r\n\r\n  const context = useStepperContext(CONTENT_NAME);\r\n  const value = useStore((state) => state.value);\r\n\r\n  const contentId = getId(context.rootId, \"content\", valueProp);\r\n  const triggerId = getId(context.rootId, \"trigger\", valueProp);\r\n\r\n  if (valueProp !== value && !forceMount) return null;\r\n\r\n  const ContentPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <ContentPrimitive\r\n      id={contentId}\r\n      role=\"tabpanel\"\r\n      aria-labelledby={triggerId}\r\n      data-slot=\"stepper-content\"\r\n      dir={context.dir}\r\n      {...contentProps}\r\n      ref={ref}\r\n      className={cn(\"flex-1 outline-none\", className)}\r\n    />\r\n  );\r\n}\r\n\r\nfunction StepperPrev(props: ButtonProps) {\r\n  const { asChild, onClick: onClickProp, disabled, ...prevProps } = props;\r\n\r\n  const store = useStoreContext(PREV_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n\r\n  const propsRef = useAsRef({\r\n    onClick: onClickProp,\r\n  });\r\n\r\n  const stepKeys = Array.from(steps.keys());\r\n  const currentIndex = value ? stepKeys.indexOf(value) : -1;\r\n  const isDisabled = disabled || currentIndex <= 0;\r\n\r\n  const onClick = React.useCallback(\r\n    async (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n      if (event.defaultPrevented || isDisabled) return;\r\n\r\n      const prevIndex = Math.max(currentIndex - 1, 0);\r\n      const prevStepValue = stepKeys[prevIndex];\r\n\r\n      if (prevStepValue) {\r\n        store.setState(\"value\", prevStepValue);\r\n      }\r\n    },\r\n    [propsRef, isDisabled, currentIndex, stepKeys, store],\r\n  );\r\n\r\n  const PrevPrimitive = asChild ? SlotPrimitive.Slot : \"button\";\r\n\r\n  return (\r\n    <PrevPrimitive\r\n      type=\"button\"\r\n      data-slot=\"stepper-prev\"\r\n      disabled={isDisabled}\r\n      {...prevProps}\r\n      onClick={onClick}\r\n    />\r\n  );\r\n}\r\n\r\nfunction StepperNext(props: ButtonProps) {\r\n  const { asChild, onClick: onClickProp, disabled, ...nextProps } = props;\r\n\r\n  const store = useStoreContext(NEXT_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const steps = useStore((state) => state.steps);\r\n\r\n  const propsRef = useAsRef({\r\n    onClick: onClickProp,\r\n  });\r\n\r\n  const stepKeys = Array.from(steps.keys());\r\n  const currentIndex = value ? stepKeys.indexOf(value) : -1;\r\n  const isDisabled = disabled || currentIndex >= stepKeys.length - 1;\r\n\r\n  const onClick = React.useCallback(\r\n    async (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n      if (event.defaultPrevented || isDisabled) return;\r\n\r\n      const nextIndex = Math.min(currentIndex + 1, stepKeys.length - 1);\r\n      const nextStepValue = stepKeys[nextIndex];\r\n\r\n      if (nextStepValue) {\r\n        await store.setStateWithValidation(nextStepValue, \"next\");\r\n      }\r\n    },\r\n    [propsRef, isDisabled, currentIndex, stepKeys, store],\r\n  );\r\n\r\n  const NextPrimitive = asChild ? SlotPrimitive.Slot : \"button\";\r\n\r\n  return (\r\n    <NextPrimitive\r\n      type=\"button\"\r\n      data-slot=\"stepper-next\"\r\n      disabled={isDisabled}\r\n      {...nextProps}\r\n      onClick={onClick}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  Stepper,\r\n  StepperList,\r\n  StepperItem,\r\n  StepperTrigger,\r\n  StepperIndicator,\r\n  StepperSeparator,\r\n  StepperTitle,\r\n  StepperDescription,\r\n  StepperContent,\r\n  StepperPrev,\r\n  StepperNext,\r\n  //\r\n  useStore as useStepper,\r\n  //\r\n  type StepperProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}