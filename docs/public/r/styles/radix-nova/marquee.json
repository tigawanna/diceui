{
  "name": "marquee",
  "dependencies": [
    "radix-ui"
  ],
  "files": [
    {
      "path": "ui/marquee.tsx",
      "content": "\"use client\";\r\n\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\nimport {\r\n  Direction as DirectionPrimitive,\r\n  Slot as SlotPrimitive,\r\n} from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst ROOT_NAME = \"Marquee\";\r\nconst CONTENT_NAME = \"MarqueeContent\";\r\n\r\ntype Side = \"left\" | \"right\" | \"top\" | \"bottom\";\r\ntype Orientation = \"horizontal\" | \"vertical\";\r\ntype Direction = \"ltr\" | \"rtl\";\r\n\r\ntype RootElement = React.ComponentRef<typeof Marquee>;\r\ntype ContentElement = React.ComponentRef<typeof MarqueeContent>;\r\n\r\ninterface Dimensions {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\ninterface ElementDimensions {\r\n  rootSize: number;\r\n  contentSize: number;\r\n}\r\n\r\nfunction createResizeObserverStore() {\r\n  const listeners = new Set<() => void>();\r\n  let observer: ResizeObserver | null = null;\r\n  const elements = new Map<Element, Dimensions>();\r\n  const refCounts = new Map<Element, number>();\r\n  const isSupported = typeof ResizeObserver !== \"undefined\";\r\n  let notificationScheduled = false;\r\n\r\n  const snapshotCache = new WeakMap<\r\n    Element,\r\n    WeakMap<\r\n      Element,\r\n      { horizontal: ElementDimensions; vertical: ElementDimensions }\r\n    >\r\n  >();\r\n\r\n  function notify() {\r\n    if (notificationScheduled) return;\r\n    notificationScheduled = true;\r\n    queueMicrotask(() => {\r\n      notificationScheduled = false;\r\n      for (const callback of listeners) {\r\n        callback();\r\n      }\r\n    });\r\n  }\r\n\r\n  function cleanup() {\r\n    if (observer) {\r\n      observer.disconnect();\r\n      observer = null;\r\n    }\r\n    elements.clear();\r\n    refCounts.clear();\r\n  }\r\n\r\n  function subscribe(callback: () => void) {\r\n    listeners.add(callback);\r\n    return () => {\r\n      listeners.delete(callback);\r\n      if (listeners.size === 0) {\r\n        cleanup();\r\n      }\r\n    };\r\n  }\r\n\r\n  function getSnapshot(\r\n    rootElement: RootElement | null,\r\n    contentElement: ContentElement | null,\r\n    orientation: Orientation,\r\n  ): ElementDimensions | null {\r\n    if (!rootElement || !contentElement) return null;\r\n\r\n    const rootDims = elements.get(rootElement);\r\n    const contentDims = elements.get(contentElement);\r\n\r\n    if (!rootDims || !contentDims) return null;\r\n\r\n    const rootSize =\r\n      orientation === \"vertical\" ? rootDims.height : rootDims.width;\r\n    const contentSize =\r\n      orientation === \"vertical\" ? contentDims.height : contentDims.width;\r\n\r\n    let rootCache = snapshotCache.get(rootElement);\r\n    if (!rootCache) {\r\n      rootCache = new WeakMap();\r\n      snapshotCache.set(rootElement, rootCache);\r\n    }\r\n\r\n    let contentCache = rootCache.get(contentElement);\r\n    if (!contentCache) {\r\n      contentCache = {\r\n        horizontal: { rootSize: -1, contentSize: -1 },\r\n        vertical: { rootSize: -1, contentSize: -1 },\r\n      };\r\n      rootCache.set(contentElement, contentCache);\r\n    }\r\n\r\n    const cached = contentCache[orientation];\r\n    if (cached.rootSize === rootSize && cached.contentSize === contentSize) {\r\n      return cached;\r\n    }\r\n\r\n    const snapshot = { rootSize, contentSize };\r\n    contentCache[orientation] = snapshot;\r\n    return snapshot;\r\n  }\r\n\r\n  function observe(\r\n    rootElement: RootElement | null,\r\n    contentElement: Element | null,\r\n  ) {\r\n    if (!isSupported || !rootElement || !contentElement) return;\r\n\r\n    if (!observer) {\r\n      observer = new ResizeObserver((entries) => {\r\n        let hasChanged = false;\r\n\r\n        for (const entry of entries) {\r\n          const element = entry.target;\r\n          const { width, height } = entry.contentRect;\r\n\r\n          const currentData = elements.get(element);\r\n\r\n          if (\r\n            !currentData ||\r\n            currentData.width !== width ||\r\n            currentData.height !== height\r\n          ) {\r\n            elements.set(element, { width, height });\r\n            hasChanged = true;\r\n          }\r\n        }\r\n\r\n        if (hasChanged) {\r\n          notify();\r\n        }\r\n      });\r\n    }\r\n\r\n    refCounts.set(rootElement, (refCounts.get(rootElement) ?? 0) + 1);\r\n    refCounts.set(contentElement, (refCounts.get(contentElement) ?? 0) + 1);\r\n\r\n    observer.observe(rootElement);\r\n    observer.observe(contentElement);\r\n\r\n    const rootRect = rootElement.getBoundingClientRect();\r\n    const contentRect = contentElement.getBoundingClientRect();\r\n\r\n    const rootData = { width: rootRect.width, height: rootRect.height };\r\n    const contentData = {\r\n      width: contentRect.width,\r\n      height: contentRect.height,\r\n    };\r\n\r\n    elements.set(rootElement, rootData);\r\n    elements.set(contentElement, contentData);\r\n\r\n    if (\r\n      rootData.width > 0 &&\r\n      rootData.height > 0 &&\r\n      contentData.width > 0 &&\r\n      contentData.height > 0\r\n    ) {\r\n      notify();\r\n    }\r\n  }\r\n\r\n  function unobserve(\r\n    rootElement: RootElement | null,\r\n    contentElement: Element | null,\r\n  ) {\r\n    if (!observer || !rootElement || !contentElement) return;\r\n\r\n    const rootCount = (refCounts.get(rootElement) ?? 1) - 1;\r\n    const contentCount = (refCounts.get(contentElement) ?? 1) - 1;\r\n\r\n    if (rootCount <= 0) {\r\n      observer.unobserve(rootElement);\r\n      elements.delete(rootElement);\r\n      refCounts.delete(rootElement);\r\n    } else {\r\n      refCounts.set(rootElement, rootCount);\r\n    }\r\n\r\n    if (contentCount <= 0) {\r\n      observer.unobserve(contentElement);\r\n      elements.delete(contentElement);\r\n      refCounts.delete(contentElement);\r\n    } else {\r\n      refCounts.set(contentElement, contentCount);\r\n    }\r\n  }\r\n\r\n  return {\r\n    subscribe,\r\n    getSnapshot,\r\n    observe,\r\n    unobserve,\r\n  };\r\n}\r\n\r\nconst resizeObserverStore = createResizeObserverStore();\r\n\r\nfunction useResizeObserverStore(\r\n  rootRef: React.RefObject<RootElement | null>,\r\n  contentRef: React.RefObject<ContentElement | null>,\r\n  orientation: Orientation,\r\n) {\r\n  const onSubscribe = React.useCallback(\r\n    (callback: () => void) => resizeObserverStore.subscribe(callback),\r\n    [],\r\n  );\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () =>\r\n      resizeObserverStore.getSnapshot(\r\n        rootRef.current,\r\n        contentRef.current,\r\n        orientation,\r\n      ),\r\n    [rootRef, contentRef, orientation],\r\n  );\r\n\r\n  return React.useSyncExternalStore(onSubscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ninterface MarqueeContextValue {\r\n  side: Side;\r\n  orientation: Orientation;\r\n  dir: Direction;\r\n  speed: number;\r\n  loopCount: number;\r\n  contentRef: React.RefObject<ContentElement | null>;\r\n  rootRef: React.RefObject<RootElement | null>;\r\n  autoFill: boolean;\r\n  pauseOnHover: boolean;\r\n  pauseOnKeyboard: boolean;\r\n  reverse: boolean;\r\n  paused: boolean;\r\n}\r\n\r\nconst MarqueeContext = React.createContext<MarqueeContextValue | null>(null);\r\n\r\nfunction useMarqueeContext(consumerName: string) {\r\n  const context = React.useContext(MarqueeContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface MarqueeProps extends DivProps {\r\n  side?: Side;\r\n  dir?: Direction;\r\n  speed?: number;\r\n  delay?: number;\r\n  loopCount?: number;\r\n  gap?: string | number;\r\n  autoFill?: boolean;\r\n  pauseOnHover?: boolean;\r\n  pauseOnKeyboard?: boolean;\r\n  reverse?: boolean;\r\n}\r\n\r\nfunction Marquee(props: MarqueeProps) {\r\n  const {\r\n    side = \"left\",\r\n    dir: dirProp,\r\n    speed = 50,\r\n    delay = 0,\r\n    loopCount = 0,\r\n    gap = \"1rem\",\r\n    asChild,\r\n    autoFill = false,\r\n    pauseOnHover = false,\r\n    pauseOnKeyboard = false,\r\n    reverse = false,\r\n    className,\r\n    style: styleProp,\r\n    ref,\r\n    ...marqueeProps\r\n  } = props;\r\n\r\n  const orientation: Orientation =\r\n    side === \"top\" || side === \"bottom\" ? \"vertical\" : \"horizontal\";\r\n\r\n  const dir = DirectionPrimitive.useDirection(dirProp);\r\n\r\n  const rootRef = React.useRef<RootElement>(null);\r\n  const contentRef = React.useRef<ContentElement>(null);\r\n  const composedRef = useComposedRefs(ref, rootRef);\r\n\r\n  const [paused, setPaused] = React.useState(false);\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent) => {\r\n      if (pauseOnKeyboard && event.key === \" \") {\r\n        event.preventDefault();\r\n        setPaused((prev) => !prev);\r\n      }\r\n    },\r\n    [pauseOnKeyboard],\r\n  );\r\n\r\n  const dimensions = useResizeObserverStore(rootRef, contentRef, orientation);\r\n\r\n  const duration = React.useMemo(() => {\r\n    const safeSpeed = Math.max(0.001, speed);\r\n\r\n    if (!dimensions) {\r\n      const defaultDistance = autoFill ? 1000 : 2000;\r\n      return defaultDistance / safeSpeed;\r\n    }\r\n\r\n    const { rootSize, contentSize } = dimensions;\r\n\r\n    if (autoFill) {\r\n      const multiplier =\r\n        contentSize < rootSize ? Math.ceil(rootSize / contentSize) : 1;\r\n      return (contentSize * multiplier) / safeSpeed;\r\n    } else {\r\n      return contentSize < rootSize\r\n        ? rootSize / safeSpeed\r\n        : contentSize / safeSpeed;\r\n    }\r\n  }, [dimensions, speed, autoFill]);\r\n\r\n  const style = React.useMemo<React.CSSProperties>(\r\n    () => ({\r\n      \"--marquee-duration\": `${duration}s`,\r\n      \"--marquee-gap\": gap,\r\n      \"--marquee-delay\": `${delay}s`,\r\n      \"--marquee-loop-count\":\r\n        loopCount === 0 || loopCount === Infinity\r\n          ? \"infinite\"\r\n          : loopCount.toString(),\r\n      ...styleProp,\r\n    }),\r\n    [duration, gap, delay, loopCount, styleProp],\r\n  );\r\n\r\n  const contextValue = React.useMemo<MarqueeContextValue>(\r\n    () => ({\r\n      side,\r\n      orientation,\r\n      dir,\r\n      speed,\r\n      loopCount,\r\n      contentRef,\r\n      rootRef,\r\n      autoFill,\r\n      paused,\r\n      pauseOnHover,\r\n      pauseOnKeyboard,\r\n      reverse,\r\n    }),\r\n    [\r\n      side,\r\n      orientation,\r\n      dir,\r\n      speed,\r\n      loopCount,\r\n      autoFill,\r\n      paused,\r\n      pauseOnHover,\r\n      pauseOnKeyboard,\r\n      reverse,\r\n    ],\r\n  );\r\n\r\n  const MarqueePrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <MarqueeContext.Provider value={contextValue}>\r\n      <div data-slot=\"marquee-wrapper\" className=\"grid\">\r\n        <MarqueePrimitive\r\n          role=\"marquee\"\r\n          aria-live=\"off\"\r\n          data-orientation={orientation}\r\n          data-slot=\"marquee\"\r\n          dir={dir}\r\n          tabIndex={pauseOnKeyboard ? 0 : undefined}\r\n          {...marqueeProps}\r\n          ref={composedRef}\r\n          className={cn(\r\n            \"relative flex overflow-hidden motion-reduce:animate-none\",\r\n            orientation === \"vertical\" && \"h-full flex-col\",\r\n            orientation === \"horizontal\" && \"w-full\",\r\n            paused && \"[&_*]:[animation-play-state:paused]\",\r\n            pauseOnHover && \"group\",\r\n            pauseOnKeyboard &&\r\n              \"rounded-md focus-visible:border-ring focus-visible:outline-none focus-visible:ring-[3px] focus-visible:ring-ring/50\",\r\n            className,\r\n          )}\r\n          style={style}\r\n          onKeyDown={pauseOnKeyboard ? onKeyDown : undefined}\r\n        />\r\n      </div>\r\n    </MarqueeContext.Provider>\r\n  );\r\n}\r\n\r\nconst marqueeContentVariants = cva(\r\n  \"flex min-w-full shrink-0 gap-(--marquee-gap)\",\r\n  {\r\n    variants: {\r\n      side: {\r\n        left: \"animate-marquee-left\",\r\n        right: \"animate-marquee-right\",\r\n        top: \"min-h-full min-w-auto animate-marquee-up flex-col\",\r\n        bottom: \"min-h-full min-w-auto animate-marquee-down flex-col\",\r\n      },\r\n      dir: {\r\n        ltr: \"\",\r\n        rtl: \"\",\r\n      },\r\n      pauseOnHover: {\r\n        true: \"group-hover:[animation-play-state:paused]\",\r\n        false: \"\",\r\n      },\r\n      reverse: {\r\n        true: \"[animation-direction:reverse]\",\r\n        false: \"\",\r\n      },\r\n    },\r\n    compoundVariants: [\r\n      {\r\n        side: \"left\",\r\n        dir: \"rtl\",\r\n        className: \"animate-marquee-left-rtl\",\r\n      },\r\n      {\r\n        side: \"right\",\r\n        dir: \"rtl\",\r\n        className: \"animate-marquee-right-rtl\",\r\n      },\r\n    ],\r\n    defaultVariants: {\r\n      side: \"left\",\r\n      dir: \"ltr\",\r\n      pauseOnHover: false,\r\n      reverse: false,\r\n    },\r\n  },\r\n);\r\n\r\nfunction MarqueeContent(props: DivProps) {\r\n  const {\r\n    className,\r\n    asChild,\r\n    ref,\r\n    children,\r\n    style: styleProp,\r\n    ...contentProps\r\n  } = props;\r\n\r\n  const context = useMarqueeContext(CONTENT_NAME);\r\n  const composedRef = useComposedRefs(ref, context.contentRef);\r\n\r\n  const isVertical = context.orientation === \"vertical\";\r\n  const isRtl = context.dir === \"rtl\";\r\n\r\n  const dimensions = useResizeObserverStore(\r\n    context.rootRef,\r\n    context.contentRef,\r\n    context.orientation,\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (context.rootRef.current && context.contentRef.current) {\r\n      resizeObserverStore.observe(\r\n        context.rootRef.current,\r\n        context.contentRef.current,\r\n      );\r\n\r\n      return () => {\r\n        resizeObserverStore.unobserve(\r\n          context.rootRef.current,\r\n          context.contentRef.current,\r\n        );\r\n      };\r\n    }\r\n  }, [context.rootRef, context.contentRef]);\r\n\r\n  const multiplier = React.useMemo(() => {\r\n    if (!context.autoFill || !dimensions) return 1;\r\n\r\n    const { rootSize, contentSize } = dimensions;\r\n    if (contentSize === 0) return 1;\r\n\r\n    return contentSize < rootSize ? Math.ceil(rootSize / contentSize) : 1;\r\n  }, [context.autoFill, dimensions]);\r\n\r\n  const onMultipliedChildrenRender = React.useCallback(\r\n    (count: number) => {\r\n      return Array.from({ length: Math.max(0, count) }).map((_, i) => (\r\n        <React.Fragment key={i}>{children}</React.Fragment>\r\n      ));\r\n    },\r\n    [children],\r\n  );\r\n\r\n  const style = React.useMemo(\r\n    () => ({\r\n      ...styleProp,\r\n      animationDuration: \"var(--marquee-duration)\",\r\n      animationDelay: \"var(--marquee-delay)\",\r\n      animationIterationCount: \"var(--marquee-loop-count)\",\r\n      animationDirection: context.reverse ? \"reverse\" : \"normal\",\r\n    }),\r\n    [styleProp, context.reverse],\r\n  );\r\n\r\n  const ContentPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <>\r\n      <ContentPrimitive\r\n        data-orientation={context.orientation}\r\n        data-slot=\"marquee-content\"\r\n        {...contentProps}\r\n        style={style}\r\n        className={cn(\r\n          marqueeContentVariants({\r\n            side: context.side,\r\n            dir: context.dir,\r\n            pauseOnHover: context.pauseOnHover,\r\n            reverse: context.reverse,\r\n            className,\r\n          }),\r\n          isVertical && \"flex-col\",\r\n          isVertical\r\n            ? \"mb-(--marquee-gap)\"\r\n            : isRtl\r\n              ? \"ml-(--marquee-gap)\"\r\n              : \"mr-(--marquee-gap)\",\r\n        )}\r\n      >\r\n        <div\r\n          ref={composedRef}\r\n          className={cn(\r\n            \"flex shrink-0 gap-(--marquee-gap)\",\r\n            isVertical && \"flex-col\",\r\n          )}\r\n        >\r\n          {children}\r\n        </div>\r\n        {onMultipliedChildrenRender(multiplier - 1)}\r\n      </ContentPrimitive>\r\n      <ContentPrimitive\r\n        role=\"presentation\"\r\n        aria-hidden=\"true\"\r\n        {...contentProps}\r\n        style={style}\r\n        className={cn(\r\n          marqueeContentVariants({\r\n            side: context.side,\r\n            dir: context.dir,\r\n            pauseOnHover: context.pauseOnHover,\r\n            reverse: context.reverse,\r\n            className,\r\n          }),\r\n          isVertical && \"flex-col\",\r\n        )}\r\n      >\r\n        {onMultipliedChildrenRender(multiplier)}\r\n      </ContentPrimitive>\r\n    </>\r\n  );\r\n}\r\n\r\nfunction MarqueeItem(props: DivProps) {\r\n  const { className, asChild, ...itemProps } = props;\r\n\r\n  const ItemPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <ItemPrimitive\r\n      data-slot=\"marquee-item\"\r\n      {...itemProps}\r\n      className={cn(\"shrink-0\", className)}\r\n    />\r\n  );\r\n}\r\n\r\nconst marqueeEdgeVariants = cva(\"pointer-events-none absolute z-10\", {\r\n  variants: {\r\n    side: {\r\n      left: \"top-0 left-0 h-full bg-gradient-to-r from-background to-transparent\",\r\n      right:\r\n        \"top-0 right-0 h-full bg-gradient-to-l from-background to-transparent\",\r\n      top: \"top-0 left-0 w-full bg-gradient-to-b from-background to-transparent\",\r\n      bottom:\r\n        \"bottom-0 left-0 w-full bg-gradient-to-t from-background to-transparent\",\r\n    },\r\n    size: {\r\n      default: \"\",\r\n      sm: \"\",\r\n      lg: \"\",\r\n    },\r\n  },\r\n  compoundVariants: [\r\n    {\r\n      side: [\"left\", \"right\"],\r\n      size: \"default\",\r\n      className: \"w-1/4\",\r\n    },\r\n    {\r\n      side: [\"left\", \"right\"],\r\n      size: \"sm\",\r\n      className: \"w-1/6\",\r\n    },\r\n    {\r\n      side: [\"left\", \"right\"],\r\n      size: \"lg\",\r\n      className: \"w-1/3\",\r\n    },\r\n    {\r\n      side: [\"top\", \"bottom\"],\r\n      size: \"default\",\r\n      className: \"h-1/4\",\r\n    },\r\n    {\r\n      side: [\"top\", \"bottom\"],\r\n      size: \"sm\",\r\n      className: \"h-1/6\",\r\n    },\r\n    {\r\n      side: [\"top\", \"bottom\"],\r\n      size: \"lg\",\r\n      className: \"h-1/3\",\r\n    },\r\n  ],\r\n  defaultVariants: {\r\n    size: \"default\",\r\n  },\r\n});\r\n\r\ninterface MarqueeEdgeProps\r\n  extends VariantProps<typeof marqueeEdgeVariants>,\r\n    DivProps {}\r\n\r\nfunction MarqueeEdge(props: MarqueeEdgeProps) {\r\n  const { side, size, className, asChild, ...edgeProps } = props;\r\n\r\n  const EdgePrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <EdgePrimitive\r\n      data-size={size}\r\n      data-slot=\"marquee-edge\"\r\n      {...edgeProps}\r\n      className={cn(marqueeEdgeVariants({ side, size, className }))}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  Marquee,\r\n  MarqueeContent,\r\n  MarqueeItem,\r\n  MarqueeEdge,\r\n  //\r\n  type MarqueeProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "cssVars": {
    "theme": {
      "--animate-marquee-left": "marquee-left var(--marquee-duration) linear var(--marquee-loop-count)",
      "--animate-marquee-right": "marquee-right var(--marquee-duration) linear var(--marquee-loop-count)",
      "--animate-marquee-left-rtl": "marquee-left-rtl var(--marquee-duration) linear var(--marquee-loop-count)",
      "--animate-marquee-right-rtl": "marquee-right-rtl var(--marquee-duration) linear var(--marquee-loop-count)",
      "--animate-marquee-up": "marquee-up var(--marquee-duration) linear var(--marquee-loop-count)",
      "--animate-marquee-down": "marquee-down var(--marquee-duration) linear var(--marquee-loop-count)"
    }
  },
  "css": {
    "@keyframes marquee-left": {
      "0%": {
        "transform": "translateX(0%)"
      },
      "100%": {
        "transform": "translateX(calc(-100% - var(--marquee-gap)))"
      }
    },
    "@keyframes marquee-right": {
      "0%": {
        "transform": "translateX(calc(-100% - var(--marquee-gap)))"
      },
      "100%": {
        "transform": "translateX(0%)"
      }
    },
    "@keyframes marquee-up": {
      "0%": {
        "transform": "translateY(0%)"
      },
      "100%": {
        "transform": "translateY(calc(-100% - var(--marquee-gap)))"
      }
    },
    "@keyframes marquee-down": {
      "0%": {
        "transform": "translateY(calc(-100% - var(--marquee-gap)))"
      },
      "100%": {
        "transform": "translateY(0%)"
      }
    },
    "@keyframes marquee-left-rtl": {
      "0%": {
        "transform": "translateX(0%)"
      },
      "100%": {
        "transform": "translateX(calc(100% + var(--marquee-gap)))"
      }
    },
    "@keyframes marquee-right-rtl": {
      "0%": {
        "transform": "translateX(calc(100% + var(--marquee-gap)))"
      },
      "100%": {
        "transform": "translateX(0%)"
      }
    }
  },
  "type": "registry:ui"
}