{
  "name": "masonry",
  "dependencies": [
    "@diceui/masonry",
    "radix-ui"
  ],
  "registryDependencies": [
    "@diceui/use-isomorphic-layout-effect"
  ],
  "files": [
    {
      "path": "ui/masonry.tsx",
      "content": "\"use client\";\r\n\r\nimport { Slot as SlotPrimitive } from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\n\r\nconst NODE_COLOR = {\r\n  RED: 0,\r\n  BLACK: 1,\r\n  SENTINEL: 2,\r\n} as const;\r\n\r\nconst NODE_OPERATION = {\r\n  REMOVE: 0,\r\n  PRESERVE: 1,\r\n} as const;\r\n\r\ntype NodeColor = (typeof NODE_COLOR)[keyof typeof NODE_COLOR];\r\ntype NodeOperation = (typeof NODE_OPERATION)[keyof typeof NODE_OPERATION];\r\n\r\ninterface ListNode {\r\n  index: number;\r\n  high: number;\r\n  next: ListNode | null;\r\n}\r\n\r\ninterface TreeNode {\r\n  max: number;\r\n  low: number;\r\n  high: number;\r\n  color: NodeColor;\r\n  parent: TreeNode;\r\n  right: TreeNode;\r\n  left: TreeNode;\r\n  list: ListNode;\r\n}\r\n\r\ninterface Tree {\r\n  root: TreeNode;\r\n  size: number;\r\n}\r\n\r\nfunction addInterval(treeNode: TreeNode, high: number, index: number): boolean {\r\n  let node: ListNode | null = treeNode.list;\r\n  let prevNode: ListNode | undefined;\r\n\r\n  while (node) {\r\n    if (node.index === index) return false;\r\n    if (high > node.high) break;\r\n    prevNode = node;\r\n    node = node.next;\r\n  }\r\n\r\n  if (!prevNode) treeNode.list = { index, high, next: node };\r\n  if (prevNode) prevNode.next = { index, high, next: prevNode.next };\r\n\r\n  return true;\r\n}\r\n\r\nfunction removeInterval(\r\n  treeNode: TreeNode,\r\n  index: number,\r\n): NodeOperation | undefined {\r\n  let node: ListNode | null = treeNode.list;\r\n  if (node.index === index) {\r\n    if (node.next === null) return NODE_OPERATION.REMOVE;\r\n    treeNode.list = node.next;\r\n    return NODE_OPERATION.PRESERVE;\r\n  }\r\n\r\n  let prevNode: ListNode | undefined = node;\r\n  node = node.next;\r\n\r\n  while (node !== null) {\r\n    if (node.index === index) {\r\n      prevNode.next = node.next;\r\n      return NODE_OPERATION.PRESERVE;\r\n    }\r\n    prevNode = node;\r\n    node = node.next;\r\n  }\r\n}\r\n\r\nconst SENTINEL_NODE: TreeNode = {\r\n  low: 0,\r\n  max: 0,\r\n  high: 0,\r\n  color: NODE_COLOR.SENTINEL,\r\n  parent: undefined as unknown as TreeNode,\r\n  right: undefined as unknown as TreeNode,\r\n  left: undefined as unknown as TreeNode,\r\n  list: undefined as unknown as ListNode,\r\n};\r\n\r\nSENTINEL_NODE.parent = SENTINEL_NODE;\r\nSENTINEL_NODE.left = SENTINEL_NODE;\r\nSENTINEL_NODE.right = SENTINEL_NODE;\r\n\r\nfunction updateMax(node: TreeNode) {\r\n  const max = node.high;\r\n  if (node.left === SENTINEL_NODE && node.right === SENTINEL_NODE)\r\n    node.max = max;\r\n  else if (node.left === SENTINEL_NODE)\r\n    node.max = Math.max(node.right.max, max);\r\n  else if (node.right === SENTINEL_NODE)\r\n    node.max = Math.max(node.left.max, max);\r\n  else node.max = Math.max(Math.max(node.left.max, node.right.max), max);\r\n}\r\n\r\nfunction updateMaxUp(node: TreeNode) {\r\n  let x = node;\r\n\r\n  while (x.parent !== SENTINEL_NODE) {\r\n    updateMax(x.parent);\r\n    x = x.parent;\r\n  }\r\n}\r\n\r\nfunction rotateLeft(tree: Tree, x: TreeNode) {\r\n  if (x.right === SENTINEL_NODE) return;\r\n  const y = x.right;\r\n  x.right = y.left;\r\n  if (y.left !== SENTINEL_NODE) y.left.parent = x;\r\n  y.parent = x.parent;\r\n\r\n  if (x.parent === SENTINEL_NODE) tree.root = y;\r\n  else if (x === x.parent.left) x.parent.left = y;\r\n  else x.parent.right = y;\r\n\r\n  y.left = x;\r\n  x.parent = y;\r\n\r\n  updateMax(x);\r\n  updateMax(y);\r\n}\r\n\r\nfunction rotateRight(tree: Tree, x: TreeNode) {\r\n  if (x.left === SENTINEL_NODE) return;\r\n  const y = x.left;\r\n  x.left = y.right;\r\n  if (y.right !== SENTINEL_NODE) y.right.parent = x;\r\n  y.parent = x.parent;\r\n\r\n  if (x.parent === SENTINEL_NODE) tree.root = y;\r\n  else if (x === x.parent.right) x.parent.right = y;\r\n  else x.parent.left = y;\r\n\r\n  y.right = x;\r\n  x.parent = y;\r\n\r\n  updateMax(x);\r\n  updateMax(y);\r\n}\r\n\r\nfunction replaceNode(tree: Tree, x: TreeNode, y: TreeNode) {\r\n  if (x.parent === SENTINEL_NODE) tree.root = y;\r\n  else if (x === x.parent.left) x.parent.left = y;\r\n  else x.parent.right = y;\r\n  y.parent = x.parent;\r\n}\r\n\r\nfunction fixRemove(tree: Tree, node: TreeNode) {\r\n  let x = node;\r\n  let w: TreeNode;\r\n\r\n  while (x !== SENTINEL_NODE && x.color === NODE_COLOR.BLACK) {\r\n    if (x === x.parent.left) {\r\n      w = x.parent.right;\r\n\r\n      if (w.color === NODE_COLOR.RED) {\r\n        w.color = NODE_COLOR.BLACK;\r\n        x.parent.color = NODE_COLOR.RED;\r\n        rotateLeft(tree, x.parent);\r\n        w = x.parent.right;\r\n      }\r\n\r\n      if (\r\n        w.left.color === NODE_COLOR.BLACK &&\r\n        w.right.color === NODE_COLOR.BLACK\r\n      ) {\r\n        w.color = NODE_COLOR.RED;\r\n        x = x.parent;\r\n      } else {\r\n        if (w.right.color === NODE_COLOR.BLACK) {\r\n          w.left.color = NODE_COLOR.BLACK;\r\n          w.color = NODE_COLOR.RED;\r\n          rotateRight(tree, w);\r\n          w = x.parent.right;\r\n        }\r\n\r\n        w.color = x.parent.color;\r\n        x.parent.color = NODE_COLOR.BLACK;\r\n        w.right.color = NODE_COLOR.BLACK;\r\n        rotateLeft(tree, x.parent);\r\n        x = tree.root;\r\n      }\r\n    } else {\r\n      w = x.parent.left;\r\n\r\n      if (w.color === NODE_COLOR.RED) {\r\n        w.color = NODE_COLOR.BLACK;\r\n        x.parent.color = NODE_COLOR.RED;\r\n        rotateRight(tree, x.parent);\r\n        w = x.parent.left;\r\n      }\r\n\r\n      if (\r\n        w.right.color === NODE_COLOR.BLACK &&\r\n        w.left.color === NODE_COLOR.BLACK\r\n      ) {\r\n        w.color = NODE_COLOR.RED;\r\n        x = x.parent;\r\n      } else {\r\n        if (w.left.color === NODE_COLOR.BLACK) {\r\n          w.right.color = NODE_COLOR.BLACK;\r\n          w.color = NODE_COLOR.RED;\r\n          rotateLeft(tree, w);\r\n          w = x.parent.left;\r\n        }\r\n\r\n        w.color = x.parent.color;\r\n        x.parent.color = NODE_COLOR.BLACK;\r\n        w.left.color = NODE_COLOR.BLACK;\r\n        rotateRight(tree, x.parent);\r\n        x = tree.root;\r\n      }\r\n    }\r\n  }\r\n\r\n  x.color = NODE_COLOR.BLACK;\r\n}\r\n\r\nfunction minimumTree(node: TreeNode) {\r\n  let current = node;\r\n  while (current.left !== SENTINEL_NODE) {\r\n    current = current.left;\r\n  }\r\n  return current;\r\n}\r\n\r\nfunction fixInsert(tree: Tree, node: TreeNode) {\r\n  let current = node;\r\n  let y: TreeNode;\r\n\r\n  while (current.parent.color === NODE_COLOR.RED) {\r\n    if (current.parent === current.parent.parent.left) {\r\n      y = current.parent.parent.right;\r\n\r\n      if (y.color === NODE_COLOR.RED) {\r\n        current.parent.color = NODE_COLOR.BLACK;\r\n        y.color = NODE_COLOR.BLACK;\r\n        current.parent.parent.color = NODE_COLOR.RED;\r\n        current = current.parent.parent;\r\n      } else {\r\n        if (current === current.parent.right) {\r\n          current = current.parent;\r\n          rotateLeft(tree, current);\r\n        }\r\n\r\n        current.parent.color = NODE_COLOR.BLACK;\r\n        current.parent.parent.color = NODE_COLOR.RED;\r\n        rotateRight(tree, current.parent.parent);\r\n      }\r\n    } else {\r\n      y = current.parent.parent.left;\r\n\r\n      if (y.color === NODE_COLOR.RED) {\r\n        current.parent.color = NODE_COLOR.BLACK;\r\n        y.color = NODE_COLOR.BLACK;\r\n        current.parent.parent.color = NODE_COLOR.RED;\r\n        current = current.parent.parent;\r\n      } else {\r\n        if (current === current.parent.left) {\r\n          current = current.parent;\r\n          rotateRight(tree, current);\r\n        }\r\n\r\n        current.parent.color = NODE_COLOR.BLACK;\r\n        current.parent.parent.color = NODE_COLOR.RED;\r\n        rotateLeft(tree, current.parent.parent);\r\n      }\r\n    }\r\n  }\r\n  tree.root.color = NODE_COLOR.BLACK;\r\n}\r\n\r\ninterface IntervalTree {\r\n  insert(low: number, high: number, index: number): void;\r\n  remove(index: number): void;\r\n  search(\r\n    low: number,\r\n    high: number,\r\n    onCallback: (index: number, low: number) => void,\r\n  ): void;\r\n  size: number;\r\n}\r\n\r\nfunction createIntervalTree(): IntervalTree {\r\n  const tree: Tree = {\r\n    root: SENTINEL_NODE,\r\n    size: 0,\r\n  };\r\n\r\n  const indexMap: Record<number, TreeNode> = {};\r\n\r\n  return {\r\n    insert(low, high, index) {\r\n      let x: TreeNode = tree.root;\r\n      let y: TreeNode = SENTINEL_NODE;\r\n\r\n      while (x !== SENTINEL_NODE) {\r\n        y = x;\r\n        if (low === y.low) break;\r\n        if (low < x.low) x = x.left;\r\n        else x = x.right;\r\n      }\r\n\r\n      if (low === y.low && y !== SENTINEL_NODE) {\r\n        if (!addInterval(y, high, index)) return;\r\n        y.high = Math.max(y.high, high);\r\n        updateMax(y);\r\n        updateMaxUp(y);\r\n        indexMap[index] = y;\r\n        tree.size++;\r\n        return;\r\n      }\r\n\r\n      const z: TreeNode = {\r\n        low,\r\n        high,\r\n        max: high,\r\n        color: NODE_COLOR.RED,\r\n        parent: y,\r\n        left: SENTINEL_NODE,\r\n        right: SENTINEL_NODE,\r\n        list: { index, high, next: null },\r\n      };\r\n\r\n      if (y === SENTINEL_NODE) {\r\n        tree.root = z;\r\n      } else {\r\n        if (z.low < y.low) y.left = z;\r\n        else y.right = z;\r\n        updateMaxUp(z);\r\n      }\r\n\r\n      fixInsert(tree, z);\r\n      indexMap[index] = z;\r\n      tree.size++;\r\n    },\r\n\r\n    remove(index) {\r\n      const z = indexMap[index];\r\n      if (z === void 0) return;\r\n      delete indexMap[index];\r\n\r\n      const intervalResult = removeInterval(z, index);\r\n      if (intervalResult === void 0) return;\r\n      if (intervalResult === NODE_OPERATION.PRESERVE) {\r\n        z.high = z.list.high;\r\n        updateMax(z);\r\n        updateMaxUp(z);\r\n        tree.size--;\r\n        return;\r\n      }\r\n\r\n      let y = z;\r\n      let originalYColor = y.color;\r\n      let x: TreeNode;\r\n\r\n      if (z.left === SENTINEL_NODE) {\r\n        x = z.right;\r\n        replaceNode(tree, z, z.right);\r\n      } else if (z.right === SENTINEL_NODE) {\r\n        x = z.left;\r\n        replaceNode(tree, z, z.left);\r\n      } else {\r\n        y = minimumTree(z.right);\r\n        originalYColor = y.color;\r\n        x = y.right;\r\n\r\n        if (y.parent === z) {\r\n          x.parent = y;\r\n        } else {\r\n          replaceNode(tree, y, y.right);\r\n          y.right = z.right;\r\n          y.right.parent = y;\r\n        }\r\n\r\n        replaceNode(tree, z, y);\r\n        y.left = z.left;\r\n        y.left.parent = y;\r\n        y.color = z.color;\r\n      }\r\n\r\n      updateMax(x);\r\n      updateMaxUp(x);\r\n\r\n      if (originalYColor === NODE_COLOR.BLACK) fixRemove(tree, x);\r\n      tree.size--;\r\n    },\r\n\r\n    search(low, high, onCallback) {\r\n      const stack = [tree.root];\r\n      while (stack.length !== 0) {\r\n        const node = stack.pop();\r\n        if (!node) continue;\r\n        if (node === SENTINEL_NODE || low > node.max) continue;\r\n        if (node.left !== SENTINEL_NODE) stack.push(node.left);\r\n        if (node.right !== SENTINEL_NODE) stack.push(node.right);\r\n        if (node.low <= high && node.high >= low) {\r\n          let curr: ListNode | null = node.list;\r\n          while (curr !== null) {\r\n            if (curr.high >= low) onCallback(curr.index, node.low);\r\n            curr = curr.next;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    get size() {\r\n      return tree.size;\r\n    },\r\n  };\r\n}\r\n\r\ntype CacheKey = string | number | symbol;\r\ntype CacheConstructor = (new () => Cache) | Record<CacheKey, unknown>;\r\n\r\ninterface Cache<K = CacheKey, V = unknown> {\r\n  set: (k: K, v: V) => V;\r\n  get: (k: K) => V | undefined;\r\n}\r\n\r\nfunction onDeepMemo<T extends unknown[], U>(\r\n  constructors: CacheConstructor[],\r\n  fn: (...args: T) => U,\r\n): (...args: T) => U {\r\n  if (!constructors.length || !constructors[0]) {\r\n    throw new Error(\"At least one constructor is required\");\r\n  }\r\n\r\n  function createCache(obj: CacheConstructor): Cache {\r\n    let cache: Cache;\r\n    if (typeof obj === \"function\") {\r\n      try {\r\n        cache = new (obj as new () => Cache)();\r\n      } catch (_err) {\r\n        cache = new Map<CacheKey, unknown>();\r\n      }\r\n    } else {\r\n      cache = obj as unknown as Cache;\r\n    }\r\n    return {\r\n      set(k: CacheKey, v: unknown): unknown {\r\n        cache.set(k, v);\r\n        return v;\r\n      },\r\n      get(k: CacheKey): unknown | undefined {\r\n        return cache.get(k);\r\n      },\r\n    };\r\n  }\r\n\r\n  const depth = constructors.length;\r\n  const baseCache = createCache(constructors[0]);\r\n\r\n  let base: Cache | undefined;\r\n  let map: Cache | undefined;\r\n  let node: Cache;\r\n  let i: number;\r\n  const one = depth === 1;\r\n\r\n  function get(args: unknown[]): unknown {\r\n    if (depth < 3) {\r\n      const key = args[0] as CacheKey;\r\n      base = baseCache.get(key) as Cache | undefined;\r\n      return one ? base : base?.get(args[1] as CacheKey);\r\n    }\r\n\r\n    node = baseCache;\r\n    for (i = 0; i < depth; i++) {\r\n      const next = node.get(args[i] as CacheKey);\r\n      if (!next) return undefined;\r\n      node = next as Cache;\r\n    }\r\n    return node;\r\n  }\r\n\r\n  function set(args: unknown[], value: unknown): unknown {\r\n    if (depth < 3) {\r\n      if (one) {\r\n        baseCache.set(args[0] as CacheKey, value);\r\n      } else {\r\n        base = baseCache.get(args[0] as CacheKey) as Cache | undefined;\r\n        if (!base) {\r\n          if (!constructors[1]) {\r\n            throw new Error(\r\n              \"Second constructor is required for non-single depth cache\",\r\n            );\r\n          }\r\n          map = createCache(constructors[1]);\r\n          map.set(args[1] as CacheKey, value);\r\n          baseCache.set(args[0] as CacheKey, map);\r\n        } else {\r\n          base.set(args[1] as CacheKey, value);\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n\r\n    node = baseCache;\r\n    for (i = 0; i < depth - 1; i++) {\r\n      map = node.get(args[i] as CacheKey) as Cache | undefined;\r\n      if (!map) {\r\n        const nextConstructor = constructors[i + 1];\r\n        if (!nextConstructor) {\r\n          throw new Error(`Constructor at index ${i + 1} is required`);\r\n        }\r\n        map = createCache(nextConstructor);\r\n        node.set(args[i] as CacheKey, map);\r\n        node = map;\r\n      } else {\r\n        node = map;\r\n      }\r\n    }\r\n    node.set(args[depth - 1] as CacheKey, value);\r\n    return value;\r\n  }\r\n\r\n  return (...args: T): U => {\r\n    const cached = get(args);\r\n    if (cached === undefined) {\r\n      return set(args, fn(...args)) as U;\r\n    }\r\n    return cached as U;\r\n  };\r\n}\r\n\r\nconst COLUMN_WIDTH = 200;\r\nconst GAP = 0;\r\nconst ITEM_HEIGHT = 300;\r\nconst OVERSCAN = 2;\r\nconst SCROLL_FPS = 12;\r\nconst DEBOUNCE_DELAY = 300;\r\n\r\ninterface Positioner {\r\n  columnCount: number;\r\n  columnWidth: number;\r\n  set: (index: number, height: number) => void;\r\n  get: (index: number) => PositionerItem | undefined;\r\n  update: (updates: number[]) => void;\r\n  range: (\r\n    low: number,\r\n    high: number,\r\n    onItemRender: (index: number, left: number, top: number) => void,\r\n  ) => void;\r\n  size: () => number;\r\n  estimateHeight: (itemCount: number, defaultItemHeight: number) => number;\r\n  shortestColumn: () => number;\r\n  all: () => PositionerItem[];\r\n}\r\n\r\ninterface PositionerItem {\r\n  top: number;\r\n  left: number;\r\n  height: number;\r\n  columnIndex: number;\r\n}\r\n\r\ninterface UsePositionerOptions {\r\n  width: number;\r\n  columnWidth?: number;\r\n  columnGap?: number;\r\n  rowGap?: number;\r\n  columnCount?: number;\r\n  maxColumnCount?: number;\r\n  linear?: boolean;\r\n}\r\n\r\nfunction usePositioner(\r\n  {\r\n    width,\r\n    columnWidth = COLUMN_WIDTH,\r\n    columnGap = GAP,\r\n    rowGap,\r\n    columnCount,\r\n    maxColumnCount,\r\n    linear = false,\r\n  }: UsePositionerOptions,\r\n  deps: React.DependencyList = [],\r\n): Positioner {\r\n  const initPositioner = React.useCallback((): Positioner => {\r\n    function binarySearch(a: number[], y: number): number {\r\n      let l = 0;\r\n      let h = a.length - 1;\r\n\r\n      while (l <= h) {\r\n        const m = (l + h) >>> 1;\r\n        const x = a[m];\r\n        if (x === y) return m;\r\n        if (x === undefined || x <= y) l = m + 1;\r\n        else h = m - 1;\r\n      }\r\n\r\n      return -1;\r\n    }\r\n\r\n    const computedColumnCount =\r\n      columnCount ||\r\n      Math.min(\r\n        Math.floor((width + columnGap) / (columnWidth + columnGap)),\r\n        maxColumnCount || Number.POSITIVE_INFINITY,\r\n      ) ||\r\n      1;\r\n    const computedColumnWidth = Math.floor(\r\n      (width - columnGap * (computedColumnCount - 1)) / computedColumnCount,\r\n    );\r\n\r\n    const intervalTree = createIntervalTree();\r\n    const columnHeights: number[] = new Array(computedColumnCount).fill(0);\r\n    const items: (PositionerItem | undefined)[] = [];\r\n    const columnItems: number[][] = new Array(computedColumnCount)\r\n      .fill(0)\r\n      .map(() => []);\r\n\r\n    for (let i = 0; i < computedColumnCount; i++) {\r\n      columnHeights[i] = 0;\r\n      columnItems[i] = [];\r\n    }\r\n\r\n    return {\r\n      columnCount: computedColumnCount,\r\n      columnWidth: computedColumnWidth,\r\n      set: (index: number, height = 0) => {\r\n        let columnIndex = 0;\r\n\r\n        if (linear) {\r\n          const preferredColumn = index % computedColumnCount;\r\n\r\n          let shortestHeight = columnHeights[0] ?? 0;\r\n          let tallestHeight = shortestHeight;\r\n          let shortestIndex = 0;\r\n\r\n          for (let i = 0; i < columnHeights.length; i++) {\r\n            const currentHeight = columnHeights[i] ?? 0;\r\n            if (currentHeight < shortestHeight) {\r\n              shortestHeight = currentHeight;\r\n              shortestIndex = i;\r\n            }\r\n            if (currentHeight > tallestHeight) {\r\n              tallestHeight = currentHeight;\r\n            }\r\n          }\r\n\r\n          const preferredHeight =\r\n            (columnHeights[preferredColumn] ?? 0) + height;\r\n\r\n          const maxAllowedHeight = shortestHeight + height * 2.5;\r\n          columnIndex =\r\n            preferredHeight <= maxAllowedHeight\r\n              ? preferredColumn\r\n              : shortestIndex;\r\n        } else {\r\n          for (let i = 1; i < columnHeights.length; i++) {\r\n            const currentHeight = columnHeights[i];\r\n            const shortestHeight = columnHeights[columnIndex];\r\n            if (\r\n              currentHeight !== undefined &&\r\n              shortestHeight !== undefined &&\r\n              currentHeight < shortestHeight\r\n            ) {\r\n              columnIndex = i;\r\n            }\r\n          }\r\n        }\r\n\r\n        const columnHeight = columnHeights[columnIndex];\r\n        if (columnHeight === undefined) return;\r\n\r\n        const top = columnHeight;\r\n        columnHeights[columnIndex] = top + height + (rowGap ?? columnGap);\r\n\r\n        const columnItemsList = columnItems[columnIndex];\r\n        if (!columnItemsList) return;\r\n        columnItemsList.push(index);\r\n\r\n        items[index] = {\r\n          left: columnIndex * (computedColumnWidth + columnGap),\r\n          top,\r\n          height,\r\n          columnIndex,\r\n        };\r\n        intervalTree.insert(top, top + height, index);\r\n      },\r\n      get: (index: number) => items[index],\r\n      update: (updates: number[]) => {\r\n        const columns: (number | undefined)[] = new Array(computedColumnCount);\r\n        let i = 0;\r\n        let j = 0;\r\n\r\n        for (; i < updates.length - 1; i++) {\r\n          const currentIndex = updates[i];\r\n          if (typeof currentIndex !== \"number\") continue;\r\n\r\n          const item = items[currentIndex];\r\n          if (!item) continue;\r\n\r\n          const nextHeight = updates[++i];\r\n          if (typeof nextHeight !== \"number\") continue;\r\n\r\n          item.height = nextHeight;\r\n          intervalTree.remove(currentIndex);\r\n          intervalTree.insert(item.top, item.top + item.height, currentIndex);\r\n          columns[item.columnIndex] =\r\n            columns[item.columnIndex] === void 0\r\n              ? currentIndex\r\n              : Math.min(\r\n                  currentIndex,\r\n                  columns[item.columnIndex] ?? currentIndex,\r\n                );\r\n        }\r\n\r\n        for (i = 0; i < columns.length; i++) {\r\n          const currentColumn = columns[i];\r\n          if (currentColumn === void 0) continue;\r\n\r\n          const itemsInColumn = columnItems[i];\r\n          if (!itemsInColumn) continue;\r\n\r\n          const startIndex = binarySearch(itemsInColumn, currentColumn);\r\n          if (startIndex === -1) continue;\r\n\r\n          const currentItemIndex = itemsInColumn[startIndex];\r\n          if (typeof currentItemIndex !== \"number\") continue;\r\n\r\n          const startItem = items[currentItemIndex];\r\n          if (!startItem) continue;\r\n\r\n          const currentHeight = columnHeights[i];\r\n          if (typeof currentHeight !== \"number\") continue;\r\n\r\n          columnHeights[i] =\r\n            startItem.top + startItem.height + (rowGap ?? columnGap);\r\n\r\n          for (j = startIndex + 1; j < itemsInColumn.length; j++) {\r\n            const currentIndex = itemsInColumn[j];\r\n            if (typeof currentIndex !== \"number\") continue;\r\n\r\n            const item = items[currentIndex];\r\n            if (!item) continue;\r\n\r\n            const columnHeight = columnHeights[i];\r\n            if (typeof columnHeight !== \"number\") continue;\r\n\r\n            item.top = columnHeight;\r\n            columnHeights[i] = item.top + item.height + (rowGap ?? columnGap);\r\n            intervalTree.remove(currentIndex);\r\n            intervalTree.insert(item.top, item.top + item.height, currentIndex);\r\n          }\r\n        }\r\n      },\r\n      range: (low, high, onItemRender) =>\r\n        intervalTree.search(low, high, (index: number, top: number) => {\r\n          const item = items[index];\r\n          if (!item) return;\r\n          onItemRender(index, item.left, top);\r\n        }),\r\n      estimateHeight: (itemCount, defaultItemHeight): number => {\r\n        const tallestColumn = Math.max(0, Math.max.apply(null, columnHeights));\r\n\r\n        return itemCount === intervalTree.size\r\n          ? tallestColumn\r\n          : tallestColumn +\r\n              Math.ceil((itemCount - intervalTree.size) / computedColumnCount) *\r\n                defaultItemHeight;\r\n      },\r\n      shortestColumn: () => {\r\n        if (columnHeights.length > 1)\r\n          return Math.min.apply(null, columnHeights);\r\n        return columnHeights[0] ?? 0;\r\n      },\r\n      size(): number {\r\n        return intervalTree.size;\r\n      },\r\n      all(): PositionerItem[] {\r\n        return items.filter(Boolean) as PositionerItem[];\r\n      },\r\n    };\r\n  }, [\r\n    width,\r\n    columnWidth,\r\n    columnGap,\r\n    rowGap,\r\n    columnCount,\r\n    maxColumnCount,\r\n    linear,\r\n  ]);\r\n\r\n  const positionerRef = React.useRef<Positioner | null>(null);\r\n  if (positionerRef.current === null) positionerRef.current = initPositioner();\r\n\r\n  const prevDepsRef = React.useRef(deps);\r\n  const opts = [\r\n    width,\r\n    columnWidth,\r\n    columnGap,\r\n    rowGap,\r\n    columnCount,\r\n    maxColumnCount,\r\n    linear,\r\n  ];\r\n  const prevOptsRef = React.useRef(opts);\r\n  const optsChanged = !opts.every((item, i) => prevOptsRef.current[i] === item);\r\n\r\n  if (\r\n    optsChanged ||\r\n    !deps.every((item, i) => prevDepsRef.current[i] === item)\r\n  ) {\r\n    const prevPositioner = positionerRef.current;\r\n    const positioner = initPositioner();\r\n    prevDepsRef.current = deps;\r\n    prevOptsRef.current = opts;\r\n\r\n    if (optsChanged) {\r\n      const cacheSize = prevPositioner.size();\r\n      for (let index = 0; index < cacheSize; index++) {\r\n        const pos = prevPositioner.get(index);\r\n        positioner.set(index, pos !== void 0 ? pos.height : 0);\r\n      }\r\n    }\r\n\r\n    positionerRef.current = positioner;\r\n  }\r\n\r\n  return positionerRef.current;\r\n}\r\n\r\ninterface DebouncedWindowSizeOptions {\r\n  containerRef: React.RefObject<RootElement | null>;\r\n  defaultWidth?: number;\r\n  defaultHeight?: number;\r\n  delayMs?: number;\r\n}\r\n\r\nfunction useDebouncedWindowSize(options: DebouncedWindowSizeOptions) {\r\n  const {\r\n    containerRef,\r\n    defaultWidth = 0,\r\n    defaultHeight = 0,\r\n    delayMs = DEBOUNCE_DELAY,\r\n  } = options;\r\n\r\n  const getDocumentSize = React.useCallback(() => {\r\n    if (typeof document === \"undefined\") {\r\n      return { width: defaultWidth, height: defaultHeight };\r\n    }\r\n    return {\r\n      width: document.documentElement.clientWidth,\r\n      height: document.documentElement.clientHeight,\r\n    };\r\n  }, [defaultWidth, defaultHeight]);\r\n\r\n  const [size, setSize] = React.useState(getDocumentSize());\r\n  const timeoutRef = React.useRef<NodeJS.Timeout | null>(null);\r\n\r\n  const setDebouncedSize = React.useCallback(\r\n    (value: { width: number; height: number }) => {\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n      }\r\n\r\n      timeoutRef.current = setTimeout(() => {\r\n        setSize(value);\r\n      }, delayMs);\r\n    },\r\n    [delayMs],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    function onResize() {\r\n      if (containerRef.current) {\r\n        setDebouncedSize({\r\n          width: containerRef.current.offsetWidth,\r\n          height: document.documentElement.clientHeight,\r\n        });\r\n      } else {\r\n        setDebouncedSize(getDocumentSize());\r\n      }\r\n    }\r\n\r\n    window?.addEventListener(\"resize\", onResize, { passive: true });\r\n    window?.addEventListener(\"orientationchange\", onResize);\r\n    window.visualViewport?.addEventListener(\"resize\", onResize);\r\n\r\n    return () => {\r\n      window?.removeEventListener(\"resize\", onResize);\r\n      window?.removeEventListener(\"orientationchange\", onResize);\r\n      window.visualViewport?.removeEventListener(\"resize\", onResize);\r\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\r\n    };\r\n  }, [setDebouncedSize, containerRef, getDocumentSize]);\r\n\r\n  return size;\r\n}\r\n\r\ntype OnRafScheduleReturn<T extends unknown[]> = {\r\n  (...args: T): void;\r\n  cancel: () => void;\r\n};\r\n\r\nfunction onRafSchedule<T extends unknown[]>(\r\n  callback: (...args: T) => void,\r\n): OnRafScheduleReturn<T> {\r\n  let lastArgs: T = [] as unknown as T;\r\n  let frameId: number | null = null;\r\n\r\n  function onCallback(...args: T) {\r\n    lastArgs = args;\r\n\r\n    if (frameId)\r\n      frameId = requestAnimationFrame(() => {\r\n        frameId = null;\r\n        callback(...lastArgs);\r\n      });\r\n  }\r\n\r\n  onCallback.cancel = () => {\r\n    if (!frameId) return;\r\n    cancelAnimationFrame(frameId);\r\n    frameId = null;\r\n  };\r\n\r\n  return onCallback;\r\n}\r\n\r\nfunction useResizeObserver(positioner: Positioner) {\r\n  const [, setLayoutVersion] = React.useState(0);\r\n\r\n  const createResizeObserver = React.useMemo(() => {\r\n    if (typeof window === \"undefined\") {\r\n      return () => ({\r\n        disconnect: () => {},\r\n        observe: () => {},\r\n        unobserve: () => {},\r\n      });\r\n    }\r\n\r\n    return onDeepMemo(\r\n      [WeakMap],\r\n      (positioner: Positioner, onUpdate: () => void) => {\r\n        const updates: number[] = [];\r\n        const itemMap = new WeakMap<Element, number>();\r\n\r\n        const update = onRafSchedule(() => {\r\n          if (updates.length > 0) {\r\n            positioner.update(updates);\r\n            onUpdate();\r\n          }\r\n          updates.length = 0;\r\n        });\r\n\r\n        function onItemResize(target: ItemElement) {\r\n          const height = target.offsetHeight;\r\n          if (height > 0) {\r\n            const index = itemMap.get(target);\r\n            if (index !== void 0) {\r\n              const position = positioner.get(index);\r\n              if (position !== void 0 && height !== position.height) {\r\n                updates.push(index, height);\r\n              }\r\n            }\r\n          }\r\n          update();\r\n        }\r\n\r\n        const scheduledItemMap = new Map<\r\n          number,\r\n          OnRafScheduleReturn<[ItemElement]>\r\n        >();\r\n        function onResizeObserver(entries: ResizeObserverEntry[]) {\r\n          for (const entry of entries) {\r\n            if (!entry) continue;\r\n            const index = itemMap.get(entry.target);\r\n\r\n            if (index === void 0) continue;\r\n            let handler = scheduledItemMap.get(index);\r\n            if (!handler) {\r\n              handler = onRafSchedule(onItemResize);\r\n              scheduledItemMap.set(index, handler);\r\n            }\r\n            handler(entry.target as ItemElement);\r\n          }\r\n        }\r\n\r\n        const observer = new ResizeObserver(onResizeObserver);\r\n        const disconnect = observer.disconnect.bind(observer);\r\n        observer.disconnect = () => {\r\n          disconnect();\r\n          for (const [, scheduleItem] of scheduledItemMap) {\r\n            scheduleItem.cancel();\r\n          }\r\n        };\r\n\r\n        return observer;\r\n      },\r\n    );\r\n  }, []);\r\n\r\n  const resizeObserver = createResizeObserver(positioner, () =>\r\n    setLayoutVersion((prev) => prev + 1),\r\n  );\r\n\r\n  React.useEffect(() => () => resizeObserver.disconnect(), [resizeObserver]);\r\n\r\n  return resizeObserver;\r\n}\r\n\r\nfunction useScroller({\r\n  offset = 0,\r\n  fps = SCROLL_FPS,\r\n}: {\r\n  offset?: number;\r\n  fps?: number;\r\n} = {}): { scrollTop: number; isScrolling: boolean } {\r\n  const [scrollY, setScrollY] = useThrottle(\r\n    typeof globalThis.window === \"undefined\"\r\n      ? 0\r\n      : (globalThis.window.scrollY ?? document.documentElement.scrollTop ?? 0),\r\n    { fps, leading: true },\r\n  );\r\n\r\n  const onScroll = React.useCallback(() => {\r\n    setScrollY(\r\n      globalThis.window.scrollY ?? document.documentElement.scrollTop ?? 0,\r\n    );\r\n  }, [setScrollY]);\r\n\r\n  React.useEffect(() => {\r\n    if (typeof globalThis.window === \"undefined\") return;\r\n    globalThis.window.addEventListener(\"scroll\", onScroll, { passive: true });\r\n\r\n    return () => globalThis.window.removeEventListener(\"scroll\", onScroll);\r\n  }, [onScroll]);\r\n\r\n  const [isScrolling, setIsScrolling] = React.useState(false);\r\n  const hasMountedRef = React.useRef(0);\r\n\r\n  React.useEffect(() => {\r\n    if (hasMountedRef.current === 1) setIsScrolling(true);\r\n    let didUnsubscribe = false;\r\n\r\n    function requestTimeout(fn: () => void, delay: number) {\r\n      const start = performance.now();\r\n      const handle = {\r\n        id: requestAnimationFrame(function tick(timestamp) {\r\n          if (timestamp - start >= delay) {\r\n            fn();\r\n          } else {\r\n            handle.id = requestAnimationFrame(tick);\r\n          }\r\n        }),\r\n      };\r\n      return handle;\r\n    }\r\n\r\n    const timeout = requestTimeout(\r\n      () => {\r\n        if (didUnsubscribe) return;\r\n        setIsScrolling(false);\r\n      },\r\n      40 + 1000 / fps,\r\n    );\r\n    hasMountedRef.current = 1;\r\n    return () => {\r\n      didUnsubscribe = true;\r\n      cancelAnimationFrame(timeout.id);\r\n    };\r\n  }, [fps]);\r\n\r\n  return { scrollTop: Math.max(0, scrollY - offset), isScrolling };\r\n}\r\n\r\nfunction useThrottle<State>(\r\n  initialState: State | (() => State),\r\n  options: {\r\n    fps?: number;\r\n    leading?: boolean;\r\n  } = {},\r\n): [State, React.Dispatch<React.SetStateAction<State>>] {\r\n  const { fps = 30, leading = false } = options;\r\n  const [state, setState] = React.useState(initialState);\r\n  const latestSetState = React.useRef(setState);\r\n  latestSetState.current = setState;\r\n\r\n  const ms = 1000 / fps;\r\n  const prevCountRef = React.useRef(0);\r\n  const trailingTimeout = React.useRef<ReturnType<typeof setTimeout> | null>(\r\n    null,\r\n  );\r\n\r\n  const clearTrailing = React.useCallback(() => {\r\n    if (trailingTimeout.current) {\r\n      clearTimeout(trailingTimeout.current);\r\n    }\r\n  }, []);\r\n\r\n  React.useEffect(() => {\r\n    return () => {\r\n      prevCountRef.current = 0;\r\n      clearTrailing();\r\n    };\r\n  }, [clearTrailing]);\r\n\r\n  const throttledSetState = React.useCallback(\r\n    (action: React.SetStateAction<State>) => {\r\n      const perf = typeof performance !== \"undefined\" ? performance : Date;\r\n      const now = () => perf.now();\r\n      const rightNow = now();\r\n      const call = () => {\r\n        prevCountRef.current = rightNow;\r\n        clearTrailing();\r\n        latestSetState.current(action);\r\n      };\r\n      const current = prevCountRef.current;\r\n\r\n      if (leading && current === 0) {\r\n        return call();\r\n      }\r\n\r\n      if (rightNow - current > ms) {\r\n        if (current > 0) {\r\n          return call();\r\n        }\r\n        prevCountRef.current = rightNow;\r\n      }\r\n\r\n      clearTrailing();\r\n      trailingTimeout.current = setTimeout(() => {\r\n        call();\r\n        prevCountRef.current = 0;\r\n      }, ms);\r\n    },\r\n    [leading, ms, clearTrailing],\r\n  );\r\n\r\n  return [state, throttledSetState];\r\n}\r\n\r\nconst ROOT_NAME = \"MasonryRoot\";\r\nconst VIEWPORT_NAME = \"MasonryViewport\";\r\nconst ITEM_NAME = \"MasonryItem\";\r\n\r\nconst MASONRY_ERROR = {\r\n  [ROOT_NAME]: `\\`${ROOT_NAME}\\` components must be within \\`${ROOT_NAME}\\``,\r\n  [VIEWPORT_NAME]: `\\`${VIEWPORT_NAME}\\` components must be within \\`${ROOT_NAME}\\``,\r\n  [ITEM_NAME]: `\\`${ITEM_NAME}\\` must be within \\`${VIEWPORT_NAME}\\``,\r\n} as const;\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {}\r\n\r\ntype RootElement = React.ComponentRef<typeof Masonry>;\r\ntype ItemElement = React.ComponentRef<typeof MasonryItem>;\r\n\r\ninterface MasonryContextValue {\r\n  positioner: Positioner;\r\n  resizeObserver?: ResizeObserver;\r\n  columnWidth: number;\r\n  onItemRegister: (index: number) => (node: ItemElement | null) => void;\r\n  scrollTop: number;\r\n  windowHeight: number;\r\n  itemHeight: number;\r\n  overscan: number;\r\n  isScrolling?: boolean;\r\n  fallback?: React.ReactNode;\r\n}\r\n\r\nconst MasonryContext = React.createContext<MasonryContextValue | null>(null);\r\n\r\nfunction useMasonryContext(name: keyof typeof MASONRY_ERROR) {\r\n  const context = React.useContext(MasonryContext);\r\n  if (!context) {\r\n    throw new Error(MASONRY_ERROR[name]);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface MasonryProps extends DivProps {\r\n  columnWidth?: number;\r\n  columnCount?: number;\r\n  maxColumnCount?: number;\r\n  gap?: number | { column: number; row: number };\r\n  itemHeight?: number;\r\n  defaultWidth?: number;\r\n  defaultHeight?: number;\r\n  overscan?: number;\r\n  scrollFps?: number;\r\n  fallback?: React.ReactNode;\r\n  linear?: boolean;\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction Masonry(props: MasonryProps) {\r\n  const {\r\n    columnWidth = COLUMN_WIDTH,\r\n    columnCount,\r\n    maxColumnCount,\r\n    gap = GAP,\r\n    itemHeight = ITEM_HEIGHT,\r\n    defaultWidth,\r\n    defaultHeight,\r\n    overscan = OVERSCAN,\r\n    scrollFps = SCROLL_FPS,\r\n    fallback,\r\n    linear = false,\r\n    asChild,\r\n    children,\r\n    style,\r\n    ref,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const gapValue = typeof gap === \"object\" ? gap : { column: gap, row: gap };\r\n  const columnGap = gapValue.column;\r\n  const rowGap = gapValue.row;\r\n\r\n  const containerRef = React.useRef<RootElement | null>(null);\r\n  const composedRef = useComposedRefs(ref, containerRef);\r\n\r\n  const size = useDebouncedWindowSize({\r\n    containerRef,\r\n    defaultWidth,\r\n    defaultHeight,\r\n    delayMs: DEBOUNCE_DELAY,\r\n  });\r\n\r\n  const [containerPosition, setContainerPosition] = React.useState<{\r\n    offset: number;\r\n    width: number;\r\n  }>({ offset: 0, width: 0 });\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    let offset = 0;\r\n    let container = containerRef.current;\r\n\r\n    do {\r\n      offset += container.offsetTop ?? 0;\r\n      container = container.offsetParent as RootElement;\r\n    } while (container);\r\n\r\n    if (\r\n      offset !== containerPosition.offset ||\r\n      containerRef.current.offsetWidth !== containerPosition.width\r\n    ) {\r\n      setContainerPosition({\r\n        offset,\r\n        width: containerRef.current.offsetWidth,\r\n      });\r\n    }\r\n  }, [containerPosition, size]);\r\n\r\n  const positioner = usePositioner({\r\n    width: containerPosition.width ?? size.width,\r\n    columnWidth,\r\n    columnGap,\r\n    rowGap,\r\n    columnCount,\r\n    maxColumnCount,\r\n    linear,\r\n  });\r\n  const resizeObserver = useResizeObserver(positioner);\r\n  const { scrollTop, isScrolling } = useScroller({\r\n    offset: containerPosition.offset,\r\n    fps: scrollFps,\r\n  });\r\n\r\n  const itemMap = React.useRef(new WeakMap<ItemElement, number>()).current;\r\n\r\n  const onItemRegister = React.useCallback(\r\n    (index: number) => (node: ItemElement | null) => {\r\n      if (!node) return;\r\n\r\n      itemMap.set(node, index);\r\n      if (resizeObserver) {\r\n        resizeObserver.observe(node);\r\n      }\r\n      if (positioner.get(index) === void 0) {\r\n        positioner.set(index, node.offsetHeight);\r\n      }\r\n    },\r\n    [itemMap, positioner, resizeObserver],\r\n  );\r\n\r\n  const contextValue = React.useMemo<MasonryContextValue>(\r\n    () => ({\r\n      positioner,\r\n      resizeObserver,\r\n      columnWidth: positioner.columnWidth,\r\n      onItemRegister,\r\n      scrollTop,\r\n      windowHeight: size.height,\r\n      itemHeight,\r\n      overscan,\r\n      fallback,\r\n      isScrolling,\r\n    }),\r\n    [\r\n      positioner,\r\n      resizeObserver,\r\n      onItemRegister,\r\n      scrollTop,\r\n      size.height,\r\n      itemHeight,\r\n      overscan,\r\n      fallback,\r\n      isScrolling,\r\n    ],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <MasonryContext.Provider value={contextValue}>\r\n      <RootPrimitive\r\n        {...rootProps}\r\n        data-slot=\"masonry\"\r\n        ref={composedRef}\r\n        style={{\r\n          position: \"relative\",\r\n          width: \"100%\",\r\n          height: \"100%\",\r\n          ...style,\r\n        }}\r\n      >\r\n        <MasonryViewport>{children}</MasonryViewport>\r\n      </RootPrimitive>\r\n    </MasonryContext.Provider>\r\n  );\r\n}\r\n\r\ninterface MasonryItemPropsWithRef extends MasonryItemProps {\r\n  ref: React.Ref<ItemElement | null>;\r\n}\r\n\r\nfunction MasonryViewport(props: DivProps) {\r\n  const { children, style, ref, ...viewportProps } = props;\r\n  const context = useMasonryContext(VIEWPORT_NAME);\r\n  const [layoutVersion, setLayoutVersion] = React.useState(0);\r\n  const rafId = React.useRef<number | null>(null);\r\n  const [mounted, setMounted] = React.useState(false);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    setMounted(true);\r\n  }, []);\r\n\r\n  let startIndex = 0;\r\n  let stopIndex: number | undefined;\r\n\r\n  const validChildren = React.Children.toArray(children).filter(\r\n    (child): child is React.ReactElement<MasonryItemPropsWithRef> =>\r\n      React.isValidElement(child) &&\r\n      (child.type === MasonryItem || child.type === MasonryItem),\r\n  );\r\n  const itemCount = validChildren.length;\r\n\r\n  const shortestColumnSize = context.positioner.shortestColumn();\r\n  const measuredCount = context.positioner.size();\r\n  const overscanPixels = context.windowHeight * context.overscan;\r\n  const rangeStart = Math.max(0, context.scrollTop - overscanPixels / 2);\r\n  const rangeEnd = context.scrollTop + overscanPixels;\r\n  const layoutOutdated =\r\n    shortestColumnSize < rangeEnd && measuredCount < itemCount;\r\n\r\n  const positionedChildren: React.ReactElement[] = [];\r\n\r\n  const visibleItemStyle = React.useMemo(\r\n    (): React.CSSProperties => ({\r\n      position: \"absolute\",\r\n      writingMode: \"horizontal-tb\",\r\n      visibility: \"visible\",\r\n      width: context.columnWidth,\r\n      transform: context.isScrolling ? \"translateZ(0)\" : undefined,\r\n      willChange: context.isScrolling ? \"transform\" : undefined,\r\n    }),\r\n    [context.columnWidth, context.isScrolling],\r\n  );\r\n\r\n  const hiddenItemStyle = React.useMemo(\r\n    (): React.CSSProperties => ({\r\n      position: \"absolute\",\r\n      writingMode: \"horizontal-tb\",\r\n      visibility: \"hidden\",\r\n      width: context.columnWidth,\r\n      zIndex: -1000,\r\n    }),\r\n    [context.columnWidth],\r\n  );\r\n\r\n  context.positioner.range(rangeStart, rangeEnd, (index, left, top) => {\r\n    const child = validChildren[index];\r\n    if (!child) return;\r\n\r\n    const itemStyle = {\r\n      ...visibleItemStyle,\r\n      top,\r\n      left,\r\n      ...child.props.style,\r\n    };\r\n\r\n    positionedChildren.push(\r\n      React.cloneElement(child, {\r\n        key: child.key ?? index,\r\n        ref: context.onItemRegister(index),\r\n        style: itemStyle,\r\n      }),\r\n    );\r\n\r\n    if (stopIndex === undefined) {\r\n      startIndex = index;\r\n      stopIndex = index;\r\n    } else {\r\n      startIndex = Math.min(startIndex, index);\r\n      stopIndex = Math.max(stopIndex, index);\r\n    }\r\n  });\r\n\r\n  if (layoutOutdated && mounted) {\r\n    const batchSize = Math.min(\r\n      itemCount - measuredCount,\r\n      Math.ceil(\r\n        ((context.scrollTop + overscanPixels - shortestColumnSize) /\r\n          context.itemHeight) *\r\n          context.positioner.columnCount,\r\n      ),\r\n    );\r\n\r\n    for (\r\n      let index = measuredCount;\r\n      index < measuredCount + batchSize;\r\n      index++\r\n    ) {\r\n      const child = validChildren[index];\r\n      if (!child) continue;\r\n\r\n      const itemStyle = {\r\n        ...hiddenItemStyle,\r\n        ...child.props.style,\r\n      };\r\n\r\n      positionedChildren.push(\r\n        React.cloneElement(child, {\r\n          key: child.key ?? index,\r\n          ref: context.onItemRegister(index),\r\n          style: itemStyle,\r\n        }),\r\n      );\r\n    }\r\n  }\r\n\r\n  React.useEffect(() => {\r\n    if (layoutOutdated && mounted) {\r\n      if (rafId.current) {\r\n        cancelAnimationFrame(rafId.current);\r\n      }\r\n      rafId.current = requestAnimationFrame(() => {\r\n        setLayoutVersion((v) => v + 1);\r\n      });\r\n    }\r\n    return () => {\r\n      if (rafId.current) {\r\n        cancelAnimationFrame(rafId.current);\r\n      }\r\n    };\r\n  }, [layoutOutdated, mounted]);\r\n\r\n  const estimatedHeight = React.useMemo(() => {\r\n    const measuredHeight = context.positioner.estimateHeight(\r\n      measuredCount,\r\n      context.itemHeight,\r\n    );\r\n    if (measuredCount === itemCount) {\r\n      return measuredHeight;\r\n    }\r\n    const remainingItems = itemCount - measuredCount;\r\n    const estimatedRemainingHeight = Math.ceil(\r\n      (remainingItems / context.positioner.columnCount) * context.itemHeight,\r\n    );\r\n    return measuredHeight + estimatedRemainingHeight;\r\n  }, [context.positioner, context.itemHeight, measuredCount, itemCount]);\r\n\r\n  const containerStyle = React.useMemo(\r\n    () => ({\r\n      position: \"relative\" as const,\r\n      width: \"100%\",\r\n      maxWidth: \"100%\",\r\n      height: Math.ceil(estimatedHeight),\r\n      maxHeight: Math.ceil(estimatedHeight),\r\n      willChange: context.isScrolling ? \"contents\" : undefined,\r\n      pointerEvents: context.isScrolling ? (\"none\" as const) : undefined,\r\n      ...style,\r\n    }),\r\n    [context.isScrolling, estimatedHeight, style],\r\n  );\r\n\r\n  if (!mounted && context.fallback) {\r\n    return context.fallback;\r\n  }\r\n\r\n  return (\r\n    <div\r\n      {...viewportProps}\r\n      ref={ref}\r\n      style={containerStyle}\r\n      data-version={mounted ? layoutVersion : undefined}\r\n    >\r\n      {positionedChildren}\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface MasonryItemProps extends DivProps {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction MasonryItem(props: MasonryItemProps) {\r\n  const { asChild, ref, ...itemProps } = props;\r\n\r\n  const ItemPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return <ItemPrimitive data-slot=\"masonry-item\" {...itemProps} ref={ref} />;\r\n}\r\n\r\nexport {\r\n  Masonry,\r\n  MasonryItem,\r\n  //\r\n  type MasonryProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}