{
  "name": "action-bar",
  "dependencies": [
    "radix-ui"
  ],
  "registryDependencies": [
    "button",
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect"
  ],
  "files": [
    {
      "path": "ui/action-bar.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  Direction as DirectionPrimitive,\r\n  Slot as SlotPrimitive,\r\n} from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\n\r\nconst ROOT_NAME = \"ActionBar\";\r\nconst GROUP_NAME = \"ActionBarGroup\";\r\nconst ITEM_NAME = \"ActionBarItem\";\r\nconst CLOSE_NAME = \"ActionBarClose\";\r\nconst SEPARATOR_NAME = \"ActionBarSeparator\";\r\nconst ITEM_SELECT = \"actionbar.itemSelect\";\r\nconst ENTRY_FOCUS = \"actionbarFocusGroup.onEntryFocus\";\r\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\ntype Orientation = \"horizontal\" | \"vertical\";\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype RootElement = React.ComponentRef<typeof ActionBar>;\r\ntype ItemElement = React.ComponentRef<typeof ActionBarItem>;\r\ntype CloseElement = React.ComponentRef<typeof ActionBarClose>;\r\n\r\nfunction focusFirst(\r\n  candidates: React.RefObject<HTMLElement | null>[],\r\n  preventScroll = false,\r\n) {\r\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\r\n  for (const candidateRef of candidates) {\r\n    const candidate = candidateRef.current;\r\n    if (!candidate) continue;\r\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\r\n    candidate.focus({ preventScroll });\r\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\r\n  }\r\n}\r\n\r\nfunction wrapArray<T>(array: T[], startIndex: number) {\r\n  return array.map<T>(\r\n    (_, index) => array[(startIndex + index) % array.length] as T,\r\n  );\r\n}\r\n\r\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\r\n  if (dir !== \"rtl\") return key;\r\n  return key === \"ArrowLeft\"\r\n    ? \"ArrowRight\"\r\n    : key === \"ArrowRight\"\r\n      ? \"ArrowLeft\"\r\n      : key;\r\n}\r\n\r\ninterface ItemData {\r\n  id: string;\r\n  ref: React.RefObject<ItemElement | null>;\r\n  disabled: boolean;\r\n}\r\n\r\ninterface ActionBarContextValue {\r\n  onOpenChange?: (open: boolean) => void;\r\n  dir: Direction;\r\n  orientation: Orientation;\r\n  loop: boolean;\r\n}\r\n\r\nconst ActionBarContext = React.createContext<ActionBarContextValue | null>(\r\n  null,\r\n);\r\n\r\nfunction useActionBarContext(consumerName: string) {\r\n  const context = React.useContext(ActionBarContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface FocusContextValue {\r\n  tabStopId: string | null;\r\n  onItemFocus: (tabStopId: string) => void;\r\n  onItemShiftTab: () => void;\r\n  onFocusableItemAdd: () => void;\r\n  onFocusableItemRemove: () => void;\r\n  onItemRegister: (item: ItemData) => void;\r\n  onItemUnregister: (id: string) => void;\r\n  getItems: () => ItemData[];\r\n}\r\n\r\nconst FocusContext = React.createContext<FocusContextValue | null>(null);\r\n\r\nfunction useFocusContext(consumerName: string) {\r\n  const context = React.useContext(FocusContext);\r\n  if (!context) {\r\n    throw new Error(\r\n      `\\`${consumerName}\\` must be used within \\`FocusProvider\\``,\r\n    );\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface ActionBarProps extends DivProps {\r\n  open?: boolean;\r\n  onOpenChange?: (open: boolean) => void;\r\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\r\n  align?: \"start\" | \"center\" | \"end\";\r\n  alignOffset?: number;\r\n  side?: \"top\" | \"bottom\";\r\n  sideOffset?: number;\r\n  portalContainer?: Element | DocumentFragment | null;\r\n  dir?: Direction;\r\n  orientation?: Orientation;\r\n  loop?: boolean;\r\n}\r\n\r\nfunction ActionBar(props: ActionBarProps) {\r\n  const {\r\n    open = false,\r\n    onOpenChange,\r\n    onEscapeKeyDown,\r\n    side = \"bottom\",\r\n    alignOffset = 0,\r\n    align = \"center\",\r\n    sideOffset = 16,\r\n    portalContainer: portalContainerProp,\r\n    dir: dirProp,\r\n    orientation = \"horizontal\",\r\n    loop = true,\r\n    className,\r\n    style,\r\n    ref,\r\n    asChild,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const [mounted, setMounted] = React.useState(false);\r\n\r\n  const rootRef = React.useRef<RootElement>(null);\r\n  const composedRef = useComposedRefs(ref, rootRef);\r\n\r\n  const propsRef = useAsRef({\r\n    onEscapeKeyDown,\r\n    onOpenChange,\r\n  });\r\n\r\n  const dir = DirectionPrimitive.useDirection(dirProp);\r\n\r\n  React.useLayoutEffect(() => {\r\n    setMounted(true);\r\n  }, []);\r\n\r\n  React.useEffect(() => {\r\n    if (!open) return;\r\n\r\n    const ownerDocument = rootRef.current?.ownerDocument ?? document;\r\n\r\n    function onKeyDown(event: KeyboardEvent) {\r\n      if (event.key === \"Escape\") {\r\n        propsRef.current.onEscapeKeyDown?.(event);\r\n        if (!event.defaultPrevented) {\r\n          propsRef.current.onOpenChange?.(false);\r\n        }\r\n      }\r\n    }\r\n\r\n    ownerDocument.addEventListener(\"keydown\", onKeyDown);\r\n    return () => ownerDocument.removeEventListener(\"keydown\", onKeyDown);\r\n  }, [open, propsRef]);\r\n\r\n  const contextValue = React.useMemo<ActionBarContextValue>(\r\n    () => ({\r\n      onOpenChange,\r\n      dir,\r\n      orientation,\r\n      loop,\r\n    }),\r\n    [onOpenChange, dir, orientation, loop],\r\n  );\r\n\r\n  const portalContainer =\r\n    portalContainerProp ?? (mounted ? globalThis.document?.body : null);\r\n\r\n  if (!portalContainer || !open) return null;\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <ActionBarContext.Provider value={contextValue}>\r\n      {ReactDOM.createPortal(\r\n        <RootPrimitive\r\n          role=\"toolbar\"\r\n          aria-orientation={orientation}\r\n          data-slot=\"action-bar\"\r\n          data-side={side}\r\n          data-align={align}\r\n          data-orientation={orientation}\r\n          dir={dir}\r\n          {...rootProps}\r\n          ref={composedRef}\r\n          className={cn(\r\n            \"fixed z-50 rounded-lg border bg-card shadow-lg outline-none\",\r\n            \"fade-in-0 zoom-in-95 animate-in duration-250 [animation-timing-function:cubic-bezier(0.16,1,0.3,1)]\",\r\n            \"data-[side=bottom]:slide-in-from-bottom-4 data-[side=top]:slide-in-from-top-4\",\r\n            \"motion-reduce:animate-none motion-reduce:transition-none\",\r\n            orientation === \"horizontal\"\r\n              ? \"flex flex-row items-center gap-2 px-2 py-1.5\"\r\n              : \"flex flex-col items-start gap-2 px-1.5 py-2\",\r\n            className,\r\n          )}\r\n          style={{\r\n            [side]: `${sideOffset}px`,\r\n            ...(align === \"center\" && {\r\n              left: \"50%\",\r\n              translate: \"-50% 0\",\r\n            }),\r\n            ...(align === \"start\" && { left: `${alignOffset}px` }),\r\n            ...(align === \"end\" && { right: `${alignOffset}px` }),\r\n            ...style,\r\n          }}\r\n        />,\r\n        portalContainer,\r\n      )}\r\n    </ActionBarContext.Provider>\r\n  );\r\n}\r\n\r\nfunction ActionBarSelection(props: DivProps) {\r\n  const { className, asChild, ...selectionProps } = props;\r\n\r\n  const SelectionPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <SelectionPrimitive\r\n      data-slot=\"action-bar-selection\"\r\n      {...selectionProps}\r\n      className={cn(\r\n        \"flex items-center gap-1 rounded-sm border px-2 py-1 font-medium text-sm tabular-nums\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nfunction ActionBarGroup(props: DivProps) {\r\n  const {\r\n    onBlur: onBlurProp,\r\n    onFocus: onFocusProp,\r\n    onMouseDown: onMouseDownProp,\r\n    className,\r\n    asChild,\r\n    ref,\r\n    ...groupProps\r\n  } = props;\r\n\r\n  const [tabStopId, setTabStopId] = React.useState<string | null>(null);\r\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\r\n  const [focusableItemCount, setFocusableItemCount] = React.useState(0);\r\n\r\n  const groupRef = React.useRef<HTMLDivElement>(null);\r\n  const composedRef = useComposedRefs(ref, groupRef);\r\n  const isClickFocusRef = React.useRef(false);\r\n  const itemsRef = React.useRef<Map<string, ItemData>>(new Map());\r\n\r\n  const { dir, orientation } = useActionBarContext(GROUP_NAME);\r\n\r\n  const onItemFocus = React.useCallback((tabStopId: string) => {\r\n    setTabStopId(tabStopId);\r\n  }, []);\r\n\r\n  const onItemShiftTab = React.useCallback(() => {\r\n    setIsTabbingBackOut(true);\r\n  }, []);\r\n\r\n  const onFocusableItemAdd = React.useCallback(() => {\r\n    setFocusableItemCount((prevCount) => prevCount + 1);\r\n  }, []);\r\n\r\n  const onFocusableItemRemove = React.useCallback(() => {\r\n    setFocusableItemCount((prevCount) => prevCount - 1);\r\n  }, []);\r\n\r\n  const onItemRegister = React.useCallback((item: ItemData) => {\r\n    itemsRef.current.set(item.id, item);\r\n  }, []);\r\n\r\n  const onItemUnregister = React.useCallback((id: string) => {\r\n    itemsRef.current.delete(id);\r\n  }, []);\r\n\r\n  const getItems = React.useCallback(() => {\r\n    return Array.from(itemsRef.current.values())\r\n      .filter((item) => item.ref.current)\r\n      .sort((a, b) => {\r\n        const elementA = a.ref.current;\r\n        const elementB = b.ref.current;\r\n        if (!elementA || !elementB) return 0;\r\n        const position = elementA.compareDocumentPosition(elementB);\r\n        if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\r\n          return -1;\r\n        }\r\n        if (position & Node.DOCUMENT_POSITION_PRECEDING) {\r\n          return 1;\r\n        }\r\n        return 0;\r\n      });\r\n  }, []);\r\n\r\n  const onBlur = React.useCallback(\r\n    (event: React.FocusEvent<HTMLDivElement>) => {\r\n      onBlurProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      setIsTabbingBackOut(false);\r\n    },\r\n    [onBlurProp],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<HTMLDivElement>) => {\r\n      onFocusProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const isKeyboardFocus = !isClickFocusRef.current;\r\n      if (\r\n        event.target === event.currentTarget &&\r\n        isKeyboardFocus &&\r\n        !isTabbingBackOut\r\n      ) {\r\n        const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\r\n        event.currentTarget.dispatchEvent(entryFocusEvent);\r\n\r\n        if (!entryFocusEvent.defaultPrevented) {\r\n          const items = Array.from(itemsRef.current.values()).filter(\r\n            (item) => !item.disabled,\r\n          );\r\n          const currentItem = items.find((item) => item.id === tabStopId);\r\n\r\n          const candidateItems = [currentItem, ...items].filter(\r\n            Boolean,\r\n          ) as ItemData[];\r\n          const candidateRefs = candidateItems.map((item) => item.ref);\r\n          focusFirst(candidateRefs, false);\r\n        }\r\n      }\r\n      isClickFocusRef.current = false;\r\n    },\r\n    [onFocusProp, isTabbingBackOut, tabStopId],\r\n  );\r\n\r\n  const onMouseDown = React.useCallback(\r\n    (event: React.MouseEvent<HTMLDivElement>) => {\r\n      onMouseDownProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      isClickFocusRef.current = true;\r\n    },\r\n    [onMouseDownProp],\r\n  );\r\n\r\n  const focusContextValue = React.useMemo<FocusContextValue>(\r\n    () => ({\r\n      tabStopId,\r\n      onItemFocus,\r\n      onItemShiftTab,\r\n      onFocusableItemAdd,\r\n      onFocusableItemRemove,\r\n      onItemRegister,\r\n      onItemUnregister,\r\n      getItems,\r\n    }),\r\n    [\r\n      tabStopId,\r\n      onItemFocus,\r\n      onItemShiftTab,\r\n      onFocusableItemAdd,\r\n      onFocusableItemRemove,\r\n      onItemRegister,\r\n      onItemUnregister,\r\n      getItems,\r\n    ],\r\n  );\r\n\r\n  const GroupPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <FocusContext.Provider value={focusContextValue}>\r\n      <GroupPrimitive\r\n        role=\"group\"\r\n        data-slot=\"action-bar-group\"\r\n        data-orientation={orientation}\r\n        dir={dir}\r\n        tabIndex={isTabbingBackOut || focusableItemCount === 0 ? -1 : 0}\r\n        {...groupProps}\r\n        ref={composedRef}\r\n        className={cn(\r\n          \"flex gap-2 outline-none\",\r\n          orientation === \"horizontal\"\r\n            ? \"items-center\"\r\n            : \"w-full flex-col items-start\",\r\n          className,\r\n        )}\r\n        onBlur={onBlur}\r\n        onFocus={onFocus}\r\n        onMouseDown={onMouseDown}\r\n      />\r\n    </FocusContext.Provider>\r\n  );\r\n}\r\n\r\ninterface ActionBarItemProps\r\n  extends Omit<React.ComponentProps<typeof Button>, \"onSelect\"> {\r\n  onSelect?: (event: Event) => void;\r\n}\r\n\r\nfunction ActionBarItem(props: ActionBarItemProps) {\r\n  const {\r\n    onSelect,\r\n    onClick: onClickProp,\r\n    onFocus: onFocusProp,\r\n    onKeyDown: onKeyDownProp,\r\n    onMouseDown: onMouseDownProp,\r\n    className,\r\n    disabled,\r\n    ref,\r\n    ...itemProps\r\n  } = props;\r\n\r\n  const itemRef = React.useRef<ItemElement>(null);\r\n  const composedRef = useComposedRefs(ref, itemRef);\r\n  const isMouseClickRef = React.useRef(false);\r\n\r\n  const { onOpenChange, dir, orientation, loop } =\r\n    useActionBarContext(ITEM_NAME);\r\n  const focusContext = useFocusContext(ITEM_NAME);\r\n\r\n  const itemId = React.useId();\r\n  const isTabStop = focusContext.tabStopId === itemId;\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    focusContext.onItemRegister({\r\n      id: itemId,\r\n      ref: itemRef,\r\n      disabled: !!disabled,\r\n    });\r\n\r\n    if (!disabled) {\r\n      focusContext.onFocusableItemAdd();\r\n    }\r\n\r\n    return () => {\r\n      focusContext.onItemUnregister(itemId);\r\n      if (!disabled) {\r\n        focusContext.onFocusableItemRemove();\r\n      }\r\n    };\r\n  }, [focusContext, itemId, disabled]);\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<ItemElement>) => {\r\n      onClickProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      const item = itemRef.current;\r\n      if (!item) return;\r\n\r\n      const itemSelectEvent = new CustomEvent(ITEM_SELECT, {\r\n        bubbles: true,\r\n        cancelable: true,\r\n      });\r\n\r\n      item.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), {\r\n        once: true,\r\n      });\r\n\r\n      item.dispatchEvent(itemSelectEvent);\r\n\r\n      if (!itemSelectEvent.defaultPrevented) {\r\n        onOpenChange?.(false);\r\n      }\r\n    },\r\n    [onClickProp, onOpenChange, onSelect],\r\n  );\r\n\r\n  const onFocus = React.useCallback(\r\n    (event: React.FocusEvent<ItemElement>) => {\r\n      onFocusProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      focusContext.onItemFocus(itemId);\r\n      isMouseClickRef.current = false;\r\n    },\r\n    [onFocusProp, focusContext, itemId],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<ItemElement>) => {\r\n      onKeyDownProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (event.key === \"Tab\" && event.shiftKey) {\r\n        focusContext.onItemShiftTab();\r\n        return;\r\n      }\r\n\r\n      if (event.target !== event.currentTarget) return;\r\n\r\n      const key = getDirectionAwareKey(event.key, dir);\r\n      let focusIntent: \"first\" | \"last\" | \"prev\" | \"next\" | undefined;\r\n\r\n      if (orientation === \"horizontal\") {\r\n        if (key === \"ArrowLeft\") focusIntent = \"prev\";\r\n        else if (key === \"ArrowRight\") focusIntent = \"next\";\r\n        else if (key === \"Home\") focusIntent = \"first\";\r\n        else if (key === \"End\") focusIntent = \"last\";\r\n      } else {\r\n        if (key === \"ArrowUp\") focusIntent = \"prev\";\r\n        else if (key === \"ArrowDown\") focusIntent = \"next\";\r\n        else if (key === \"Home\") focusIntent = \"first\";\r\n        else if (key === \"End\") focusIntent = \"last\";\r\n      }\r\n\r\n      if (focusIntent !== undefined) {\r\n        if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)\r\n          return;\r\n        event.preventDefault();\r\n\r\n        const items = focusContext.getItems().filter((item) => !item.disabled);\r\n        let candidateRefs = items.map((item) => item.ref);\r\n\r\n        if (focusIntent === \"last\") {\r\n          candidateRefs.reverse();\r\n        } else if (focusIntent === \"prev\" || focusIntent === \"next\") {\r\n          if (focusIntent === \"prev\") candidateRefs.reverse();\r\n          const currentIndex = candidateRefs.findIndex(\r\n            (ref) => ref.current === event.currentTarget,\r\n          );\r\n          candidateRefs = loop\r\n            ? wrapArray(candidateRefs, currentIndex + 1)\r\n            : candidateRefs.slice(currentIndex + 1);\r\n        }\r\n\r\n        queueMicrotask(() => focusFirst(candidateRefs));\r\n      }\r\n    },\r\n    [onKeyDownProp, focusContext, dir, orientation, loop],\r\n  );\r\n\r\n  const onMouseDown = React.useCallback(\r\n    (event: React.MouseEvent<ItemElement>) => {\r\n      onMouseDownProp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      isMouseClickRef.current = true;\r\n\r\n      if (disabled) {\r\n        event.preventDefault();\r\n      } else {\r\n        focusContext.onItemFocus(itemId);\r\n      }\r\n    },\r\n    [onMouseDownProp, focusContext, itemId, disabled],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      data-slot=\"action-bar-item\"\r\n      variant=\"secondary\"\r\n      size=\"sm\"\r\n      disabled={disabled}\r\n      tabIndex={isTabStop ? 0 : -1}\r\n      {...itemProps}\r\n      className={cn(orientation === \"vertical\" && \"w-full\", className)}\r\n      ref={composedRef}\r\n      onClick={onClick}\r\n      onFocus={onFocus}\r\n      onKeyDown={onKeyDown}\r\n      onMouseDown={onMouseDown}\r\n    />\r\n  );\r\n}\r\n\r\ninterface ActionBarCloseProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction ActionBarClose(props: ActionBarCloseProps) {\r\n  const { asChild, className, onClick, ...closeProps } = props;\r\n\r\n  const { onOpenChange } = useActionBarContext(CLOSE_NAME);\r\n\r\n  const onCloseClick = React.useCallback(\r\n    (event: React.MouseEvent<CloseElement>) => {\r\n      onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      onOpenChange?.(false);\r\n    },\r\n    [onOpenChange, onClick],\r\n  );\r\n\r\n  const ClosePrimitive = asChild ? SlotPrimitive.Slot : \"button\";\r\n\r\n  return (\r\n    <ClosePrimitive\r\n      type=\"button\"\r\n      data-slot=\"action-bar-close\"\r\n      {...closeProps}\r\n      className={cn(\r\n        \"rounded-xs opacity-70 outline-none hover:opacity-100 focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring/50 disabled:pointer-events-none [&_svg:not([class*='size-'])]:size-3.5 [&_svg]:pointer-events-none [&_svg]:shrink-0\",\r\n        className,\r\n      )}\r\n      onClick={onCloseClick}\r\n    />\r\n  );\r\n}\r\n\r\ninterface ActionBarSeparatorProps extends DivProps {\r\n  orientation?: Orientation;\r\n}\r\n\r\nfunction ActionBarSeparator(props: ActionBarSeparatorProps) {\r\n  const {\r\n    orientation: orientationProp,\r\n    asChild,\r\n    className,\r\n    ...separatorProps\r\n  } = props;\r\n\r\n  const context = useActionBarContext(SEPARATOR_NAME);\r\n  const orientation = orientationProp ?? context.orientation;\r\n\r\n  const SeparatorPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <SeparatorPrimitive\r\n      role=\"separator\"\r\n      aria-orientation={orientation}\r\n      aria-hidden=\"true\"\r\n      data-slot=\"action-bar-separator\"\r\n      {...separatorProps}\r\n      className={cn(\r\n        \"in-data-[slot=action-bar-selection]:ml-0.5 in-data-[slot=action-bar-selection]:h-4 in-data-[slot=action-bar-selection]:w-px bg-border\",\r\n        orientation === \"horizontal\" ? \"h-6 w-px\" : \"h-px w-full\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  ActionBar,\r\n  ActionBarSelection,\r\n  ActionBarGroup,\r\n  ActionBarItem,\r\n  ActionBarClose,\r\n  ActionBarSeparator,\r\n  type ActionBarProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}