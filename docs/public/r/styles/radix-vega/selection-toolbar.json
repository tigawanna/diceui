{
  "name": "selection-toolbar",
  "dependencies": [
    "@floating-ui/react-dom",
    "radix-ui"
  ],
  "registryDependencies": [
    "button",
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/selection-toolbar.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  autoUpdate,\r\n  flip,\r\n  hide,\r\n  limitShift,\r\n  type Middleware,\r\n  offset,\r\n  type Placement,\r\n  shift,\r\n  size,\r\n  useFloating,\r\n} from \"@floating-ui/react-dom\";\r\nimport { Slot as SlotPrimitive } from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"SelectionToolbar\";\r\nconst ITEM_NAME = \"SelectionToolbarItem\";\r\n\r\nconst SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"] as const;\r\nconst ALIGN_OPTIONS = [\"start\", \"center\", \"end\"] as const;\r\n\r\ntype Side = (typeof SIDE_OPTIONS)[number];\r\ntype Align = (typeof ALIGN_OPTIONS)[number];\r\ntype Boundary = Element | null;\r\n\r\ninterface DivProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\ntype ItemElement = React.ComponentRef<typeof SelectionToolbarItem>;\r\n\r\nfunction getSideAndAlignFromPlacement(placement: Placement) {\r\n  const [side, align = \"center\"] = placement.split(\"-\");\r\n  return [side as Side, align as Align] as const;\r\n}\r\n\r\nfunction isNotNull<T>(value: T | null): value is T {\r\n  return value !== null;\r\n}\r\n\r\ninterface SelectionRect {\r\n  top: number;\r\n  left: number;\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\ninterface StoreState {\r\n  open: boolean;\r\n  selectedText: string;\r\n  selectionRect: SelectionRect | null;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  notify: () => void;\r\n  batch: (fn: () => void) => void;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStoreContext(consumerName: string) {\r\n  const context = React.useContext(StoreContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nfunction useStore<T>(\r\n  selector: (state: StoreState) => T,\r\n  ogStore?: Store | null,\r\n): T {\r\n  const contextStore = React.useContext(StoreContext);\r\n\r\n  const store = ogStore ?? contextStore;\r\n\r\n  if (!store) {\r\n    throw new Error(`\\`useStore\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface SelectionToolbarProps extends DivProps {\r\n  open?: boolean;\r\n  onOpenChange?: (open: boolean) => void;\r\n  onSelectionChange?: (text: string) => void;\r\n  container?: HTMLElement | React.RefObject<HTMLElement | null> | null;\r\n  portalContainer?: Element | DocumentFragment | null;\r\n  side?: Side;\r\n  sideOffset?: number;\r\n  align?: Align;\r\n  alignOffset?: number;\r\n  avoidCollisions?: boolean;\r\n  collisionBoundary?: Boundary | Boundary[];\r\n  collisionPadding?: number | Partial<Record<Side, number>>;\r\n  sticky?: \"partial\" | \"always\";\r\n  hideWhenDetached?: boolean;\r\n  updatePositionStrategy?: \"optimized\" | \"always\";\r\n}\r\n\r\nfunction SelectionToolbar(props: SelectionToolbarProps) {\r\n  const {\r\n    open: openProp,\r\n    onOpenChange,\r\n    onSelectionChange,\r\n    container: containerProp,\r\n    portalContainer: portalContainerProp,\r\n    side = \"top\",\r\n    sideOffset = 8,\r\n    align = \"center\",\r\n    alignOffset = 0,\r\n    avoidCollisions = true,\r\n    collisionBoundary = [],\r\n    collisionPadding: collisionPaddingProp = 0,\r\n    sticky = \"partial\",\r\n    hideWhenDetached = false,\r\n    updatePositionStrategy = \"optimized\",\r\n    className,\r\n    style,\r\n    asChild,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    open: openProp ?? false,\r\n    selectedText: \"\",\r\n    selectionRect: null,\r\n  }));\r\n\r\n  const propsRef = useAsRef({\r\n    onOpenChange,\r\n    onSelectionChange,\r\n  });\r\n\r\n  const getContainer = React.useCallback((): HTMLElement | null => {\r\n    if (containerProp === undefined || containerProp === null) return null;\r\n    if (typeof containerProp === \"object\" && \"current\" in containerProp) {\r\n      return containerProp.current;\r\n    }\r\n    return containerProp;\r\n  }, [containerProp]);\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    let isBatching = false;\r\n\r\n    return {\r\n      subscribe: (callback) => {\r\n        listenersRef.current.add(callback);\r\n        return () => listenersRef.current.delete(callback);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n\r\n        if (key === \"open\" && typeof value === \"boolean\") {\r\n          stateRef.current.open = value;\r\n          propsRef.current.onOpenChange?.(value);\r\n        } else if (key === \"selectedText\" && typeof value === \"string\") {\r\n          stateRef.current.selectedText = value;\r\n          propsRef.current.onSelectionChange?.(value);\r\n        } else {\r\n          stateRef.current[key] = value;\r\n        }\r\n\r\n        if (!isBatching) {\r\n          store.notify();\r\n        }\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n      batch: (fn: () => void) => {\r\n        if (isBatching) {\r\n          fn();\r\n          return;\r\n        }\r\n        isBatching = true;\r\n        try {\r\n          fn();\r\n        } finally {\r\n          isBatching = false;\r\n          store.notify();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, propsRef]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (openProp !== undefined) {\r\n      store.setState(\"open\", openProp);\r\n    }\r\n  }, [openProp]);\r\n\r\n  const open = useStore((state) => state.open, store);\r\n  const selectionRect = useStore((state) => state.selectionRect, store);\r\n\r\n  const rafRef = React.useRef<number | null>(null);\r\n\r\n  const mounted = React.useSyncExternalStore(\r\n    () => () => {},\r\n    () => true,\r\n    () => false,\r\n  );\r\n\r\n  const virtualElement = React.useMemo(() => {\r\n    if (!selectionRect) return null;\r\n\r\n    return {\r\n      getBoundingClientRect: () => ({\r\n        x: selectionRect.left,\r\n        y: selectionRect.top,\r\n        width: selectionRect.width,\r\n        height: selectionRect.height,\r\n        top: selectionRect.top,\r\n        left: selectionRect.left,\r\n        right: selectionRect.left + selectionRect.width,\r\n        bottom: selectionRect.top + selectionRect.height,\r\n      }),\r\n    };\r\n  }, [selectionRect]);\r\n\r\n  const transformOrigin = React.useMemo<Middleware>(\r\n    () => ({\r\n      name: \"transformOrigin\",\r\n      fn(data) {\r\n        const { placement, rects } = data;\r\n        const [placedSide, placedAlign] =\r\n          getSideAndAlignFromPlacement(placement);\r\n        const noArrowAlign = { start: \"0%\", center: \"50%\", end: \"100%\" }[\r\n          placedAlign\r\n        ];\r\n\r\n        let x = \"\";\r\n        let y = \"\";\r\n\r\n        if (placedSide === \"bottom\") {\r\n          x = noArrowAlign;\r\n          y = \"0px\";\r\n        } else if (placedSide === \"top\") {\r\n          x = noArrowAlign;\r\n          y = `${rects.floating.height}px`;\r\n        } else if (placedSide === \"right\") {\r\n          x = \"0px\";\r\n          y = noArrowAlign;\r\n        } else if (placedSide === \"left\") {\r\n          x = `${rects.floating.width}px`;\r\n          y = noArrowAlign;\r\n        }\r\n        return { data: { x, y } };\r\n      },\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const desiredPlacement = React.useMemo(\r\n    () => (side + (align !== \"center\" ? `-${align}` : \"\")) as Placement,\r\n    [side, align],\r\n  );\r\n\r\n  const collisionPadding = React.useMemo(\r\n    () =>\r\n      typeof collisionPaddingProp === \"number\"\r\n        ? collisionPaddingProp\r\n        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp },\r\n    [collisionPaddingProp],\r\n  );\r\n\r\n  const boundary = React.useMemo(\r\n    () =>\r\n      Array.isArray(collisionBoundary)\r\n        ? collisionBoundary\r\n        : [collisionBoundary],\r\n    [collisionBoundary],\r\n  );\r\n\r\n  const hasExplicitBoundaries = boundary.length > 0;\r\n\r\n  const detectOverflowOptions = React.useMemo(\r\n    () => ({\r\n      padding: collisionPadding,\r\n      boundary: boundary.filter(isNotNull),\r\n      altBoundary: hasExplicitBoundaries,\r\n    }),\r\n    [collisionPadding, boundary, hasExplicitBoundaries],\r\n  );\r\n\r\n  const sizeMiddleware = React.useMemo(\r\n    () =>\r\n      size({\r\n        ...detectOverflowOptions,\r\n        apply: ({ elements, rects, availableWidth, availableHeight }) => {\r\n          const { width: anchorWidth, height: anchorHeight } = rects.reference;\r\n          const contentStyle = elements.floating.style;\r\n          contentStyle.setProperty(\r\n            \"--selection-toolbar-available-width\",\r\n            `${availableWidth}px`,\r\n          );\r\n          contentStyle.setProperty(\r\n            \"--selection-toolbar-available-height\",\r\n            `${availableHeight}px`,\r\n          );\r\n          contentStyle.setProperty(\r\n            \"--selection-toolbar-anchor-width\",\r\n            `${anchorWidth}px`,\r\n          );\r\n          contentStyle.setProperty(\r\n            \"--selection-toolbar-anchor-height\",\r\n            `${anchorHeight}px`,\r\n          );\r\n        },\r\n      }),\r\n    [detectOverflowOptions],\r\n  );\r\n\r\n  const middleware = React.useMemo<Array<Middleware | false | undefined>>(\r\n    () => [\r\n      offset({ mainAxis: sideOffset, alignmentAxis: alignOffset }),\r\n      avoidCollisions &&\r\n        shift({\r\n          mainAxis: true,\r\n          crossAxis: false,\r\n          limiter: sticky === \"partial\" ? limitShift() : undefined,\r\n          ...detectOverflowOptions,\r\n        }),\r\n      avoidCollisions && flip({ ...detectOverflowOptions }),\r\n      sizeMiddleware,\r\n      transformOrigin,\r\n      hideWhenDetached &&\r\n        hide({ strategy: \"referenceHidden\", ...detectOverflowOptions }),\r\n    ],\r\n    [\r\n      sideOffset,\r\n      alignOffset,\r\n      avoidCollisions,\r\n      sticky,\r\n      detectOverflowOptions,\r\n      sizeMiddleware,\r\n      transformOrigin,\r\n      hideWhenDetached,\r\n    ],\r\n  );\r\n\r\n  const { refs, floatingStyles, isPositioned, middlewareData } = useFloating({\r\n    open: open && !!virtualElement,\r\n    placement: desiredPlacement,\r\n    strategy: \"fixed\",\r\n    middleware,\r\n    whileElementsMounted: (reference, floating, update) => {\r\n      return autoUpdate(reference, floating, update, {\r\n        animationFrame: updatePositionStrategy === \"always\",\r\n      });\r\n    },\r\n    elements: {\r\n      reference: virtualElement,\r\n    },\r\n  });\r\n\r\n  const closeToolbar = React.useCallback(() => {\r\n    const state = store.getState();\r\n    if (state.open || state.selectedText || state.selectionRect) {\r\n      store.batch(() => {\r\n        store.setState(\"open\", false);\r\n        store.setState(\"selectedText\", \"\");\r\n        store.setState(\"selectionRect\", null);\r\n      });\r\n    }\r\n  }, [store]);\r\n\r\n  const updateSelection = React.useCallback(() => {\r\n    const selection = window.getSelection();\r\n    if (!selection || selection.rangeCount === 0) {\r\n      closeToolbar();\r\n      return;\r\n    }\r\n\r\n    const text = selection.toString().trim();\r\n    if (!text) {\r\n      closeToolbar();\r\n      return;\r\n    }\r\n\r\n    if (containerProp !== undefined) {\r\n      const resolvedContainer = getContainer();\r\n      if (!resolvedContainer) return;\r\n\r\n      const range = selection.getRangeAt(0);\r\n      const commonAncestor = range.commonAncestorContainer;\r\n      const element =\r\n        commonAncestor.nodeType === Node.ELEMENT_NODE\r\n          ? (commonAncestor as Element)\r\n          : commonAncestor.parentElement;\r\n\r\n      if (!element || !resolvedContainer.contains(element)) {\r\n        closeToolbar();\r\n        return;\r\n      }\r\n    }\r\n\r\n    const range = selection.getRangeAt(0);\r\n    const rect = range.getBoundingClientRect();\r\n\r\n    const state = store.getState();\r\n    const hasChanges =\r\n      state.selectedText !== text ||\r\n      !state.selectionRect ||\r\n      state.selectionRect.top !== rect.top ||\r\n      state.selectionRect.left !== rect.left ||\r\n      state.selectionRect.width !== rect.width ||\r\n      state.selectionRect.height !== rect.height ||\r\n      !state.open;\r\n\r\n    if (hasChanges) {\r\n      store.batch(() => {\r\n        store.setState(\"selectedText\", text);\r\n        store.setState(\"selectionRect\", {\r\n          top: rect.top,\r\n          left: rect.left,\r\n          width: rect.width,\r\n          height: rect.height,\r\n        });\r\n        store.setState(\"open\", true);\r\n      });\r\n    }\r\n  }, [containerProp, getContainer, store, closeToolbar]);\r\n\r\n  const scheduleUpdate = React.useCallback(() => {\r\n    if (rafRef.current !== null) return;\r\n    rafRef.current = requestAnimationFrame(() => {\r\n      if (store.getState().open) {\r\n        updateSelection();\r\n      }\r\n      rafRef.current = null;\r\n    });\r\n  }, [store, updateSelection]);\r\n\r\n  React.useEffect(() => {\r\n    const container = getContainer() ?? document;\r\n\r\n    function onMouseUp() {\r\n      requestAnimationFrame(() => {\r\n        updateSelection();\r\n      });\r\n    }\r\n\r\n    function onSelectionChange() {\r\n      const selection = window.getSelection();\r\n      if (!selection || !selection.toString().trim()) {\r\n        closeToolbar();\r\n      }\r\n    }\r\n\r\n    container.addEventListener(\"mouseup\", onMouseUp);\r\n    document.addEventListener(\"selectionchange\", onSelectionChange);\r\n    window.addEventListener(\"scroll\", scheduleUpdate, { passive: true });\r\n    window.addEventListener(\"resize\", scheduleUpdate, { passive: true });\r\n\r\n    return () => {\r\n      container.removeEventListener(\"mouseup\", onMouseUp);\r\n      document.removeEventListener(\"selectionchange\", onSelectionChange);\r\n      window.removeEventListener(\"scroll\", scheduleUpdate);\r\n      window.removeEventListener(\"resize\", scheduleUpdate);\r\n      if (rafRef.current !== null) {\r\n        cancelAnimationFrame(rafRef.current);\r\n        rafRef.current = null;\r\n      }\r\n    };\r\n  }, [getContainer, updateSelection, closeToolbar, scheduleUpdate]);\r\n\r\n  const clearSelection = React.useCallback(() => {\r\n    const selection = window.getSelection();\r\n    if (selection) {\r\n      selection.removeAllRanges();\r\n    }\r\n    closeToolbar();\r\n  }, [closeToolbar]);\r\n\r\n  React.useEffect(() => {\r\n    if (!open) return;\r\n\r\n    function onMouseDown(event: MouseEvent) {\r\n      const target = event.target as Node;\r\n      if (refs.floating.current && !refs.floating.current.contains(target)) {\r\n        clearSelection();\r\n      }\r\n    }\r\n\r\n    function onKeyDown(event: KeyboardEvent) {\r\n      if (event.key === \"Escape\") {\r\n        clearSelection();\r\n      }\r\n    }\r\n\r\n    document.addEventListener(\"mousedown\", onMouseDown);\r\n    document.addEventListener(\"keydown\", onKeyDown);\r\n\r\n    return () => {\r\n      document.removeEventListener(\"mousedown\", onMouseDown);\r\n      document.removeEventListener(\"keydown\", onKeyDown);\r\n    };\r\n  }, [open, refs.floating, clearSelection]);\r\n\r\n  const portalContainer =\r\n    portalContainerProp ?? (mounted ? globalThis.document?.body : null);\r\n\r\n  if (!portalContainer || !open) return null;\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      {ReactDOM.createPortal(\r\n        <div\r\n          ref={refs.setFloating}\r\n          style={{\r\n            ...floatingStyles,\r\n            transform: isPositioned\r\n              ? floatingStyles.transform\r\n              : \"translate(0, -200%)\",\r\n            minWidth: \"max-content\",\r\n            ...(middlewareData.hide?.referenceHidden && {\r\n              visibility: \"hidden\",\r\n              pointerEvents: \"none\",\r\n            }),\r\n          }}\r\n          data-state={isPositioned ? \"positioned\" : \"measuring\"}\r\n        >\r\n          <RootPrimitive\r\n            role=\"toolbar\"\r\n            aria-label=\"Text formatting toolbar\"\r\n            data-slot=\"selection-toolbar\"\r\n            data-state={open ? \"open\" : \"closed\"}\r\n            {...rootProps}\r\n            className={cn(\r\n              \"flex items-center gap-1 rounded-lg border bg-card px-1.5 py-1.5 shadow-lg outline-none\",\r\n              isPositioned &&\r\n                \"fade-in-0 zoom-in-95 animate-in duration-200 [animation-timing-function:cubic-bezier(0.16,1,0.3,1)]\",\r\n              \"motion-reduce:animate-none motion-reduce:transition-none\",\r\n              className,\r\n            )}\r\n            style={{\r\n              transformOrigin: middlewareData.transformOrigin\r\n                ? `${middlewareData.transformOrigin.x} ${middlewareData.transformOrigin.y}`\r\n                : undefined,\r\n              animation: !isPositioned ? \"none\" : undefined,\r\n              ...style,\r\n            }}\r\n          />\r\n        </div>,\r\n        portalContainer,\r\n      )}\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface SelectionToolbarItemProps\r\n  extends Omit<React.ComponentProps<typeof Button>, \"onSelect\"> {\r\n  onSelect?: (text: string, event: Event) => void;\r\n}\r\n\r\nfunction SelectionToolbarItem(props: SelectionToolbarItemProps) {\r\n  const {\r\n    onSelect: onSelectProp,\r\n    onClick: onClickProp,\r\n    onPointerDown: onPointerDownProp,\r\n    onPointerUp: onPointerUpProp,\r\n    className,\r\n    ref,\r\n    ...itemProps\r\n  } = props;\r\n\r\n  const store = useStoreContext(ITEM_NAME);\r\n\r\n  const propsRef = useAsRef({\r\n    onSelect: onSelectProp,\r\n    onClick: onClickProp,\r\n    onPointerDown: onPointerDownProp,\r\n    onPointerUp: onPointerUpProp,\r\n  });\r\n\r\n  const itemRef = React.useRef<ItemElement>(null);\r\n  const composedRef = useComposedRefs(ref, itemRef);\r\n  const pointerTypeRef =\r\n    React.useRef<React.PointerEvent[\"pointerType\"]>(\"touch\");\r\n\r\n  const onSelect = React.useCallback(() => {\r\n    const item = itemRef.current;\r\n    if (!item) return;\r\n\r\n    const text = store.getState().selectedText;\r\n\r\n    const selectEvent = new CustomEvent(\"selectiontoolbar.select\", {\r\n      bubbles: true,\r\n      cancelable: true,\r\n      detail: { text },\r\n    });\r\n\r\n    item.addEventListener(\r\n      \"selectiontoolbar.select\",\r\n      (event) => propsRef.current.onSelect?.(text, event),\r\n      {\r\n        once: true,\r\n      },\r\n    );\r\n\r\n    item.dispatchEvent(selectEvent);\r\n  }, [propsRef, store]);\r\n\r\n  const onPointerDown = React.useCallback(\r\n    (event: React.PointerEvent<ItemElement>) => {\r\n      pointerTypeRef.current = event.pointerType;\r\n      propsRef.current.onPointerDown?.(event);\r\n\r\n      if (event.pointerType === \"mouse\") {\r\n        event.preventDefault();\r\n      }\r\n    },\r\n    [propsRef],\r\n  );\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<ItemElement>) => {\r\n      propsRef.current.onClick?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (pointerTypeRef.current !== \"mouse\") {\r\n        onSelect();\r\n      }\r\n    },\r\n    [propsRef, onSelect],\r\n  );\r\n\r\n  const onPointerUp = React.useCallback(\r\n    (event: React.PointerEvent<ItemElement>) => {\r\n      propsRef.current.onPointerUp?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (pointerTypeRef.current === \"mouse\") {\r\n        onSelect();\r\n      }\r\n    },\r\n    [propsRef, onSelect],\r\n  );\r\n\r\n  return (\r\n    <Button\r\n      type=\"button\"\r\n      data-slot=\"selection-toolbar-item\"\r\n      variant=\"ghost\"\r\n      size=\"icon\"\r\n      {...itemProps}\r\n      className={cn(\"size-8\", className)}\r\n      ref={composedRef}\r\n      onPointerDown={onPointerDown}\r\n      onClick={onClick}\r\n      onPointerUp={onPointerUp}\r\n    />\r\n  );\r\n}\r\n\r\nfunction SelectionToolbarSeparator(props: DivProps) {\r\n  const { asChild, className, ...separatorProps } = props;\r\n\r\n  const SeparatorPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <SeparatorPrimitive\r\n      role=\"separator\"\r\n      aria-orientation=\"vertical\"\r\n      aria-hidden=\"true\"\r\n      data-slot=\"selection-toolbar-separator\"\r\n      {...separatorProps}\r\n      className={cn(\"mx-0.5 h-6 w-px bg-border\", className)}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  SelectionToolbar,\r\n  SelectionToolbarItem,\r\n  SelectionToolbarSeparator,\r\n  //\r\n  useStore as useSelectionToolbar,\r\n  //\r\n  type SelectionToolbarProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}