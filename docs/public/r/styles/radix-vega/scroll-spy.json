{
  "name": "scroll-spy",
  "dependencies": [
    "radix-ui"
  ],
  "registryDependencies": [
    "@diceui/use-as-ref",
    "@diceui/use-isomorphic-layout-effect",
    "@diceui/use-lazy-ref"
  ],
  "files": [
    {
      "path": "ui/scroll-spy.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  Direction as DirectionPrimitive,\r\n  Slot as SlotPrimitive,\r\n} from \"radix-ui\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { useAsRef } from \"@/registry/bases/radix/hooks/use-as-ref\";\r\nimport { useIsomorphicLayoutEffect } from \"@/registry/bases/radix/hooks/use-isomorphic-layout-effect\";\r\nimport { useLazyRef } from \"@/registry/bases/radix/hooks/use-lazy-ref\";\r\n\r\nconst ROOT_NAME = \"ScrollSpy\";\r\nconst NAV_NAME = \"ScrollSpyNav\";\r\nconst LINK_NAME = \"ScrollSpyLink\";\r\nconst VIEWPORT_NAME = \"ScrollSpyViewport\";\r\nconst SECTION_NAME = \"ScrollSpySection\";\r\n\r\ntype Direction = \"ltr\" | \"rtl\";\r\ntype Orientation = \"horizontal\" | \"vertical\";\r\n\r\ntype LinkElement = React.ComponentRef<typeof ScrollSpyLink>;\r\ntype SectionElement = React.ComponentRef<typeof ScrollSpySection>;\r\n\r\nfunction getDefaultScrollBehavior(): ScrollBehavior {\r\n  if (typeof window === \"undefined\") return \"smooth\";\r\n  return window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\r\n    ? \"auto\"\r\n    : \"smooth\";\r\n}\r\n\r\ninterface StoreState {\r\n  value: string;\r\n}\r\n\r\ninterface Store {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => StoreState;\r\n  setState: <K extends keyof StoreState>(key: K, value: StoreState[K]) => void;\r\n  notify: () => void;\r\n}\r\n\r\nconst StoreContext = React.createContext<Store | null>(null);\r\n\r\nfunction useStore<T>(\r\n  selector: (state: StoreState) => T,\r\n  ogStore?: Store | null,\r\n): T {\r\n  const contextStore = React.useContext(StoreContext);\r\n\r\n  const store = ogStore ?? contextStore;\r\n\r\n  if (!store) {\r\n    throw new Error(`\\`useStore\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface ScrollSpyContextValue {\r\n  offset: number;\r\n  scrollBehavior: ScrollBehavior;\r\n  dir: Direction;\r\n  orientation: Orientation;\r\n  scrollContainer: HTMLElement | null;\r\n  isScrollingRef: React.RefObject<boolean>;\r\n  onSectionRegister: (id: string, element: SectionElement) => void;\r\n  onSectionUnregister: (id: string) => void;\r\n  onScrollToSection: (sectionId: string) => void;\r\n}\r\n\r\nconst ScrollSpyContext = React.createContext<ScrollSpyContextValue | null>(\r\n  null,\r\n);\r\n\r\nfunction useScrollSpyContext(consumerName: string) {\r\n  const context = React.useContext(ScrollSpyContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface ScrollSpyProps extends React.ComponentProps<\"div\"> {\r\n  value?: string;\r\n  defaultValue?: string;\r\n  onValueChange?: (value: string) => void;\r\n  rootMargin?: string;\r\n  threshold?: number | number[];\r\n  offset?: number;\r\n  scrollBehavior?: ScrollBehavior;\r\n  scrollContainer?: HTMLElement | null;\r\n  dir?: Direction;\r\n  orientation?: Orientation;\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction ScrollSpy(props: ScrollSpyProps) {\r\n  const {\r\n    value,\r\n    defaultValue,\r\n    onValueChange,\r\n    rootMargin,\r\n    threshold = 0.1,\r\n    offset = 0,\r\n    scrollBehavior = getDefaultScrollBehavior(),\r\n    scrollContainer = null,\r\n    dir: dirProp,\r\n    orientation = \"horizontal\",\r\n    asChild,\r\n    className,\r\n    ...rootProps\r\n  } = props;\r\n\r\n  const dir = DirectionPrimitive.useDirection(dirProp);\r\n\r\n  const stateRef = useLazyRef<StoreState>(() => ({\r\n    value: value ?? defaultValue ?? \"\",\r\n  }));\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n  const onValueChangeRef = useAsRef(onValueChange);\r\n\r\n  const store = React.useMemo<Store>(() => {\r\n    return {\r\n      subscribe: (cb) => {\r\n        listenersRef.current.add(cb);\r\n        return () => listenersRef.current.delete(cb);\r\n      },\r\n      getState: () => {\r\n        return stateRef.current;\r\n      },\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n\r\n        stateRef.current[key] = value;\r\n\r\n        if (key === \"value\" && value) {\r\n          onValueChangeRef.current?.(value);\r\n        }\r\n\r\n        store.notify();\r\n      },\r\n      notify: () => {\r\n        for (const cb of listenersRef.current) {\r\n          cb();\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef, onValueChangeRef]);\r\n\r\n  const sectionMapRef = React.useRef(new Map<string, Element>());\r\n  const isScrollingRef = React.useRef(false);\r\n  const rafIdRef = React.useRef<number | null>(null);\r\n  const isMountedRef = React.useRef(false);\r\n  const scrollTimeoutRef = React.useRef<number | null>(null);\r\n\r\n  const onSectionRegister = React.useCallback(\r\n    (id: string, element: SectionElement) => {\r\n      sectionMapRef.current.set(id, element);\r\n    },\r\n    [],\r\n  );\r\n\r\n  const onSectionUnregister = React.useCallback((id: string) => {\r\n    sectionMapRef.current.delete(id);\r\n  }, []);\r\n\r\n  const onScrollToSection = React.useCallback(\r\n    (sectionId: string) => {\r\n      const section = scrollContainer\r\n        ? scrollContainer.querySelector(`#${sectionId}`)\r\n        : document.getElementById(sectionId);\r\n\r\n      if (!section) {\r\n        store.setState(\"value\", sectionId);\r\n        return;\r\n      }\r\n\r\n      // Set flag to prevent observer from firing during programmatic scroll\r\n      isScrollingRef.current = true;\r\n      store.setState(\"value\", sectionId);\r\n\r\n      if (scrollContainer) {\r\n        const containerRect = scrollContainer.getBoundingClientRect();\r\n        const sectionRect = section.getBoundingClientRect();\r\n        const scrollTop = scrollContainer.scrollTop;\r\n        const offsetPosition =\r\n          sectionRect.top - containerRect.top + scrollTop - offset;\r\n\r\n        scrollContainer.scrollTo({\r\n          top: offsetPosition,\r\n          behavior: scrollBehavior,\r\n        });\r\n      } else {\r\n        const sectionPosition = section.getBoundingClientRect().top;\r\n        const offsetPosition = sectionPosition + window.scrollY - offset;\r\n\r\n        window.scrollTo({\r\n          top: offsetPosition,\r\n          behavior: scrollBehavior,\r\n        });\r\n      }\r\n\r\n      if (scrollTimeoutRef.current !== null) {\r\n        clearTimeout(scrollTimeoutRef.current);\r\n      }\r\n\r\n      scrollTimeoutRef.current = window.setTimeout(() => {\r\n        isScrollingRef.current = false;\r\n      }, 500);\r\n    },\r\n    [scrollContainer, offset, scrollBehavior, store],\r\n  );\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const currentValue = value ?? defaultValue;\r\n    if (currentValue === undefined) return;\r\n\r\n    if (!isMountedRef.current) {\r\n      isMountedRef.current = true;\r\n      store.setState(\"value\", currentValue);\r\n      return;\r\n    }\r\n\r\n    onScrollToSection(currentValue);\r\n  }, [value, onScrollToSection]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const sectionMap = sectionMapRef.current;\r\n    if (sectionMap.size === 0) return;\r\n\r\n    const observerRootMargin = rootMargin ?? `${-offset}px 0px -70% 0px`;\r\n\r\n    const observer = new IntersectionObserver(\r\n      (entries) => {\r\n        if (isScrollingRef.current) return;\r\n\r\n        if (rafIdRef.current !== null) {\r\n          cancelAnimationFrame(rafIdRef.current);\r\n        }\r\n\r\n        rafIdRef.current = requestAnimationFrame(() => {\r\n          const intersecting = entries.filter((entry) => entry.isIntersecting);\r\n\r\n          if (intersecting.length === 0) return;\r\n\r\n          const topmost = intersecting.reduce((prev, curr) => {\r\n            return curr.boundingClientRect.top < prev.boundingClientRect.top\r\n              ? curr\r\n              : prev;\r\n          });\r\n\r\n          const id = topmost.target.id;\r\n          if (id && sectionMap.has(id)) {\r\n            store.setState(\"value\", id);\r\n          }\r\n        });\r\n      },\r\n      {\r\n        root: scrollContainer,\r\n        rootMargin: observerRootMargin,\r\n        threshold,\r\n      },\r\n    );\r\n\r\n    for (const element of sectionMap.values()) {\r\n      observer.observe(element);\r\n    }\r\n\r\n    return () => {\r\n      observer.disconnect();\r\n      if (rafIdRef.current !== null) {\r\n        cancelAnimationFrame(rafIdRef.current);\r\n      }\r\n      if (scrollTimeoutRef.current !== null) {\r\n        clearTimeout(scrollTimeoutRef.current);\r\n      }\r\n    };\r\n  }, [offset, rootMargin, threshold, scrollContainer]);\r\n\r\n  const contextValue = React.useMemo<ScrollSpyContextValue>(\r\n    () => ({\r\n      dir,\r\n      orientation,\r\n      offset,\r\n      scrollBehavior,\r\n      scrollContainer,\r\n      isScrollingRef,\r\n      onSectionRegister,\r\n      onSectionUnregister,\r\n      onScrollToSection,\r\n    }),\r\n    [\r\n      dir,\r\n      orientation,\r\n      offset,\r\n      scrollBehavior,\r\n      scrollContainer,\r\n      onSectionRegister,\r\n      onSectionUnregister,\r\n      onScrollToSection,\r\n    ],\r\n  );\r\n\r\n  const RootPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <StoreContext.Provider value={store}>\r\n      <ScrollSpyContext.Provider value={contextValue}>\r\n        <RootPrimitive\r\n          data-orientation={orientation}\r\n          data-slot=\"scroll-spy\"\r\n          dir={dir}\r\n          {...rootProps}\r\n          className={cn(\r\n            \"flex\",\r\n            orientation === \"horizontal\" ? \"flex-row\" : \"flex-col\",\r\n            className,\r\n          )}\r\n        />\r\n      </ScrollSpyContext.Provider>\r\n    </StoreContext.Provider>\r\n  );\r\n}\r\n\r\ninterface ScrollSpyNavProps extends React.ComponentProps<\"nav\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction ScrollSpyNav(props: ScrollSpyNavProps) {\r\n  const { asChild, className, ...navProps } = props;\r\n\r\n  const { dir, orientation } = useScrollSpyContext(NAV_NAME);\r\n\r\n  const NavPrimitive = asChild ? SlotPrimitive.Slot : \"nav\";\r\n\r\n  return (\r\n    <NavPrimitive\r\n      data-orientation={orientation}\r\n      data-slot=\"scroll-spy-nav\"\r\n      dir={dir}\r\n      {...navProps}\r\n      className={cn(\r\n        \"flex gap-2\",\r\n        orientation === \"horizontal\" ? \"flex-col\" : \"flex-row\",\r\n        className,\r\n      )}\r\n    />\r\n  );\r\n}\r\n\r\ninterface ScrollSpyLinkProps extends React.ComponentProps<\"a\"> {\r\n  value: string;\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction ScrollSpyLink(props: ScrollSpyLinkProps) {\r\n  const { value: linkValue, asChild, onClick, className, ...linkProps } = props;\r\n\r\n  const { orientation, onScrollToSection } = useScrollSpyContext(LINK_NAME);\r\n  const value = useStore((state) => state.value);\r\n  const isActive = value === linkValue;\r\n\r\n  const onLinkClick = React.useCallback(\r\n    (event: React.MouseEvent<LinkElement>) => {\r\n      event.preventDefault();\r\n      onClick?.(event);\r\n      onScrollToSection(linkValue);\r\n    },\r\n    [linkValue, onClick, onScrollToSection],\r\n  );\r\n\r\n  const LinkPrimitive = asChild ? SlotPrimitive.Slot : \"a\";\r\n\r\n  return (\r\n    <LinkPrimitive\r\n      data-orientation={orientation}\r\n      data-slot=\"scroll-spy-link\"\r\n      data-state={isActive ? \"active\" : \"inactive\"}\r\n      {...linkProps}\r\n      href={asChild ? undefined : `#${linkValue}`}\r\n      className={cn(\r\n        \"rounded px-3 py-1.5 font-medium text-muted-foreground text-sm transition-colors hover:bg-accent hover:text-accent-foreground data-[state=active]:bg-accent data-[state=active]:text-foreground\",\r\n        className,\r\n      )}\r\n      onClick={onLinkClick}\r\n    />\r\n  );\r\n}\r\n\r\ninterface ScrollSpyViewportProps extends React.ComponentProps<\"div\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction ScrollSpyViewport(props: ScrollSpyViewportProps) {\r\n  const { asChild, className, ...viewportProps } = props;\r\n\r\n  const { dir, orientation } = useScrollSpyContext(VIEWPORT_NAME);\r\n\r\n  const ViewportPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <ViewportPrimitive\r\n      data-orientation={orientation}\r\n      data-slot=\"scroll-spy-viewport\"\r\n      dir={dir}\r\n      {...viewportProps}\r\n      className={cn(\"flex flex-1 flex-col gap-8\", className)}\r\n    />\r\n  );\r\n}\r\n\r\ninterface ScrollSpySectionProps extends React.ComponentProps<\"div\"> {\r\n  value: string;\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction ScrollSpySection(props: ScrollSpySectionProps) {\r\n  const { asChild, ref, value, ...sectionProps } = props;\r\n\r\n  const { orientation, onSectionRegister, onSectionUnregister } =\r\n    useScrollSpyContext(SECTION_NAME);\r\n  const sectionRef = React.useRef<SectionElement>(null);\r\n  const composedRef = useComposedRefs(ref, sectionRef);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const element = sectionRef.current;\r\n    if (!element || !value) return;\r\n\r\n    onSectionRegister(value, element);\r\n\r\n    return () => {\r\n      onSectionUnregister(value);\r\n    };\r\n  }, [value, onSectionRegister, onSectionUnregister]);\r\n\r\n  const SectionPrimitive = asChild ? SlotPrimitive.Slot : \"div\";\r\n\r\n  return (\r\n    <SectionPrimitive\r\n      data-orientation={orientation}\r\n      data-slot=\"scroll-spy-section\"\r\n      {...sectionProps}\r\n      id={value}\r\n      ref={composedRef}\r\n    />\r\n  );\r\n}\r\n\r\nexport {\r\n  ScrollSpy,\r\n  ScrollSpyLink,\r\n  ScrollSpyNav,\r\n  ScrollSpySection,\r\n  ScrollSpyViewport,\r\n  //\r\n  type ScrollSpyProps,\r\n};\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "lib/compose-refs.ts",
      "content": "import * as React from \"react\";\r\n\r\ntype PossibleRef<T> = React.Ref<T> | undefined;\r\n\r\n/**\r\n * Set a given ref to a given value\r\n * This utility takes care of different types of refs: callback refs and RefObject(s)\r\n */\r\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\r\n  if (typeof ref === \"function\") {\r\n    return ref(value);\r\n  }\r\n\r\n  if (ref !== null && ref !== undefined) {\r\n    ref.current = value;\r\n  }\r\n}\r\n\r\n/**\r\n * A utility to compose multiple refs together\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  return (node) => {\r\n    let hasCleanup = false;\r\n    const cleanups = refs.map((ref) => {\r\n      const cleanup = setRef(ref, node);\r\n      if (!hasCleanup && typeof cleanup === \"function\") {\r\n        hasCleanup = true;\r\n      }\r\n      return cleanup;\r\n    });\r\n\r\n    // React <19 will log an error to the console if a callback ref returns a\r\n    // value. We don't use ref cleanups internally so this will only happen if a\r\n    // user's ref callback returns a value, which we only expect if they are\r\n    // using the cleanup functionality added in React 19.\r\n    if (hasCleanup) {\r\n      return () => {\r\n        for (let i = 0; i < cleanups.length; i++) {\r\n          const cleanup = cleanups[i];\r\n          if (typeof cleanup === \"function\") {\r\n            cleanup();\r\n          } else {\r\n            setRef(refs[i], null);\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * A custom hook that composes multiple refs\r\n * Accepts callback refs and RefObject(s)\r\n */\r\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we want to memoize by all values\r\n  return React.useCallback(composeRefs(...refs), refs);\r\n}\r\n\r\nexport { composeRefs, useComposedRefs };\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "type": "registry:ui"
}