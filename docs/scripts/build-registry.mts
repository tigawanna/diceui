/**
 * @see https://github.com/shadcn-ui/ui/blob/main/apps/v4/scripts/build-registry.mts
 */

import { existsSync, promises as fs } from "node:fs";
import { tmpdir } from "node:os";
import path from "node:path";
import { cwd } from "node:process";
import { rimraf } from "rimraf";
import {
  registryItemSchema,
  type registryItemTypeSchema,
  registrySchema,
} from "shadcn/schema";
import { Project, ScriptKind, SyntaxKind } from "ts-morph";
import type { z } from "zod";
import { type RegistryBase, registries } from "../registry";
import { STYLES } from "../registry/styles";
import { fixImport } from "./fix-imports.mts";

const REGISTRY_PATH = path.join(process.cwd(), "public/r");
const STYLES_PATH = path.join(REGISTRY_PATH, "styles");

const REGISTRY_INDEX_WHITELIST: z.infer<typeof registryItemTypeSchema>[] = [
  "registry:ui",
  "registry:lib",
  "registry:hook",
  "registry:theme",
  "registry:block",
  "registry:example",
  "registry:component",
  "registry:internal",
  "registry:style",
];

// Define bases to build
const BASES: RegistryBase[] = ["radix", "base"];

// Map styles for compatibility
const styles = STYLES.map((s) => ({ name: s.name, label: s.title }));

// Build all base-style combination names
function getStylesToBuild() {
  const stylesToBuild: { name: string; label: string; base: RegistryBase }[] =
    [];
  for (const baseName of BASES) {
    for (const style of styles) {
      stylesToBuild.push({
        name: `${baseName}-${style.name}`,
        label: `${style.label}`,
        base: baseName,
      });
    }
  }
  return stylesToBuild;
}

const project = new Project({
  compilerOptions: {},
});

async function createTempSourceFile(filename: string) {
  const dir = await fs.mkdtemp(path.join(tmpdir(), "shadcn-"));
  return path.join(dir, filename);
}

// ----------------------------------------------------------------------------
// Build __registry__/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry() {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, Record<string, any>> = {
`;

  for (const baseName of BASES) {
    const registry = registries[baseName];

    index += `  "${baseName}": {`;

    for (const style of styles) {
      index += `
    "${style.name}": {`;

      // Build style index.
      for (const item of registry.items) {
        const resolveFiles = item.files?.map(
          (file) =>
            `registry/bases/${baseName}/${
              typeof file === "string" ? file : file.path
            }`,
        );
        if (!resolveFiles) {
          continue;
        }

        const type = item.type.split(":")[1];
        let sourceFilename = "";

        // biome-ignore lint/suspicious/noExplicitAny: chunks can contain various types from AST parsing
        let chunks: any = [];
        if (item.type === "registry:block") {
          const file = resolveFiles[0];
          const filename = path.basename(file);
          let raw: string;
          try {
            raw = await fs.readFile(file, "utf8");
          } catch (_error) {
            continue;
          }
          const tempFile = await createTempSourceFile(filename);
          const sourceFile = project.createSourceFile(tempFile, raw, {
            scriptKind: ScriptKind.TSX,
          });

          const description = sourceFile
            .getVariableDeclaration("description")
            ?.getInitializerOrThrow()
            .asKindOrThrow(SyntaxKind.StringLiteral)
            .getLiteralValue();

          item.description = description ?? "";

          // Find all imports.
          const imports = new Map<
            string,
            {
              module: string;
              text: string;
              isDefault?: boolean;
            }
          >();
          for (const node of sourceFile.getImportDeclarations()) {
            const module = node.getModuleSpecifier().getLiteralValue();
            for (const importItem of node.getNamedImports()) {
              imports.set(importItem.getText(), {
                module,
                text: node.getText(),
              });
            }

            const defaultImport = node.getDefaultImport();
            if (defaultImport) {
              imports.set(defaultImport.getText(), {
                module,
                text: defaultImport.getText(),
                isDefault: true,
              });
            }
          }

          // Find all opening tags with x-chunk attribute.
          const components = sourceFile
            .getDescendantsOfKind(SyntaxKind.JsxOpeningElement)
            .filter((node) => {
              return node.getAttribute("x-chunk") !== undefined;
            });

          chunks = await Promise.all(
            components.map(async (component, chunkIndex) => {
              const chunkName = `${item.name}-chunk-${chunkIndex}`;

              // Get the value of x-chunk attribute.
              const attr = component
                .getAttributeOrThrow("x-chunk")
                .asKindOrThrow(SyntaxKind.JsxAttribute);

              const chunkDescription = attr
                .getInitializerOrThrow()
                .asKindOrThrow(SyntaxKind.StringLiteral)
                .getLiteralValue();

              // Delete the x-chunk attribute.
              attr.remove();

              // Add a new attribute to the component.
              component.addAttribute({
                name: "x-chunk",
                initializer: `"${chunkName}"`,
              });

              // Get the value of x-chunk-container attribute.
              const containerAttr = component
                .getAttribute("x-chunk-container")
                ?.asKindOrThrow(SyntaxKind.JsxAttribute);

              const containerClassName = containerAttr
                ?.getInitializer()
                ?.asKindOrThrow(SyntaxKind.StringLiteral)
                .getLiteralValue();

              containerAttr?.remove();

              const parentJsxElement = component.getParentIfKindOrThrow(
                SyntaxKind.JsxElement,
              );

              // Find all opening tags on component.
              const children = parentJsxElement
                .getDescendantsOfKind(SyntaxKind.JsxOpeningElement)
                .map((node) => {
                  return node.getTagNameNode().getText();
                })
                .concat(
                  parentJsxElement
                    .getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement)
                    .map((node) => {
                      return node.getTagNameNode().getText();
                    }),
                );

              const componentImports = new Map<
                string,
                string | string[] | Set<string>
              >();
              for (const child of children) {
                const importLine = imports.get(child);
                if (importLine) {
                  const existingImports =
                    componentImports.get(importLine.module) || [];

                  const newImports = importLine.isDefault
                    ? importLine.text
                    : new Set([...existingImports, child]);

                  componentImports.set(
                    importLine.module,
                    importLine?.isDefault ? newImports : Array.from(newImports),
                  );
                }
              }

              const componentImportLines = Array.from(
                componentImports.keys(),
              ).map((key) => {
                const values = componentImports.get(key);
                const specifier = Array.isArray(values)
                  ? `{${values.join(",")}}`
                  : values;

                return `import ${specifier} from "${key}"`;
              });

              const code = `
            'use client'

            ${componentImportLines.join("\n")}

            export default function Component() {
              return (${parentJsxElement.getText()})
            }`;

              const targetFile = file.replace(item.name, `${chunkName}`);
              const targetFilePath = path.join(
                cwd(),
                `registry/bases/${baseName}/${type}/${chunkName}.tsx`,
              );

              // Write component file.
              rimraf.sync(targetFilePath);
              await fs.writeFile(targetFilePath, code, "utf8");

              return {
                name: chunkName,
                description: chunkDescription,
                component: `React.lazy(() => import("@/registry/bases/${baseName}/${type}/${chunkName}")),`,
                file: targetFile,
                container: {
                  className: containerClassName,
                },
              };
            }),
          );

          // // Write the source file for blocks only.
          sourceFilename = `__registry__/${baseName}/${style.name}/${type}/${item.name}.tsx`;

          if (item.files) {
            const files = item.files.map((file) =>
              typeof file === "string"
                ? { type: "registry:page", path: file }
                : file,
            );
            if (files?.length) {
              sourceFilename = `__registry__/${baseName}/${style.name}/${files[0].path}`;
            }
          }

          const sourcePath = path.join(process.cwd(), sourceFilename);
          if (!existsSync(sourcePath)) {
            await fs.mkdir(sourcePath, { recursive: true });
          }

          rimraf.sync(sourcePath);
          await fs.writeFile(sourcePath, sourceFile.getText());
        }

        let componentPath = `@/registry/bases/${baseName}/${type}/${item.name}`;

        if (item.files) {
          const files = item.files.map((file) =>
            typeof file === "string"
              ? { type: "registry:page", path: file }
              : file,
          );
          if (files?.length) {
            componentPath = `@/registry/bases/${baseName}/${files[0].path}`;
          }
        }

        // Skip component generation for metadata-only entries
        const shouldGenerateComponent =
          item.files &&
          item.files.length > 0 &&
          !["index", "style"].includes(item.name);

        index += `
      "${item.name}": {
        name: "${item.name}",
        description: "${item.description ?? ""}",
        type: "${item.type}",
        registryDependencies: ${JSON.stringify(item.registryDependencies)},
        files: [${item.files?.map((file) => {
          const filePath = `registry/bases/${baseName}/${
            typeof file === "string" ? file : file.path
          }`;
          const resolvedFilePath = path.resolve(filePath);
          return typeof file === "string"
            ? `"${resolvedFilePath}"`
            : `{
          path: "${filePath}",
          type: "${file.type}",
          target: "${file.target ?? ""}"
        }`;
        })}],${
          shouldGenerateComponent
            ? `
        component: React.lazy(() => import("${componentPath}")),`
            : ""
        }
        source: "${sourceFilename}",
        chunks: [${chunks.map(
          (chunk) => `{
          name: "${chunk.name}",
          description: "${chunk.description ?? "No description"}",
          component: ${chunk.component}
          file: "${chunk.file}",
          container: {
            className: "${chunk.container.className}"
          }
        }`,
        )}]
      },`;
      }

      index += `
    },`;
    }

    index += `
  },`;
  }

  index += `
}
`;

  // Write style index.
  rimraf.sync(path.join(process.cwd(), "__registry__/index.tsx"));
  await fs.writeFile(path.join(process.cwd(), "__registry__/index.tsx"), index);
}

// ----------------------------------------------------------------------------
// Build public/r/styles/{base}-{style}/registry.json and index.json.
// ----------------------------------------------------------------------------
async function buildRegistryJson() {
  const stylesToBuild = getStylesToBuild();

  for (const { name: styleName, base: baseName } of stylesToBuild) {
    const registry = registries[baseName];
    const outputDir = path.join(STYLES_PATH, styleName);
    await fs.mkdir(outputDir, { recursive: true });

    // ----------------------------------------------------------------------------
    // Build index.json (UI components only).
    // ----------------------------------------------------------------------------
    const uiItems = registry.items
      .filter((item) => ["registry:ui"].includes(item.type))
      .map((item) => {
        return {
          ...item,
          files: item.files?.map((_file) => {
            const file =
              typeof _file === "string"
                ? {
                    path: _file,
                    type: item.type,
                  }
                : _file;

            return file;
          }),
        };
      });
    const indexJson = JSON.stringify(uiItems, null, 2);
    await fs.writeFile(path.join(outputDir, "index.json"), indexJson, "utf8");

    // ----------------------------------------------------------------------------
    // Build registry.json (full registry object).
    // ----------------------------------------------------------------------------
    const allItems = registry.items
      .filter((item) => REGISTRY_INDEX_WHITELIST.includes(item.type))
      .filter((item) => item.name !== "index") // Skip index item
      .map((item) => {
        return {
          ...item,
          files: item.files?.map((_file) => {
            const file =
              typeof _file === "string"
                ? {
                    path: _file,
                    type: item.type,
                  }
                : _file;

            return file;
          }),
        };
      });
    const fullRegistry = {
      name: registry.name,
      homepage: registry.homepage,
      items: allItems,
    };
    const registryJson = JSON.stringify(fullRegistry, null, 2);
    await fs.writeFile(
      path.join(outputDir, "registry.json"),
      registryJson,
      "utf8",
    );
  }
}

// ----------------------------------------------------------------------------
// Build public/r/styles/index.json listing all available styles.
// ----------------------------------------------------------------------------
async function buildStylesIndex() {
  const stylesToBuild = getStylesToBuild();
  const stylesIndex = stylesToBuild.map(({ name, label, base }) => ({
    name,
    label,
    base,
  }));

  await fs.mkdir(STYLES_PATH, { recursive: true });
  await fs.writeFile(
    path.join(STYLES_PATH, "index.json"),
    JSON.stringify(stylesIndex, null, 2),
    "utf8",
  );
}

// ----------------------------------------------------------------------------
// Build public/r/index.json (top-level UI component listing, like shadcn).
// Uses the default base ("radix") as the primary registry index.
// ----------------------------------------------------------------------------
async function buildRootIndex() {
  const defaultBase: RegistryBase = "radix";
  const registry = registries[defaultBase];

  const uiItems = registry.items
    .filter((item) => ["registry:ui"].includes(item.type))
    .map((item) => {
      // biome-ignore lint/suspicious/noExplicitAny: registry item types vary
      const mapped: Record<string, any> = {
        name: item.name,
        type: item.type,
      };

      if (item.dependencies && item.dependencies.length > 0) {
        mapped.dependencies = item.dependencies;
      }

      if (item.registryDependencies && item.registryDependencies.length > 0) {
        mapped.registryDependencies = item.registryDependencies;
      }

      if (item.files) {
        mapped.files = item.files.map((_file) => {
          const file =
            typeof _file === "string"
              ? { path: _file, type: item.type }
              : _file;
          return { path: file.path, type: file.type };
        });
      }

      return mapped;
    });

  await fs.writeFile(
    path.join(REGISTRY_PATH, "index.json"),
    JSON.stringify(uiItems, null, 2),
    "utf8",
  );
}

// ----------------------------------------------------------------------------
// Build public/r/styles/{base}-{style}/[name].json for each base-style combo.
// ----------------------------------------------------------------------------
async function buildStyles() {
  const stylesToBuild = getStylesToBuild();

  for (const { name: styleName, base: baseName } of stylesToBuild) {
    const registry = registries[baseName];
    const outputDir = path.join(STYLES_PATH, styleName);
    await fs.mkdir(outputDir, { recursive: true });

    for (const item of registry.items) {
      if (!REGISTRY_INDEX_WHITELIST.includes(item.type)) {
        continue;
      }

      // Skip "index" item to avoid overwriting the UI component listing
      if (item.name === "index") {
        continue;
      }

      // biome-ignore lint/suspicious/noExplicitAny: files array can contain various registry item types
      let files: any[] = [];
      if (item.files) {
        files = await Promise.all(
          item.files.map(async (_file) => {
            const file =
              typeof _file === "string"
                ? {
                    path: _file,
                    type: item.type,
                    content: "",
                    target: "",
                  }
                : _file;

            let content: string;
            try {
              content = await fs.readFile(
                path.join(
                  process.cwd(),
                  "registry",
                  "bases",
                  baseName,
                  file.path,
                ),
                "utf8",
              );

              // Only fix imports for v0- blocks.
              if (item.name.startsWith("v0-")) {
                content = fixImport(content);
              }
            } catch (_error) {
              return;
            }

            const tempFile = await createTempSourceFile(file.path);
            const sourceFile = project.createSourceFile(tempFile, content, {
              scriptKind: ScriptKind.TSX,
            });

            sourceFile.getVariableDeclaration("iframeHeight")?.remove();
            sourceFile.getVariableDeclaration("containerClassName")?.remove();
            sourceFile.getVariableDeclaration("description")?.remove();

            let target = file.target || "";

            if ((!target || target === "") && item.name.startsWith("v0-")) {
              const fileName = file.path.split("/").pop();
              if (
                file.type === "registry:block" ||
                file.type === "registry:component" ||
                file.type === "registry:example"
              ) {
                target = `components/${fileName}`;
              }

              if (file.type === "registry:ui") {
                target = `components/ui/${fileName}`;
              }

              if (file.type === "registry:hook") {
                target = `hooks/${fileName}`;
              }

              if (file.type === "registry:lib") {
                target = `lib/${fileName}`;
              }
            }

            return {
              path: file.path,
              type: file.type,
              content: sourceFile.getText(),
              target,
            };
          }),
        );
      }

      const payload = registryItemSchema.safeParse({
        ...item,
        files,
      });

      if (payload.success) {
        // Write to public/r/styles/{base}-{style}/{name}.json
        await fs.writeFile(
          path.join(outputDir, `${item.name}.json`),
          JSON.stringify(payload.data, null, 2),
          "utf8",
        );
      }
    }
  }
}

try {
  const totalStart = performance.now();

  // Validate all registries
  for (const baseName of BASES) {
    const registry = registries[baseName];
    const result = registrySchema.safeParse(registry);

    if (!result.success) {
      console.error(`Error in ${baseName} registry:`, result.error);
      process.exit(1);
    }
  }

  // Clean styles output directory
  console.log("üßπ Cleaning styles output directory...");
  await rimraf(STYLES_PATH);
  await fs.mkdir(STYLES_PATH, { recursive: true });

  console.log("üèóÔ∏è  Building __registry__/index.tsx...");
  await buildRegistry();

  console.log("üì¶ Building styles index...");
  await buildStylesIndex();

  console.log("üìã Building public/r/index.json...");
  await buildRootIndex();

  const stylesToBuild = getStylesToBuild();
  console.log(`üíÖ Building ${stylesToBuild.length} style variants...`);

  // Build registry JSON and individual items for each style
  await buildRegistryJson();
  await buildStyles();

  for (const style of stylesToBuild) {
    console.log(`   ‚úÖ ${style.name}`);
  }

  const elapsed = ((performance.now() - totalStart) / 1000).toFixed(2);
  console.log(`\n‚úÖ Build complete in ${elapsed}s!`);
} catch (error) {
  console.error(error);
  process.exit(1);
}
